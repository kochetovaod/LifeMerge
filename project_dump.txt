=== PROJECT DUMP ===
Generated: 2025-12-15T22:58:16+04:00
Root: /home/oksana/projects/LifeMerge

=== TREE (FILES ONLY) ===
.
├── combine_md.sh
├── debug_skipped_files.log
├── debug_skipped.log
├── project_dump.txt
├── Backend
│   ├── alembic.ini
│   ├── docker-compose.yml
│   ├── Dockerfile
│   ├── .env.example
│   ├── .gitignore
│   ├── README.md
│   ├── requirements.txt
│   ├── alembic
│   │   ├── env.py
│   │   ├── script.py.mako
│   │   └── versions
│   │       └── 0001_init.py
│   ├── app
│   │   ├── __init__.py
│   │   ├── main.py
│   │   ├── api
│   │   │   ├── deps.py
│   │   │   ├── idempotency.py
│   │   │   ├── __init__.py
│   │   │   ├── router.py
│   │   │   └── v1
│   │   │       ├── auth.py
│   │   │       ├── __init__.py
│   │   │       └── tasks.py
│   │   ├── core
│   │   │   ├── config.py
│   │   │   ├── __init__.py
│   │   │   ├── logging.py
│   │   │   ├── response.py
│   │   │   └── security.py
│   │   ├── db
│   │   │   ├── base.py
│   │   │   ├── init_db.py
│   │   │   ├── __init__.py
│   │   │   └── session.py
│   │   ├── middleware
│   │   │   ├── __init__.py
│   │   │   ├── rate_limit.py
│   │   │   └── request_context.py
│   │   ├── models
│   │   │   ├── idempotency.py
│   │   │   ├── __init__.py
│   │   │   ├── refresh_token.py
│   │   │   ├── task.py
│   │   │   └── user.py
│   │   ├── repositories
│   │   │   ├── idempotency_repo.py
│   │   │   ├── __init__.py
│   │   │   ├── refresh_tokens_repo.py
│   │   │   ├── tasks_repo.py
│   │   │   └── users_repo.py
│   │   ├── schemas
│   │   │   ├── auth.py
│   │   │   ├── common.py
│   │   │   ├── __init__.py
│   │   │   ├── tasks.py
│   │   │   └── user.py
│   │   └── services
│   │       ├── auth_service.py
│   │       ├── events.py
│   │       ├── __init__.py
│   │       └── tasks_service.py
│   └── LifeMerge_docs
│       ├── 00_Administration
│       │   ├── Decisions_Log.md
│       │   ├── Glossary.md
│       │   ├── Project_Charter.md
│       │   ├── Team_Roles_and_Contacts.md
│       │   └── Meeting_Notes
│       │       ├── Template_Meeting_Note.md
│       │       └── MEETING NOTE — Strategic MVP Planning 
│       │           ├── Mobile Sprint 01 — Technical Breakdown (Jira-ready).md
│       │           ├──  Sprint 01–02.md
│       │           ├── Sprint01.md
│       │           ├── Sprint02.md
│       │           ├── Sprint Do R Do D.md
│       │           └── Sprint Planning.md
│       ├── 01_Product
│       │   ├── MVP_Scope_v1.md
│       │   ├── Change_Management
│       │   │   └── Change_Management_Process.md
│       │   ├── Metrics
│       │   │   ├── Alerts_And_Thresholds.md
│       │   │   ├── Dashboards_Structure.md
│       │   │   ├── Events_Specification.md
│       │   │   └── Metrics_Plan.md
│       │   ├── Product_Vision
│       │   │   ├── Competitors_Comparison.md
│       │   │   ├── Product_Vision.md
│       │   │   ├── Value_Proposition.md
│       │   │   └── Personas
│       │   │       ├── Persona_1.md
│       │   │       ├── Persona_2.md
│       │   │       └── Persona_3.md
│       │   ├── Roadmap
│       │   │   ├── Roadmap_Pro_Stages.md
│       │   │   └── Roadmap_Stages.md
│       │   └── User_Stories
│       │       ├── User_Stories_All.md
│       │       └── User_Story_Map.md
│       ├── 02_Design
│       │   ├── Interaction_Guidelines.md
│       │   ├── Branding
│       │   │   ├── Brand_Guidelines.md
│       │   │   └── Logo
│       │   │       ├── logo1.svg
│       │   │       ├── logo.png
│       │   │       └── logo.svg
│       │   ├── Prototypes
│       │   │   ├── Dark_Mode
│       │   │   │   └── Readme.md
│       │   │   ├── Mobile
│       │   │   │   ├── AI_Planner.png
│       │   │   │   ├── Calendar_Day.png
│       │   │   │   ├── Calendar_Week.png
│       │   │   │   ├── Finance_Dashboard.png
│       │   │   │   ├── Inbox.png
│       │   │   │   └── Tasks_List.png
│       │   │   ├── Notes
│       │   │   │   └── MVP_Wireframes.md
│       │   │   └── Web_Future
│       │   │       ├── Readme.md
│       │   │       ├── High_Fidelity
│       │   │       │   ├── Calendar_Week_HighFi.png
│       │   │       │   ├── Dashboard_Web_HighFi.png
│       │   │       │   ├── Finance_Analytics_Web.png
│       │   │       │   └── Settings_Web.png
│       │   │       ├── Notes
│       │   │       │   ├── Web_Adaptive_Design_Principles.md
│       │   │       │   └── Web_Navigation_Concepts.md
│       │   │       └── Wireframes
│       │   │           ├── Calendar_Week_Wireframe.png
│       │   │           ├── Dashboard_Web_Wireframe.png
│       │   │           └── Tasks_Panel_Wireframe.png
│       │   └── UI_Kit
│       │       ├── Colors.md
│       │       ├── Dark_Theme.md
│       │       ├── Design_Tokens.json
│       │       ├── Typography.md
│       │       ├── UI_Kit_v1.0.md
│       │       ├── UI Kit & Wireframes figma.md
│       │       └── Components
│       │           ├── Buttons.md
│       │           ├── Cards.md
│       │           ├── Chips.md
│       │           ├── Inputs.md
│       │           ├── Modals.md
│       │           └── Navigation.md
│       ├── 03_Technical
│       │   ├── AI
│       │   │   └── JSON Schema
│       │   │       ├── calendar_min.json
│       │   │       ├── goals_min.json
│       │   │       ├── metadata.json
│       │   │       ├── plan_week_request.json
│       │   │       ├── plan_week_response.json
│       │   │       ├── preferences.json
│       │   │       └── tasks_min.json
│       │   ├── API
│       │   │   ├── AI_Planner_API.md
│       │   │   ├── Auth_API.md
│       │   │   ├── Calendar_API.md
│       │   │   ├── Finance_API.md
│       │   │   ├── Goals_API.md
│       │   │   ├── Inbox_API.md
│       │   │   ├── OpenAPI.yaml
│       │   │   └── Tasks_API.md
│       │   ├── Architecture
│       │   │   ├── AI_Architecture.md
│       │   │   ├── Backend_Architecture.md
│       │   │   ├── Mobile_Architecture_Flutter.md
│       │   │   ├── Offline_Sync_Design.md
│       │   │   ├── Personalization_ML_Spec.md
│       │   │   ├── System_Architecture.md
│       │   │   └── Data_Model
│       │   │       ├── Database_Schema.sql
│       │   │       └── ER_Diagram.png
│       │   ├── DevOps
│       │   │   ├── CI_CD_Pipeline.md
│       │   │   ├── Deployment_Guide.md
│       │   │   ├── Deployment_Plan.md
│       │   │   ├── Environments.md
│       │   │   ├── Infrastructure_Spec.md
│       │   │   └── Monitoring_and_Logging.md
│       │   ├── Requirements
│       │   │   ├── API_Requirements.md
│       │   │   ├── Functional_Requirements.md
│       │   │   ├── NonFunctional_Requirements.md
│       │   │   └── Technical_Specification.md
│       │   └── Security
│       │       ├── Authentication.md
│       │       ├── Data_Protection.md
│       │       └── Threat_Model.md
│       ├── 04_Development
│       │   ├── Backlog
│       │   │   ├── Bugs.md
│       │   │   ├── Features.md
│       │   │   └── Tech_Debt.md
│       │   ├── Coding_Standards
│       │   │   ├── API_Usage_Guide.md
│       │   │   ├── Architecture_Rules.md
│       │   │   ├── Dart_Style_Guide.md
│       │   │   └── Flutter_Best_Practices.md
│       │   └── Sprint_Planning
│       │       └── Template_Sprint_Plan.md
│       ├── 05_QA
│       │   ├── QA_Plan.md
│       │   ├── Automation
│       │   │   └── CI_Test_Config.md
│       │   └── Checklists
│       │       ├── Regression_Checklist.md
│       │       ├── Release_Checklist.md
│       │       └── Smoke_Test_Checklist.md
│       └── 06_Release
│           ├── Release_Plan.md
│           ├── AppStore
│           │   ├── Description.md
│           │   └── Privacy_Policy.md
│           └── Beta_Testing
│               ├── Beta_Feedback.md
│               └── Invitations.md
├── Docs
│   ├── Detailed Project Plan.md
│   ├── Dor_DoD.md
│   ├── Metrics Plan.md
│   ├── TECHNICAL SPECIFICATIONS.md
│   ├── ДИЗАЙН-ПРОТОТИПЫ.md
│   ├── Техническое задание.md
│   └── LifeMerge
│       ├── 00_Administration
│       │   ├── Decisions_Log.md
│       │   ├── Glossary.md
│       │   ├── Project_Charter.md
│       │   ├── Team_Roles_and_Contacts.md
│       │   └── Meeting_Notes
│       │       ├── Template_Meeting_Note.md
│       │       └── MEETING NOTE — Strategic MVP Planning 
│       │           ├── Mobile Sprint 01 — Technical Breakdown (Jira-ready).md
│       │           ├──  Sprint 01–02.md
│       │           ├── Sprint Do R Do D.md
│       │           └── Sprint Planning.md
│       ├── 01_Product
│       │   ├── MVP_Scope_v1.md
│       │   ├── Change_Management
│       │   │   └── Change_Management_Process.md
│       │   ├── Metrics
│       │   │   ├── Alerts_And_Thresholds.md
│       │   │   ├── Dashboards_Structure.md
│       │   │   ├── Events_Specification.md
│       │   │   └── Metrics_Plan.md
│       │   ├── Product_Vision
│       │   │   ├── Competitors_Comparison.md
│       │   │   ├── Product_Vision.md
│       │   │   ├── Value_Proposition.md
│       │   │   └── Personas
│       │   │       ├── Persona_1.md
│       │   │       ├── Persona_2.md
│       │   │       └── Persona_3.md
│       │   ├── Roadmap
│       │   │   ├── Roadmap_Pro_Stages.md
│       │   │   └── Roadmap_Stages.md
│       │   └── User_Stories
│       │       ├── User_Stories_All.md
│       │       └── User_Story_Map.md
│       ├── 02_Design
│       │   ├── Interaction_Guidelines.md
│       │   ├── Branding
│       │   │   ├── Brand_Guidelines.md
│       │   │   └── Logo
│       │   │       ├── logo1.svg
│       │   │       ├── logo.png
│       │   │       └── logo.svg
│       │   ├── Prototypes
│       │   │   ├── Dark_Mode
│       │   │   │   └── Readme.md
│       │   │   ├── Mobile
│       │   │   │   ├── AI_Planner.png
│       │   │   │   ├── Calendar_Day.png
│       │   │   │   ├── Calendar_Week.png
│       │   │   │   ├── Finance_Dashboard.png
│       │   │   │   ├── Inbox.png
│       │   │   │   └── Tasks_List.png
│       │   │   ├── Notes
│       │   │   │   └── MVP_Wireframes.md
│       │   │   └── Web_Future
│       │   │       ├── Readme.md
│       │   │       ├── High_Fidelity
│       │   │       │   ├── Calendar_Week_HighFi.png
│       │   │       │   ├── Dashboard_Web_HighFi.png
│       │   │       │   ├── Finance_Analytics_Web.png
│       │   │       │   └── Settings_Web.png
│       │   │       ├── Notes
│       │   │       │   ├── Web_Adaptive_Design_Principles.md
│       │   │       │   └── Web_Navigation_Concepts.md
│       │   │       └── Wireframes
│       │   │           ├── Calendar_Week_Wireframe.png
│       │   │           ├── Dashboard_Web_Wireframe.png
│       │   │           └── Tasks_Panel_Wireframe.png
│       │   └── UI_Kit
│       │       ├── Colors.md
│       │       ├── Dark_Theme.md
│       │       ├── Design_Tokens.json
│       │       ├── Typography.md
│       │       ├── UI_Kit_v1.0.md
│       │       ├── UI Kit & Wireframes figma.md
│       │       └── Components
│       │           ├── Buttons.md
│       │           ├── Cards.md
│       │           ├── Chips.md
│       │           ├── Inputs.md
│       │           ├── Modals.md
│       │           └── Navigation.md
│       ├── 03_Technical
│       │   ├── AI
│       │   │   └── JSON Schema
│       │   │       ├── calendar_min.json
│       │   │       ├── goals_min.json
│       │   │       ├── metadata.json
│       │   │       ├── plan_week_request.json
│       │   │       ├── plan_week_response.json
│       │   │       ├── preferences.json
│       │   │       └── tasks_min.json
│       │   ├── API
│       │   │   ├── AI_Planner_API.md
│       │   │   ├── Auth_API.md
│       │   │   ├── Calendar_API.md
│       │   │   ├── Finance_API.md
│       │   │   ├── Goals_API.md
│       │   │   ├── Inbox_API.md
│       │   │   ├── OpenAPI.yaml
│       │   │   └── Tasks_API.md
│       │   ├── Architecture
│       │   │   ├── AI_Architecture.md
│       │   │   ├── Backend_Architecture.md
│       │   │   ├── Mobile_Architecture_Flutter.md
│       │   │   ├── Offline_Sync_Design.md
│       │   │   ├── Personalization_ML_Spec.md
│       │   │   ├── System_Architecture.md
│       │   │   └── Data_Model
│       │   │       ├── Database_Schema.sql
│       │   │       └── ER_Diagram.png
│       │   ├── DevOps
│       │   │   ├── CI_CD_Pipeline.md
│       │   │   ├── Deployment_Guide.md
│       │   │   ├── Deployment_Plan.md
│       │   │   ├── Environments.md
│       │   │   ├── Infrastructure_Spec.md
│       │   │   └── Monitoring_and_Logging.md
│       │   ├── Requirements
│       │   │   ├── API_Requirements.md
│       │   │   ├── Functional_Requirements.md
│       │   │   ├── NonFunctional_Requirements.md
│       │   │   └── Technical_Specification.md
│       │   └── Security
│       │       ├── Authentication.md
│       │       ├── Data_Protection.md
│       │       └── Threat_Model.md
│       ├── 04_Development
│       │   ├── Backlog
│       │   │   ├── Bugs.md
│       │   │   ├── Features.md
│       │   │   └── Tech_Debt.md
│       │   ├── Coding_Standards
│       │   │   ├── API_Usage_Guide.md
│       │   │   ├── Architecture_Rules.md
│       │   │   ├── Dart_Style_Guide.md
│       │   │   └── Flutter_Best_Practices.md
│       │   └── Sprint_Planning
│       │       └── Template_Sprint_Plan.md
│       ├── 05_QA
│       │   ├── QA_Plan.md
│       │   ├── Automation
│       │   │   └── CI_Test_Config.md
│       │   └── Checklists
│       │       ├── Regression_Checklist.md
│       │       ├── Release_Checklist.md
│       │       └── Smoke_Test_Checklist.md
│       └── 06_Release
│           ├── Release_Plan.md
│           ├── AppStore
│           │   ├── Description.md
│           │   └── Privacy_Policy.md
│           └── Beta_Testing
│               ├── Beta_Feedback.md
│               └── Invitations.md
└── Flutter
    ├── analysis_options.yaml
    ├── .gitignore
    ├── pubspec.yaml
    ├── README.md
    ├── docs
    │   ├── ARCHITECTURE.md
    │   └── Sprint01_Skeleton.md
    ├── lib
    │   ├── main.dart
    │   ├── app
    │   │   ├── app.dart
    │   │   └── bootstrap.dart
    │   ├── application
    │   │   └── .keep
    │   ├── core
    │   │   ├── analytics
    │   │   │   └── analytics_service.dart
    │   │   ├── di
    │   │   │   └── providers.dart
    │   │   ├── l10n
    │   │   │   └── app_localizations.dart
    │   │   ├── routing
    │   │   │   ├── app_router.dart
    │   │   │   └── routes.dart
    │   │   └── theme
    │   │       ├── app_colors.dart
    │   │       ├── app_theme.dart
    │   │       └── app_typography.dart
    │   ├── data
    │   │   └── .keep
    │   ├── domain
    │   │   └── .keep
    │   ├── features
    │   │   ├── .keep
    │   │   ├── auth
    │   │   │   ├── application
    │   │   │   │   ├── auth_controller.dart
    │   │   │   │   └── auth_state.dart
    │   │   │   ├── data
    │   │   │   │   ├── auth_api_service.dart
    │   │   │   │   ├── auth_repository.dart
    │   │   │   │   └── session_storage.dart
    │   │   │   ├── domain
    │   │   │   │   └── auth_error_code.dart
    │   │   │   └── presentation
    │   │   │       ├── login_screen.dart
    │   │   │       ├── register_screen.dart
    │   │   │       └── widgets
    │   │   │           ├── auth_text_field.dart
    │   │   │           └── primary_button.dart
    │   │   ├── calendar
    │   │   │   ├── application
    │   │   │   │   ├── calendar_controller.dart
    │   │   │   │   └── calendar_state.dart
    │   │   │   ├── data
    │   │   │   │   ├── calendar_api_service.dart
    │   │   │   │   └── calendar_repository.dart
    │   │   │   ├── domain
    │   │   │   │   └── calendar_event.dart
    │   │   │   └── presentation
    │   │   │       ├── calendar_day_screen.dart
    │   │   │       └── widgets
    │   │   │           └── event_form_sheet.dart
    │   │   ├── inbox
    │   │   │   └── presentation
    │   │   │       └── inbox_screen.dart
    │   │   ├── onboarding
    │   │   │   └── presentation
    │   │   │       └── onboarding_screen.dart
    │   │   ├── pro
    │   │   │   └── presentation
    │   │   │       └── pro_screen.dart
    │   │   ├── settings
    │   │   │   └── presentation
    │   │   │       └── settings_screen.dart
    │   │   ├── shell
    │   │   │   └── presentation
    │   │   │       └── app_shell.dart
    │   │   └── tasks
    │   │       ├── application
    │   │       │   ├── tasks_controller.dart
    │   │       │   └── tasks_state.dart
    │   │       ├── data
    │   │       │   ├── tasks_api_service.dart
    │   │       │   └── tasks_repository.dart
    │   │       ├── domain
    │   │       │   └── task.dart
    │   │       └── presentation
    │   │           ├── tasks_screen.dart
    │   │           └── widgets
    │   │               ├── task_form_sheet.dart
    │   │               └── task_list_item.dart
    │   └── presentation
    │       └── .keep
    └── LifeMerge_docs
        ├── 00_Administration
        │   ├── Decisions_Log.md
        │   ├── Glossary.md
        │   ├── Project_Charter.md
        │   ├── Team_Roles_and_Contacts.md
        │   └── Meeting_Notes
        │       ├── Template_Meeting_Note.md
        │       └── MEETING NOTE — Strategic MVP Planning 
        │           ├── Mobile Sprint 01 — Technical Breakdown (Jira-ready).md
        │           ├──  Sprint 01–02.md
        │           ├── Sprint01.md
        │           ├── Sprint02.md
        │           ├── Sprint Do R Do D.md
        │           └── Sprint Planning.md
        ├── 01_Product
        │   ├── MVP_Scope_v1.md
        │   ├── Change_Management
        │   │   └── Change_Management_Process.md
        │   ├── Metrics
        │   │   ├── Alerts_And_Thresholds.md
        │   │   ├── Dashboards_Structure.md
        │   │   ├── Events_Specification.md
        │   │   └── Metrics_Plan.md
        │   ├── Product_Vision
        │   │   ├── Competitors_Comparison.md
        │   │   ├── Product_Vision.md
        │   │   ├── Value_Proposition.md
        │   │   └── Personas
        │   │       ├── Persona_1.md
        │   │       ├── Persona_2.md
        │   │       └── Persona_3.md
        │   ├── Roadmap
        │   │   ├── Roadmap_Pro_Stages.md
        │   │   └── Roadmap_Stages.md
        │   └── User_Stories
        │       ├── User_Stories_All.md
        │       └── User_Story_Map.md
        ├── 02_Design
        │   ├── Interaction_Guidelines.md
        │   ├── Branding
        │   │   ├── Brand_Guidelines.md
        │   │   └── Logo
        │   │       ├── logo1.svg
        │   │       ├── logo.png
        │   │       └── logo.svg
        │   ├── Prototypes
        │   │   ├── Dark_Mode
        │   │   │   └── Readme.md
        │   │   ├── Mobile
        │   │   │   ├── AI_Planner.png
        │   │   │   ├── Calendar_Day.png
        │   │   │   ├── Calendar_Week.png
        │   │   │   ├── Finance_Dashboard.png
        │   │   │   ├── Inbox.png
        │   │   │   └── Tasks_List.png
        │   │   ├── Notes
        │   │   │   └── MVP_Wireframes.md
        │   │   └── Web_Future
        │   │       ├── Readme.md
        │   │       ├── High_Fidelity
        │   │       │   ├── Calendar_Week_HighFi.png
        │   │       │   ├── Dashboard_Web_HighFi.png
        │   │       │   ├── Finance_Analytics_Web.png
        │   │       │   └── Settings_Web.png
        │   │       ├── Notes
        │   │       │   ├── Web_Adaptive_Design_Principles.md
        │   │       │   └── Web_Navigation_Concepts.md
        │   │       └── Wireframes
        │   │           ├── Calendar_Week_Wireframe.png
        │   │           ├── Dashboard_Web_Wireframe.png
        │   │           └── Tasks_Panel_Wireframe.png
        │   └── UI_Kit
        │       ├── Colors.md
        │       ├── Dark_Theme.md
        │       ├── Design_Tokens.json
        │       ├── Typography.md
        │       ├── UI_Kit_v1.0.md
        │       ├── UI Kit & Wireframes figma.md
        │       └── Components
        │           ├── Buttons.md
        │           ├── Cards.md
        │           ├── Chips.md
        │           ├── Inputs.md
        │           ├── Modals.md
        │           └── Navigation.md
        ├── 03_Technical
        │   ├── AI
        │   │   └── JSON Schema
        │   │       ├── calendar_min.json
        │   │       ├── goals_min.json
        │   │       ├── metadata.json
        │   │       ├── plan_week_request.json
        │   │       ├── plan_week_response.json
        │   │       ├── preferences.json
        │   │       └── tasks_min.json
        │   ├── API
        │   │   ├── AI_Planner_API.md
        │   │   ├── Auth_API.md
        │   │   ├── Calendar_API.md
        │   │   ├── Finance_API.md
        │   │   ├── Goals_API.md
        │   │   ├── Inbox_API.md
        │   │   ├── OpenAPI.yaml
        │   │   └── Tasks_API.md
        │   ├── Architecture
        │   │   ├── AI_Architecture.md
        │   │   ├── Backend_Architecture.md
        │   │   ├── Mobile_Architecture_Flutter.md
        │   │   ├── Offline_Sync_Design.md
        │   │   ├── Personalization_ML_Spec.md
        │   │   ├── System_Architecture.md
        │   │   └── Data_Model
        │   │       ├── Database_Schema.sql
        │   │       └── ER_Diagram.png
        │   ├── DevOps
        │   │   ├── CI_CD_Pipeline.md
        │   │   ├── Deployment_Guide.md
        │   │   ├── Deployment_Plan.md
        │   │   ├── Environments.md
        │   │   ├── Infrastructure_Spec.md
        │   │   └── Monitoring_and_Logging.md
        │   ├── Requirements
        │   │   ├── API_Requirements.md
        │   │   ├── Functional_Requirements.md
        │   │   ├── NonFunctional_Requirements.md
        │   │   └── Technical_Specification.md
        │   └── Security
        │       ├── Authentication.md
        │       ├── Data_Protection.md
        │       └── Threat_Model.md
        ├── 04_Development
        │   ├── Backlog
        │   │   ├── Bugs.md
        │   │   ├── Features.md
        │   │   └── Tech_Debt.md
        │   ├── Coding_Standards
        │   │   ├── API_Usage_Guide.md
        │   │   ├── Architecture_Rules.md
        │   │   ├── Dart_Style_Guide.md
        │   │   └── Flutter_Best_Practices.md
        │   └── Sprint_Planning
        │       └── Template_Sprint_Plan.md
        ├── 05_QA
        │   ├── QA_Plan.md
        │   ├── Automation
        │   │   └── CI_Test_Config.md
        │   └── Checklists
        │       ├── Regression_Checklist.md
        │       ├── Release_Checklist.md
        │       └── Smoke_Test_Checklist.md
        └── 06_Release
            ├── Release_Plan.md
            ├── AppStore
            │   ├── Description.md
            │   └── Privacy_Policy.md
            └── Beta_Testing
                ├── Beta_Feedback.md
                └── Invitations.md

187 directories, 458 files

=== FILE CONTENTS ===
========================================
FILE: ./Backend/alembic/env.py
========================================

from __future__ import annotations

import asyncio
from logging.config import fileConfig
from pathlib import Path
import sys

from alembic import context
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config

BASE_DIR = Path(__file__).resolve().parent.parent
sys.path.append(str(BASE_DIR))

from app.core.config import settings
from app.db.base import Base
from app.models import idempotency, refresh_token, task, user  # noqa: F401

config = context.config

if config.config_file_name is not None:
    fileConfig(config.config_file_name)

config.set_main_option("sqlalchemy.url", settings.DATABASE_URL)

target_metadata = Base.metadata


def run_migrations_offline() -> None:
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        compare_type=True,
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    context.configure(connection=connection, target_metadata=target_metadata, compare_type=True)

    with context.begin_transaction():
        context.run_migrations()


async def run_migrations_online() -> None:
    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
        future=True,
    )

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

    await connectable.dispose()


if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())


========================================
FILE: ./Backend/alembic.ini
========================================

[alembic]
script_location = alembic
prepend_sys_path = .
version_locations = alembic/versions

sqlalchemy.url = %(DATABASE_URL)s

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = INFO
handlers = console

[logger_sqlalchemy]
level = WARN
handlers = console
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers = console
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stdout,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s


========================================
FILE: ./Backend/alembic/script.py.mako
========================================

"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}
"""
from __future__ import annotations

from alembic import op
import sqlalchemy as sa

${imports if imports else ""}

revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}


========================================
FILE: ./Backend/alembic/versions/0001_init.py
========================================

"""Initial tables for users, tasks, refresh tokens, idempotency keys.

Revision ID: 0001_init
Revises: 
Create Date: 2025-12-14
"""

from __future__ import annotations

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql


revision = "0001_init"
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    op.create_table(
        "users",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("email", sa.String(length=320), nullable=False),
        sa.Column("password_hash", sa.String(length=255), nullable=False),
        sa.Column("full_name", sa.String(length=200), nullable=True),
        sa.Column("timezone", sa.String(length=64), nullable=False, server_default="UTC"),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("NOW()")),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("NOW()")),
        sa.Column("deleted", sa.Boolean(), nullable=False, server_default=sa.text("FALSE")),
    )
    op.create_index("ix_users_email", "users", ["email"], unique=True)

    op.create_table(
        "tasks",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("user_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("title", sa.String(length=300), nullable=False),
        sa.Column("description", sa.Text(), nullable=True),
        sa.Column("status", sa.String(length=32), nullable=False, server_default="todo"),
        sa.Column("priority", sa.Integer(), nullable=True),
        sa.Column("estimated_minutes", sa.Integer(), nullable=True),
        sa.Column("energy_level", sa.Integer(), nullable=True),
        sa.Column("goal_id", postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column("due_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("NOW()")),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("NOW()")),
        sa.Column("deleted", sa.Boolean(), nullable=False, server_default=sa.text("FALSE")),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"], name="fk_tasks_user_id_users"),
    )
    op.create_index("ix_tasks_user_id", "tasks", ["user_id"], unique=False)
    op.create_index("ix_tasks_user_id_updated_at", "tasks", ["user_id", "updated_at"], unique=False)

    op.create_table(
        "refresh_tokens",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("user_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("device_id", sa.String(length=128), nullable=False),
        sa.Column("token_hash", sa.String(length=64), nullable=False),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("revoked", sa.Boolean(), nullable=False, server_default=sa.text("FALSE")),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("NOW()")),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"], name="fk_refresh_tokens_user_id_users"),
    )
    op.create_index("ix_refresh_tokens_user_id", "refresh_tokens", ["user_id"], unique=False)
    op.create_index("ix_refresh_tokens_device_id", "refresh_tokens", ["device_id"], unique=False)
    op.create_index("uq_refresh_tokens_token_hash", "refresh_tokens", ["token_hash"], unique=True)

    op.create_table(
        "idempotency_keys",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("user_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("key", sa.String(length=128), nullable=False),
        sa.Column("method", sa.String(length=8), nullable=False),
        sa.Column("path", sa.String(length=200), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("NOW()")),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"], name="fk_idempotency_user_id_users"),
        sa.UniqueConstraint("user_id", "key", "method", "path", name="uq_idem_user_key"),
    )
    op.create_index("ix_idempotency_user_id", "idempotency_keys", ["user_id"], unique=False)


def downgrade() -> None:
    op.drop_index("ix_idempotency_user_id", table_name="idempotency_keys")
    op.drop_table("idempotency_keys")

    op.drop_index("uq_refresh_tokens_token_hash", table_name="refresh_tokens")
    op.drop_index("ix_refresh_tokens_device_id", table_name="refresh_tokens")
    op.drop_index("ix_refresh_tokens_user_id", table_name="refresh_tokens")
    op.drop_table("refresh_tokens")

    op.drop_index("ix_tasks_user_id_updated_at", table_name="tasks")
    op.drop_index("ix_tasks_user_id", table_name="tasks")
    op.drop_table("tasks")

    op.drop_index("ix_users_email", table_name="users")
    op.drop_table("users")


========================================
FILE: ./Backend/app/api/deps.py
========================================

from __future__ import annotations

import uuid

from fastapi import Depends, HTTPException, Request
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.response import err
from app.core.security import decode_token
from app.db.session import get_db
from app.models.user import User

bearer_scheme = HTTPBearer(auto_error=False)


async def get_current_user(
    request: Request,
    creds: HTTPAuthorizationCredentials | None = Depends(bearer_scheme),
    db: AsyncSession = Depends(get_db),
) -> User:
    if creds is None or not creds.credentials:
        raise HTTPException(status_code=401, detail=err(request, "unauthorized", "Missing bearer token"))

    try:
        payload = decode_token(creds.credentials)
    except Exception:
        raise HTTPException(status_code=401, detail=err(request, "unauthorized", "Invalid token"))

    if payload.get("type") != "access":
        raise HTTPException(status_code=401, detail=err(request, "unauthorized", "Invalid token type"))

    raw_uid = payload.get("uid")
    if not raw_uid:
        raise HTTPException(status_code=401, detail=err(request, "unauthorized", "Invalid token payload"))

    try:
        uid = uuid.UUID(str(raw_uid))
    except Exception:
        raise HTTPException(status_code=401, detail=err(request, "unauthorized", "Invalid token payload"))

    res = await db.execute(select(User).where(User.id == uid, User.deleted == False))  # noqa: E712
    user = res.scalar_one_or_none()
    if not user:
        raise HTTPException(status_code=401, detail=err(request, "unauthorized", "User not found"))
    return user


========================================
FILE: ./Backend/app/api/idempotency.py
========================================

from __future__ import annotations

from fastapi import Depends, Header, HTTPException, Request
from sqlalchemy import select
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.response import err
from app.db.session import get_db
from app.models.idempotency import IdempotencyKey
from app.models.user import User


async def enforce_idempotency(
    request: Request,
    current_user: User,
    db: AsyncSession,
    request_id: str | None,
    idempotency_key: str | None,
) -> None:
    key = idempotency_key or request_id
    if not key:
        raise HTTPException(status_code=400, detail=err(request, "validation_error", "request_id or X-Idempotency-Key is required"))

    rec = IdempotencyKey(user_id=current_user.id, key=key, method=request.method, path=request.url.path)
    db.add(rec)
    try:
        await db.flush()
    except IntegrityError:
        # repeated request; in full impl we'd return stored response
        raise HTTPException(status_code=409, detail=err(request, "idempotency_conflict", "Duplicate request_id/X-Idempotency-Key"))


async def idempotency_dependency(
    request: Request,
    current_user: User,
    db: AsyncSession = Depends(get_db),
    x_idempotency_key: str | None = Header(default=None, alias="X-Idempotency-Key"),
) -> None:
    # request_id typically supplied in body, but FastAPI can't access it generically here.
    # Each handler should pass the body.request_id into enforce_idempotency.
    await enforce_idempotency(request, current_user, db, request_id=None, idempotency_key=x_idempotency_key)


========================================
FILE: ./Backend/app/api/__init__.py
========================================

Здесь пока пусто

========================================
FILE: ./Backend/app/api/router.py
========================================

from __future__ import annotations

from fastapi import APIRouter

from app.api.v1.auth import router as auth_router
from app.api.v1.tasks import router as tasks_router

api_router = APIRouter()
api_router.include_router(auth_router, tags=["auth"])
api_router.include_router(tasks_router, tags=["tasks"])


========================================
FILE: ./Backend/app/api/v1/auth.py
========================================

from __future__ import annotations

from fastapi import APIRouter, Depends, Header, HTTPException, Request
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.response import err, ok
from app.core.logging import log
from app.db.session import get_db
from app.middleware.rate_limit import forgot_rate_limit, signup_rate_limit
from app.schemas.auth import AuthOut, ForgotIn, LoginIn, LogoutIn, RefreshIn, ResetIn, SignupIn
from app.schemas.user import UserOut
from app.services.auth_service import (
    RefreshError,
    authenticate_user,
    create_user,
    get_user_by_email,
    issue_tokens,
    refresh_tokens,
    revoke_device_tokens,
)
from app.services.events import publish_event
from app.api.deps import get_current_user

router = APIRouter(prefix="/auth")


@router.post("/signup", response_model=AuthOut, dependencies=[signup_rate_limit])
async def signup(
    request: Request,
    body: SignupIn,
    db: AsyncSession = Depends(get_db),
    x_device_id: str | None = Header(default=None, alias="X-Device-Id"),
):
    existing = await get_user_by_email(db, body.email)
    if existing:
        raise HTTPException(status_code=409, detail=err(request, "user_exists", "User already exists"))

    try:
        user = await create_user(db, body.email, body.password, body.full_name, body.timezone)
        device_id = x_device_id or "default"
        access, refresh = await issue_tokens(db, user, device_id)
        await db.commit()
    except IntegrityError:
        await db.rollback()
        raise HTTPException(status_code=409, detail=err(request, "user_exists", "User already exists"))

    publish_event(
        name="User_SignUp",
        request_id=request.state.request_id,
        user_id=str(user.id),
        payload={"device_id": device_id},
    )

    log.info(
        "auth_signup",
        request_id=request.state.request_id,
        user_id=str(user.id),
        device_id=device_id,
        timezone=user.timezone,
    )

    return ok(
        request,
        {
            "user": UserOut.model_validate(user),
            "access_token": access,
            "refresh_token": refresh,
        },
    )


@router.post("/login", response_model=AuthOut)
async def login(request: Request, body: LoginIn, db: AsyncSession = Depends(get_db)):
    user = await authenticate_user(db, body.email, body.password)
    if not user:
        raise HTTPException(status_code=401, detail=err(request, "invalid_credentials", "Invalid email or password"))

    access, refresh = await issue_tokens(db, user, body.device_id)
    await db.commit()

    log.info(
        "auth_login",
        request_id=request.state.request_id,
        user_id=str(user.id),
        device_id=body.device_id,
    )

    return ok(
        request,
        {
            "user": UserOut.model_validate(user),
            "access_token": access,
            "refresh_token": refresh,
        },
    )


@router.post("/refresh", response_model=AuthOut)
async def refresh(request: Request, body: RefreshIn, db: AsyncSession = Depends(get_db)):
    try:
        user, access, refresh_token = await refresh_tokens(db, body.refresh_token, body.device_id)
    except RefreshError as e:
        raise HTTPException(status_code=401, detail=err(request, e.code, "Invalid refresh token"))
    await db.commit()

    log.info(
        "auth_refresh",
        request_id=request.state.request_id,
        user_id=str(user.id),
        device_id=body.device_id,
    )

    return ok(
        request,
        {
            "user": UserOut.model_validate(user),
            "access_token": access,
            "refresh_token": refresh_token,
        },
    )


@router.post("/forgot", dependencies=[forgot_rate_limit])
async def forgot(request: Request, body: ForgotIn):
    return ok(request, {"status": "ok"})


@router.post("/reset")
async def reset(request: Request, body: ResetIn):
    return ok(request, {"status": "ok"})


@router.post("/logout")
async def logout(
    request: Request,
    body: LogoutIn,
    current_user=Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    await revoke_device_tokens(db, current_user, body.device_id)
    await db.commit()
    log.info(
        "auth_logout",
        request_id=request.state.request_id,
        user_id=str(current_user.id),
        device_id=body.device_id,
    )
    return ok(request, {"status": "ok"})


========================================
FILE: ./Backend/app/api/v1/__init__.py
========================================

Здесь пока пусто

========================================
FILE: ./Backend/app/api/v1/tasks.py
========================================

from __future__ import annotations

import uuid
from datetime import datetime

from fastapi import APIRouter, Depends, Header, HTTPException, Query, Request
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.api.deps import get_current_user
from app.api.idempotency import enforce_idempotency
from app.core.logging import log
from app.core.response import err, ok
from app.db.session import get_db
from app.models.task import Task
from app.schemas.tasks import ALLOWED_STATUSES, TaskCreateIn, TaskDeleteIn, TaskListOut, TaskOut, TaskUpdateIn
from app.services.events import publish_event
from app.services.tasks_service import create_task, list_tasks, soft_delete_task, update_task

router = APIRouter(prefix="/tasks")


@router.get("", response_model=TaskListOut)
async def get_tasks(
    request: Request,
    current_user=Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
    status: str | None = Query(default=None),
    goal_id: uuid.UUID | None = Query(default=None),
    due_from: datetime | None = Query(default=None),
    due_to: datetime | None = Query(default=None),
    cursor: str | None = Query(default=None),
    limit: int = Query(default=50, ge=1, le=100),
):
    if status and status not in ALLOWED_STATUSES:
        raise HTTPException(status_code=400, detail=err(request, "validation_error", "Unsupported status filter"))

    items, next_cursor = await list_tasks(
        db,
        user_id=current_user.id,
        status=status,
        goal_id=goal_id,
        due_from=due_from,
        due_to=due_to,
        cursor=cursor,
        limit=limit,
    )

    payload = {
        "items": [TaskOut.model_validate(t) for t in items],
        "next_cursor": next_cursor,
    }

    log.info(
        "tasks_list",
        request_id=request.state.request_id,
        user_id=str(current_user.id),
        count=len(items),
        next_cursor=next_cursor,
    )

    return ok(request, payload)


@router.post("", response_model=TaskOut)
async def post_task(
    request: Request,
    body: TaskCreateIn,
    current_user=Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
    x_idempotency_key: str | None = Header(default=None, alias="X-Idempotency-Key"),
):
    await enforce_idempotency(request, current_user, db, request_id=body.request_id, idempotency_key=x_idempotency_key)

    task = await create_task(db, current_user.id, body.model_dump())
    await db.commit()
    await db.refresh(task)

    publish_event(
        name="Task_Created",
        request_id=request.state.request_id,
        user_id=str(current_user.id),
        payload={"task_id": str(task.id)},
    )

    log.info(
        "task_created",
        request_id=request.state.request_id,
        user_id=str(current_user.id),
        task_id=str(task.id),
    )

    return ok(request, TaskOut.model_validate(task).model_dump())


@router.patch("/{task_id}", response_model=TaskOut)
async def patch_task(
    request: Request,
    task_id: uuid.UUID,
    body: TaskUpdateIn,
    current_user=Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
    x_idempotency_key: str | None = Header(default=None, alias="X-Idempotency-Key"),
):
    await enforce_idempotency(request, current_user, db, request_id=body.request_id, idempotency_key=x_idempotency_key)

    res = await db.execute(select(Task).where(Task.id == task_id, Task.user_id == current_user.id, Task.deleted == False))  # noqa: E712
    task = res.scalar_one_or_none()
    if not task:
        raise HTTPException(status_code=404, detail=err(request, "not_found", "Task not found"))

    try:
        updated = await update_task(db, task, body.model_dump(exclude_unset=True), expected_updated_at=body.updated_at)
    except ValueError as exc:
        if str(exc) == "conflict":
            raise HTTPException(
                status_code=409,
                detail=err(
                    request,
                    "conflict",
                    "Task version conflict",
                    details={"current": TaskOut.model_validate(task).model_dump()},
                ),
            )
        raise HTTPException(status_code=400, detail=err(request, "validation_error", "Invalid task data"))

    await db.commit()
    await db.refresh(updated)
    log.info(
        "task_updated",
        request_id=request.state.request_id,
        user_id=str(current_user.id),
        task_id=str(updated.id),
    )
    return ok(request, TaskOut.model_validate(updated).model_dump())


@router.delete("/{task_id}")
async def delete_task(
    request: Request,
    task_id: uuid.UUID,
    body: TaskDeleteIn,
    current_user=Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
    x_idempotency_key: str | None = Header(default=None, alias="X-Idempotency-Key"),
):
    await enforce_idempotency(request, current_user, db, request_id=body.request_id, idempotency_key=x_idempotency_key)

    res = await db.execute(select(Task).where(Task.id == task_id, Task.user_id == current_user.id, Task.deleted == False))  # noqa: E712
    task = res.scalar_one_or_none()
    if not task:
        raise HTTPException(status_code=404, detail=err(request, "not_found", "Task not found"))

    await soft_delete_task(db, task)
    await db.commit()
    log.info(
        "task_deleted",
        request_id=request.state.request_id,
        user_id=str(current_user.id),
        task_id=str(task.id),
    )
    return ok(request, {"status": "ok"})


========================================
FILE: ./Backend/app/core/config.py
========================================

from __future__ import annotations

from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", extra="ignore")

    # env: dev|stage|prod
    APP_ENV: str = "dev"
    API_V1_PREFIX: str = "/v1"

    # DB
    DATABASE_URL: str = "postgresql+asyncpg://lifemerge:lifemerge@db:5432/lifemerge"

    # JWT
    JWT_SECRET_KEY: str = "CHANGE_ME_IN_STAGE_AND_PROD"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_TTL_SECONDS: int = 900  # 15m
    REFRESH_TOKEN_TTL_SECONDS: int = 60 * 60 * 24 * 30  # 30d

    # Security
    PASSWORD_BCRYPT_ROUNDS: int = 12

    # HTTP
    CORS_ALLOW_ORIGINS: list[str] = ["*"]
    DEFAULT_TIMEZONE: str = "UTC"


settings = Settings()


========================================
FILE: ./Backend/app/core/__init__.py
========================================



========================================
FILE: ./Backend/app/core/logging.py
========================================

from __future__ import annotations

import logging

import structlog


def configure_logging() -> None:
    logging.basicConfig(level=logging.INFO, format="%(message)s")
    structlog.configure(
        processors=[
            structlog.contextvars.merge_contextvars,
            structlog.processors.add_log_level,
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.processors.JSONRenderer(),
        ],
        wrapper_class=structlog.make_filtering_bound_logger(logging.INFO),
        cache_logger_on_first_use=True,
    )


log = structlog.get_logger()


========================================
FILE: ./Backend/app/core/response.py
========================================

from __future__ import annotations

from typing import Any

from fastapi import Request


def ok(request: Request, payload: dict[str, Any]) -> dict[str, Any]:
    return {**payload, "request_id": request.state.request_id}


def err(request: Request, code: str, message: str, details: Any | None = None) -> dict[str, Any]:
    body: dict[str, Any] = {
        "error": {"code": code, "message": message},
        "request_id": request.state.request_id,
    }
    if details is not None:
        body["error"]["details"] = details
    return body


========================================
FILE: ./Backend/app/core/security.py
========================================

from __future__ import annotations

import hashlib
from datetime import datetime, timedelta, timezone
from typing import Any

import hashlib
from jose import jwt
from passlib.context import CryptContext

from app.core.config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def hash_password(password: str) -> str:
    return pwd_context.hash(password)


def verify_password(password: str, password_hash: str) -> bool:
    return pwd_context.verify(password, password_hash)


def create_access_token(subject: str, user_id: str) -> str:
    now = datetime.now(timezone.utc)
    exp = now + timedelta(seconds=settings.ACCESS_TOKEN_TTL_SECONDS)
    payload: dict[str, Any] = {
        "sub": subject,
        "uid": user_id,
        "iat": int(now.timestamp()),
        "exp": exp,
        "type": "access",
    }
    return jwt.encode(payload, settings.JWT_SECRET_KEY, algorithm=settings.JWT_ALGORITHM)


def create_refresh_token(subject: str, user_id: str, device_id: str) -> str:
    now = datetime.now(timezone.utc)
    exp = now + timedelta(seconds=settings.REFRESH_TOKEN_TTL_SECONDS)
    payload: dict[str, Any] = {
        "sub": subject,
        "uid": user_id,
        "device_id": device_id,
        "iat": int(now.timestamp()),
        "exp": exp,
        "type": "refresh",
    }
    return jwt.encode(payload, settings.JWT_SECRET_KEY, algorithm=settings.JWT_ALGORITHM)


def decode_token(token: str) -> dict[str, Any]:
    return jwt.decode(token, settings.JWT_SECRET_KEY, algorithms=[settings.JWT_ALGORITHM])


def token_hash(token: str) -> str:
    # store only hash of refresh token in DB
    return hashlib.sha256(token.encode("utf-8")).hexdigest()


========================================
FILE: ./Backend/app/db/base.py
========================================

from __future__ import annotations

from sqlalchemy.orm import DeclarativeBase


class Base(DeclarativeBase):
    pass


========================================
FILE: ./Backend/app/db/init_db.py
========================================

from __future__ import annotations

from sqlalchemy.ext.asyncio import AsyncEngine

from app.db.base import Base
from app.models.user import User  # noqa: F401
from app.models.task import Task  # noqa: F401
from app.models.refresh_token import RefreshToken  # noqa: F401
from app.models.idempotency import IdempotencyKey  # noqa: F401


async def init_db(engine: AsyncEngine) -> None:
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


========================================
FILE: ./Backend/app/db/__init__.py
========================================

Здесь пока пусто

========================================
FILE: ./Backend/app/db/session.py
========================================

from __future__ import annotations

from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

from app.core.config import settings

engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True)

AsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)


async def get_db() -> AsyncSession:
    async with AsyncSessionLocal() as session:
        yield session


========================================
FILE: ./Backend/app/__init__.py
========================================

Здесь пока пусто

========================================
FILE: ./Backend/app/main.py
========================================

from __future__ import annotations

import uuid

from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse

from app.api.router import api_router
from app.core.config import settings
from app.core.logging import configure_logging, log
from app.db.init_db import init_db
from app.db.session import engine
from app.middleware.request_context import RequestContextMiddleware

configure_logging()

app = FastAPI(
    title="LifeMerge Backend (Skeleton)",
    version="0.1.0",
    openapi_url=f"{settings.API_V1_PREFIX}/openapi.json",
    docs_url=f"{settings.API_V1_PREFIX}/docs",
    redoc_url=f"{settings.API_V1_PREFIX}/redoc",
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ALLOW_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Adds request_id + timezone context, returns request_id in all responses
app.add_middleware(RequestContextMiddleware)

app.include_router(api_router, prefix=settings.API_V1_PREFIX)


@app.on_event("startup")
async def on_startup() -> None:
    # Skeleton convenience: create tables automatically.
    # In production, use Alembic migrations.
    await init_db(engine)


@app.get("/health")
async def health():
    return {"status": "ok"}


@app.exception_handler(Exception)
async def unhandled_exception_handler(request: Request, exc: Exception):
    # Ensure we always return a request_id for tracing, even on unexpected errors
    request_id = getattr(request.state, "request_id", None) or str(uuid.uuid4())
    log.exception("unhandled_exception", request_id=request_id, path=str(request.url))
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": "internal_error",
                "message": "Internal server error",
            },
            "request_id": request_id,
        },
        headers={"X-Request-Id": request_id},
    )


@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    # Ensure API error format matches `{error:..., request_id}` across services.
    request_id = getattr(request.state, "request_id", None) or str(uuid.uuid4())
    payload = exc.detail if isinstance(exc.detail, dict) else {
        "error": {"code": "http_error", "message": str(exc.detail)},
        "request_id": request_id,
    }
    # hard-enforce request_id
    payload.setdefault("request_id", request_id)
    return JSONResponse(status_code=exc.status_code, content=payload, headers={"X-Request-Id": request_id})


========================================
FILE: ./Backend/app/middleware/__init__.py
========================================

Здесь пока пусто

========================================
FILE: ./Backend/app/middleware/rate_limit.py
========================================

from __future__ import annotations

import time
from dataclasses import dataclass
from typing import Callable

from fastapi import Depends, HTTPException, Request

from app.core.response import err

# MVP in-memory limiter (per-process). For prod / multi-replica -> Redis.
@dataclass
class _Bucket:
    reset_at: float
    count: int


_STORE: dict[str, _Bucket] = {}


def _client_ip(request: Request) -> str:
    # if behind proxy, you may want X-Forwarded-For parsing in ingress
    return request.client.host if request.client else "unknown"


def rate_limit(*, key_prefix: str, limit: int, window_seconds: int) -> Callable:
    async def _dep(request: Request):
        now = time.time()
        ip = _client_ip(request)
        key = f"{key_prefix}:{ip}"

        b = _STORE.get(key)
        if b is None or now >= b.reset_at:
            _STORE[key] = _Bucket(reset_at=now + window_seconds, count=1)
            return

        b.count += 1
        if b.count > limit:
            raise HTTPException(
                status_code=429,
                detail=err(
                    request,
                    "rate_limited",
                    "Too many requests",
                    details={"retry_after_seconds": max(0, int(b.reset_at - now))},
                ),
            )

    return Depends(_dep)


# project defaults
signup_rate_limit = rate_limit(key_prefix="auth:signup", limit=10, window_seconds=60)
forgot_rate_limit = rate_limit(key_prefix="auth:forgot", limit=10, window_seconds=60)


========================================
FILE: ./Backend/app/middleware/request_context.py
========================================

from __future__ import annotations

import uuid
from zoneinfo import ZoneInfo

from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import Response

from app.core.config import settings


class RequestContextMiddleware(BaseHTTPMiddleware):
    """Injects:
    - request.state.request_id
    - request.state.client_timezone (IANA)

    Rules:
    - If `X-Request-Id` header is present, use it.
    - Else generate UUID.
    - Timezone from `X-Timezone` header (IANA). If invalid/absent, fallback to DEFAULT_TIMEZONE.

    Adds `X-Request-Id` and `X-Timezone` to every response.
    """

    async def dispatch(self, request: Request, call_next):
        req_id = request.headers.get("X-Request-Id") or str(uuid.uuid4())
        tz = request.headers.get("X-Timezone") or settings.DEFAULT_TIMEZONE
        try:
            # Validate timezone
            ZoneInfo(tz)
        except Exception:
            tz = settings.DEFAULT_TIMEZONE

        request.state.request_id = req_id
        request.state.client_timezone = tz

        response: Response = await call_next(request)
        response.headers["X-Request-Id"] = req_id
        response.headers["X-Timezone"] = tz
        return response


========================================
FILE: ./Backend/app/models/idempotency.py
========================================

from __future__ import annotations

import uuid
from datetime import datetime, timezone

from sqlalchemy import DateTime, ForeignKey, String, UniqueConstraint
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column

from app.db.base import Base


class IdempotencyKey(Base):
    __tablename__ = "idempotency_keys"
    __table_args__ = (
        UniqueConstraint("user_id", "key", "method", "path", name="uq_idem_user_key"),
    )

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    key: Mapped[str] = mapped_column(String(128), nullable=False)
    method: Mapped[str] = mapped_column(String(8), nullable=False)
    path: Mapped[str] = mapped_column(String(200), nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, default=lambda: datetime.now(timezone.utc))


========================================
FILE: ./Backend/app/models/__init__.py
========================================

Здесь пока пусто

========================================
FILE: ./Backend/app/models/refresh_token.py
========================================

from __future__ import annotations

import uuid
from datetime import datetime, timezone

from sqlalchemy import Boolean, DateTime, ForeignKey, String
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column

from app.db.base import Base


class RefreshToken(Base):
    __tablename__ = "refresh_tokens"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    device_id: Mapped[str] = mapped_column(String(128), nullable=False, index=True)
    token_hash: Mapped[str] = mapped_column(String(64), nullable=False)
    revoked: Mapped[bool] = mapped_column(Boolean, nullable=False, default=False)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, default=lambda: datetime.now(timezone.utc))
    expires_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)


========================================
FILE: ./Backend/app/models/task.py
========================================

from __future__ import annotations

import uuid
from datetime import datetime, timezone

from sqlalchemy import Boolean, DateTime, ForeignKey, Integer, String, Text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column

from app.db.base import Base


class Task(Base):
    __tablename__ = "tasks"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)

    title: Mapped[str] = mapped_column(String(300), nullable=False)
    description: Mapped[str | None] = mapped_column(Text, nullable=True)
    status: Mapped[str] = mapped_column(String(32), nullable=False, default="todo")
    priority: Mapped[int | None] = mapped_column(Integer, nullable=True)
    estimated_minutes: Mapped[int | None] = mapped_column(Integer, nullable=True)
    energy_level: Mapped[int | None] = mapped_column(Integer, nullable=True)

    goal_id: Mapped[uuid.UUID | None] = mapped_column(UUID(as_uuid=True), nullable=True, index=True)
    due_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), nullable=True)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, default=lambda: datetime.now(timezone.utc))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, default=lambda: datetime.now(timezone.utc))
    deleted: Mapped[bool] = mapped_column(Boolean, nullable=False, default=False)


========================================
FILE: ./Backend/app/models/user.py
========================================

from __future__ import annotations

import uuid
from datetime import datetime, timezone

from sqlalchemy import Boolean, DateTime, String
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column

from app.db.base import Base


class User(Base):
    __tablename__ = "users"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email: Mapped[str] = mapped_column(String(320), unique=True, index=True, nullable=False)
    password_hash: Mapped[str] = mapped_column(String(255), nullable=False)
    full_name: Mapped[str | None] = mapped_column(String(200), nullable=True)
    timezone: Mapped[str] = mapped_column(String(64), nullable=False, default="UTC")

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, default=lambda: datetime.now(timezone.utc))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, default=lambda: datetime.now(timezone.utc))
    deleted: Mapped[bool] = mapped_column(Boolean, nullable=False, default=False)


========================================
FILE: ./Backend/app/repositories/idempotency_repo.py
========================================

from __future__ import annotations

from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.idempotency import IdempotencyKey


async def insert_key(
    db: AsyncSession,
    *,
    user_id,
    key: str,
    method: str,
    path: str,
) -> bool:
    """
    Returns:
      True  -> first time seen (insert ok)
      False -> duplicate (unique constraint hit)
    """
    rec = IdempotencyKey(user_id=user_id, key=key, method=method, path=path)
    db.add(rec)
    try:
        await db.flush()
        return True
    except IntegrityError:
        return False


========================================
FILE: ./Backend/app/repositories/__init__.py
========================================

from __future__ import annotations


========================================
FILE: ./Backend/app/repositories/refresh_tokens_repo.py
========================================

from __future__ import annotations

import uuid
from datetime import datetime

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.refresh_token import RefreshToken


async def create(db: AsyncSession, token: RefreshToken) -> RefreshToken:
    db.add(token)
    await db.flush()
    return token


async def find_valid(
    db: AsyncSession,
    *,
    user_id: uuid.UUID,
    device_id: str,
    token_hash: str,
    now: datetime,
) -> RefreshToken | None:
    res = await db.execute(
        select(RefreshToken).where(
            RefreshToken.user_id == user_id,
            RefreshToken.device_id == device_id,
            RefreshToken.token_hash == token_hash,
            RefreshToken.revoked == False,  # noqa: E712
            RefreshToken.expires_at > now,
        )
    )
    return res.scalar_one_or_none()


async def revoke(db: AsyncSession, *, token_id: uuid.UUID) -> None:
    await db.execute(update(RefreshToken).where(RefreshToken.id == token_id).values(revoked=True))


async def revoke_device(db: AsyncSession, *, user_id: uuid.UUID, device_id: str) -> None:
    await db.execute(
        update(RefreshToken)
        .where(RefreshToken.user_id == user_id, RefreshToken.device_id == device_id)
        .values(revoked=True)
    )


========================================
FILE: ./Backend/app/repositories/tasks_repo.py
========================================

from __future__ import annotations

import uuid
from datetime import datetime

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.task import Task


async def get_by_id(db: AsyncSession, *, task_id: uuid.UUID, user_id: uuid.UUID) -> Task | None:
    res = await db.execute(select(Task).where(Task.id == task_id, Task.user_id == user_id, Task.deleted == False))  # noqa: E712
    return res.scalar_one_or_none()


async def list(
    db: AsyncSession,
    *,
    user_id: uuid.UUID,
    status: str | None,
    goal_id: uuid.UUID | None,
    due_from: datetime | None,
    due_to: datetime | None,
    cursor: str | None,
    limit: int,
) -> tuple[list[Task], str | None]:
    q = select(Task).where(Task.user_id == user_id, Task.deleted == False)  # noqa: E712
    if status:
        q = q.where(Task.status == status)
    if goal_id:
        q = q.where(Task.goal_id == goal_id)
    if due_from:
        q = q.where(Task.due_at >= due_from)
    if due_to:
        q = q.where(Task.due_at <= due_to)

    if cursor:
        try:
            ts_str, id_str = cursor.split("|")
            ts = datetime.fromisoformat(ts_str)
            cid = uuid.UUID(id_str)
            q = q.where((Task.updated_at, Task.id) < (ts, cid))
        except Exception:
            pass

    q = q.order_by(Task.updated_at.desc(), Task.id.desc()).limit(max(1, min(limit, 100)) + 1)
    res = await db.execute(q)
    rows = res.scalars().all()

    next_cursor = None
    if len(rows) > limit:
        last = rows[limit - 1]
        next_cursor = f"{last.updated_at.isoformat()}|{last.id}"
        rows = rows[:limit]

    return rows, next_cursor


async def create(db: AsyncSession, task: Task) -> Task:
    db.add(task)
    await db.flush()
    return task


async def patch(db: AsyncSession, *, task_id: uuid.UUID, values: dict) -> None:
    await db.execute(update(Task).where(Task.id == task_id).values(**values))


async def soft_delete(db: AsyncSession, *, task_id: uuid.UUID, values: dict) -> None:
    await db.execute(update(Task).where(Task.id == task_id).values(**values))


========================================
FILE: ./Backend/app/repositories/users_repo.py
========================================

from __future__ import annotations

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.user import User


async def get_by_email(db: AsyncSession, email: str) -> User | None:
    res = await db.execute(select(User).where(User.email == email.lower(), User.deleted == False))  # noqa: E712
    return res.scalar_one_or_none()


async def get_by_id(db: AsyncSession, user_id) -> User | None:
    res = await db.execute(select(User).where(User.id == user_id, User.deleted == False))  # noqa: E712
    return res.scalar_one_or_none()


async def create(db: AsyncSession, *, email: str, password_hash: str, full_name: str | None, timezone: str) -> User:
    user = User(email=email.lower(), password_hash=password_hash, full_name=full_name, timezone=timezone)
    db.add(user)
    await db.flush()
    return user


========================================
FILE: ./Backend/app/schemas/auth.py
========================================

from __future__ import annotations

from zoneinfo import ZoneInfo

from pydantic import BaseModel, EmailStr, Field, field_validator

from app.schemas.user import UserOut


class SignupIn(BaseModel):
    email: EmailStr
    password: str = Field(min_length=8, max_length=256)
    full_name: str | None = Field(default=None, max_length=200)
    timezone: str = Field(default="UTC", max_length=64)

    @field_validator("timezone")
    @classmethod
    def validate_timezone(cls, value: str) -> str:
        try:
            ZoneInfo(value)
        except Exception as exc:  # pragma: no cover - defensive validation
            raise ValueError("Invalid timezone") from exc
        return value


class LoginIn(BaseModel):
    email: EmailStr
    password: str
    device_id: str = Field(min_length=1, max_length=128)


class RefreshIn(BaseModel):
    refresh_token: str = Field(min_length=1)
    device_id: str = Field(min_length=1, max_length=128)


class ForgotIn(BaseModel):
    email: EmailStr


class ResetIn(BaseModel):
    token: str
    new_password: str = Field(min_length=8, max_length=256)


class LogoutIn(BaseModel):
    device_id: str = Field(min_length=1, max_length=128)


class AuthOut(BaseModel):
    user: UserOut
    access_token: str
    refresh_token: str
    request_id: str


========================================
FILE: ./Backend/app/schemas/common.py
========================================

from __future__ import annotations

from pydantic import BaseModel


class ErrorBody(BaseModel):
    code: str
    message: str
    details: dict | None = None


class ErrorResponse(BaseModel):
    error: ErrorBody
    request_id: str


========================================
FILE: ./Backend/app/schemas/__init__.py
========================================

Здесь пока пусто

========================================
FILE: ./Backend/app/schemas/tasks.py
========================================

from __future__ import annotations

import uuid
from datetime import datetime

from pydantic import BaseModel, Field, field_validator

ALLOWED_STATUSES = {"todo", "in_progress", "done", "deferred"}


class TaskOut(BaseModel):
    id: uuid.UUID
    title: str
    description: str | None = None
    status: str
    priority: int | None = None
    estimated_minutes: int | None = None
    energy_level: int | None = None
    goal_id: uuid.UUID | None = None
    due_at: datetime | None = None
    created_at: datetime | None = None
    updated_at: datetime | None = None
    deleted: bool = False

    class Config:
        from_attributes = True


class TaskCreateIn(BaseModel):
    title: str = Field(min_length=1, max_length=300)
    description: str | None = None
    goal_id: uuid.UUID | None = None
    due_at: datetime | None = None
    priority: int | None = None
    estimated_minutes: int | None = None
    energy_level: int | None = None
    request_id: str = Field(min_length=1, max_length=128)

    @field_validator("priority", "estimated_minutes", "energy_level")
    @classmethod
    def non_negative(cls, value: int | None) -> int | None:
        if value is not None and value < 0:
            raise ValueError("Value must be non-negative")
        return value


class TaskUpdateIn(BaseModel):
    title: str | None = Field(default=None, max_length=300)
    description: str | None = None
    goal_id: uuid.UUID | None = None
    due_at: datetime | None = None
    priority: int | None = None
    estimated_minutes: int | None = None
    energy_level: int | None = None
    status: str | None = None
    updated_at: datetime | None = None
    request_id: str = Field(min_length=1, max_length=128)

    @field_validator("priority", "estimated_minutes", "energy_level")
    @classmethod
    def non_negative(cls, value: int | None) -> int | None:
        if value is not None and value < 0:
            raise ValueError("Value must be non-negative")
        return value

    @field_validator("status")
    @classmethod
    def validate_status(cls, value: str | None) -> str | None:
        if value is not None and value not in ALLOWED_STATUSES:
            raise ValueError("Unsupported status")
        return value


class TaskDeleteIn(BaseModel):
    request_id: str = Field(min_length=1, max_length=128)


class TaskListOut(BaseModel):
    items: list[TaskOut]
    next_cursor: str | None = None
    request_id: str


========================================
FILE: ./Backend/app/schemas/user.py
========================================

from __future__ import annotations

import uuid
from datetime import datetime

from pydantic import BaseModel, EmailStr


class UserOut(BaseModel):
    id: uuid.UUID
    email: EmailStr
    full_name: str | None = None
    timezone: str
    created_at: datetime | None = None
    updated_at: datetime | None = None
    deleted: bool = False

    class Config:
        from_attributes = True


========================================
FILE: ./Backend/app/services/auth_service.py
========================================

from __future__ import annotations

import uuid
from datetime import datetime, timedelta, timezone

from sqlalchemy.ext.asyncio import AsyncSession

from app.core.config import settings
from app.core.security import (
    create_access_token,
    create_refresh_token,
    decode_token,
    hash_password,
    token_hash,
    verify_password,
)
from app.models.refresh_token import RefreshToken
from app.models.user import User
from app.repositories import refresh_tokens_repo, users_repo


async def create_user(
    db: AsyncSession, email: str, password: str, full_name: str | None, timezone_name: str
) -> User:
    user = await users_repo.create(
        db,
        email=email,
        password_hash=hash_password(password),
        full_name=full_name,
        timezone=timezone_name,
    )
    return user


async def get_user_by_email(db: AsyncSession, email: str) -> User | None:
    return await users_repo.get_by_email(db, email)


async def issue_tokens(db: AsyncSession, user: User, device_id: str) -> tuple[str, str]:
    access = create_access_token(subject=user.email, user_id=str(user.id))
    refresh = create_refresh_token(subject=user.email, user_id=str(user.id), device_id=device_id)

    expires_at = datetime.now(timezone.utc) + timedelta(seconds=settings.REFRESH_TOKEN_TTL_SECONDS)
    rt = RefreshToken(user_id=user.id, device_id=device_id, token_hash=token_hash(refresh), expires_at=expires_at)
    await refresh_tokens_repo.create(db, rt)

    return access, refresh


async def authenticate_user(db: AsyncSession, email: str, password: str) -> User | None:
    user = await get_user_by_email(db, email)
    if not user:
        return None
    if not verify_password(password, user.password_hash):
        return None
    return user


class RefreshError(Exception):
    code: str

    def __init__(self, code: str):
        self.code = code


async def refresh_tokens(db: AsyncSession, refresh_token: str, device_id: str) -> tuple[User, str, str]:
    try:
        payload = decode_token(refresh_token)
    except Exception:
        raise RefreshError("invalid_refresh")

    if payload.get("type") != "refresh":
        raise RefreshError("invalid_refresh")

    token_device = payload.get("device_id")
    if token_device != device_id:
        # required by Backend Lead: invalid device -> 401 refresh_invalid_device
        raise RefreshError("refresh_invalid_device")

    raw_uid = payload.get("uid")
    if not raw_uid:
        raise RefreshError("invalid_refresh")

    try:
        uid = uuid.UUID(str(raw_uid))
    except Exception:
        raise RefreshError("invalid_refresh")

    now = datetime.now(timezone.utc)
    h = token_hash(refresh_token)
    stored = await refresh_tokens_repo.find_valid(db, user_id=uid, device_id=device_id, token_hash=h, now=now)
    if not stored:
        raise RefreshError("invalid_refresh")

    user = await users_repo.get_by_id(db, uid)
    if not user:
        raise RefreshError("invalid_refresh")

    # rotation: revoke old token and issue new
    await refresh_tokens_repo.revoke(db, token_id=stored.id)
    access, new_refresh = await issue_tokens(db, user, device_id)
    return user, access, new_refresh


async def revoke_device_tokens(db: AsyncSession, user: User, device_id: str) -> None:
    await refresh_tokens_repo.revoke_device(db, user_id=user.id, device_id=device_id)


========================================
FILE: ./Backend/app/services/events.py
========================================

from __future__ import annotations

from typing import Any

from app.core.logging import log


def publish_event(*, name: str, request_id: str, user_id: str | None = None, payload: dict[str, Any] | None = None) -> None:
    # MVP: structured log. Later: outbox/queue -> worker -> Firebase/Amplitude
    log.info(
        "analytics_event",
        event_name=name,
        request_id=request_id,
        user_id=user_id,
        payload=payload or {},
    )


========================================
FILE: ./Backend/app/services/__init__.py
========================================

Здесь пока пусто

========================================
FILE: ./Backend/app/services/tasks_service.py
========================================

from __future__ import annotations

import uuid
from datetime import datetime, timezone

from sqlalchemy.ext.asyncio import AsyncSession

from app.models.task import Task
from app.repositories import tasks_repo
from app.schemas.tasks import ALLOWED_STATUSES


async def list_tasks(
    db: AsyncSession,
    user_id: uuid.UUID,
    status: str | None = None,
    goal_id: uuid.UUID | None = None,
    due_from: datetime | None = None,
    due_to: datetime | None = None,
    cursor: str | None = None,
    limit: int = 50,
) -> tuple[list[Task], str | None]:
    return await tasks_repo.list(
        db,
        user_id=user_id,
        status=status,
        goal_id=goal_id,
        due_from=due_from,
        due_to=due_to,
        cursor=cursor,
        limit=limit,
    )


async def create_task(db: AsyncSession, user_id: uuid.UUID, data: dict) -> Task:
    now = datetime.now(timezone.utc)
    task = Task(
        user_id=user_id,
        title=data["title"],
        description=data.get("description"),
        goal_id=data.get("goal_id"),
        due_at=data.get("due_at"),
        priority=data.get("priority"),
        estimated_minutes=data.get("estimated_minutes"),
        energy_level=data.get("energy_level"),
        status="todo",
        created_at=now,
        updated_at=now,
        deleted=False,
    )
    return await tasks_repo.create(db, task)


async def update_task(db: AsyncSession, task: Task, patch: dict, expected_updated_at: datetime | None) -> Task:
    if expected_updated_at:
        # normalize tz
        a = task.updated_at.replace(tzinfo=timezone.utc)
        b = expected_updated_at.replace(tzinfo=timezone.utc)
        if a != b:
            raise ValueError("conflict")

    values = {k: v for k, v in patch.items() if v is not None and k not in {"request_id", "updated_at"}}
    status = values.get("status")
    if status and status not in ALLOWED_STATUSES:
        raise ValueError("invalid_status")
    values["updated_at"] = datetime.now(timezone.utc)

    await tasks_repo.patch(db, task_id=task.id, values=values)
    await db.refresh(task)
    return task


async def soft_delete_task(db: AsyncSession, task: Task) -> Task:
    values = {"deleted": True, "updated_at": datetime.now(timezone.utc)}
    await tasks_repo.soft_delete(db, task_id=task.id, values=values)
    await db.refresh(task)
    return task


========================================
FILE: ./Backend/docker-compose.yml
========================================

services:
  db:
    image: postgres:16
    environment:
      POSTGRES_DB: lifemerge
      POSTGRES_USER: lifemerge
      POSTGRES_PASSWORD: lifemerge
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U lifemerge -d lifemerge"]
      interval: 5s
      timeout: 5s
      retries: 20

  api:
    build: .
    environment:
      APP_ENV: stage
      DATABASE_URL: postgresql+asyncpg://lifemerge:lifemerge@db:5432/lifemerge
      JWT_SECRET_KEY: ${JWT_SECRET_KEY:-CHANGE_ME_IN_STAGE_AND_PROD}
      CORS_ALLOW_ORIGINS: '["*"]'
      DEFAULT_TIMEZONE: "UTC"
    ports:
      - "8000:8000"
    depends_on:
      db:
        condition: service_healthy

volumes:
  pgdata:


========================================
FILE: ./Backend/Dockerfile
========================================

FROM python:3.12-slim

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

WORKDIR /app

RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt /app/requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

COPY app /app/app

EXPOSE 8000

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]


========================================
FILE: ./Backend/.gitignore
========================================

lifemerge-backend.txt
combine_md.sh

========================================
FILE: ./Backend/LifeMerge_docs/00_Administration/Decisions_Log.md
========================================

# Template for new decisions

## DEC-XXX — Название решения
**Дата:**  
**Категория:**  
**Статус:** Proposed / Accepted / Rejected / Deprecated  
**Ответственный:**  

### Контекст

### Решение

### Причины

### Влияние


### Альтернативы

### Риски


### Миграции / технические действия

### Ссылки



========================================
FILE: ./Backend/LifeMerge_docs/00_Administration/Glossary.md
========================================

# Glossary – LifeMerge

Документ содержит список терминов, используемых в проекте LifeMerge, их определения и контекст применения.

Структура:
1. Основные термины продукта
2. Планирование и задачи
3. Финансы
4. AI и машинное обучение
5. Архитектура и backend
6. Мобильная разработка (Flutter)
7. Метрики и аналитика
8. Подписки и монетизация
9. Процессы разработки
10. Специфические термины LifeMerge

---

## 1. Основные термины продукта

**LifeMerge**  
Приложение «операционная система жизни», объединяющее цели, задачи, календарь, финансы и AI.

**Сфера жизни (Life Sphere)**  
Категории: работа, здоровье, личное, финансы, учёба и т.д.

**Event (Событие)**  
Любая запись в календаре: встреча, смена, сон, поезка, спорт, финансовое событие.

**Task (Задача)**  
Единица работы, которую пользователь должен выполнить. Может быть привязана к цели или календарю.

**Goal (Цель)**  
Стратегическая задача, состоящая из подзадач.

**Inbox (GTD)**  
Входящие идеи, мысли, задачи без структуры.

---

## 2. Планирование и задачи

**Time Blocking (Блоки времени)**  
Метод планирования, при котором задачи размещаются на временной шкале.

**Working Schedule (Рабочий график)**  
Шаблон рабочей нагрузки (5/2, 2/2, 3/3, ночные смены и т.д.).

**Recurring Task (Регулярная задача)**  
Автоматически повторяющаяся задача по правилу.

**Splittable Task (Дробимая задача)**  
Задача, разбиваемая на несколько временных слотов.

**Context (Контекст)**  
Условие выполнения задачи (например, «@компьютер», «@дом», «@дорога»).

**Energy Level (Энергозатратность)**  
Оценка сложности задачи — лёгкая, средняя, тяжёлая.

---

## 3. Финансы

**Finance Record (Финансовая запись)**  
Доход или расход.

**Recurring Finance Record (Регулярный платёж)**  
Платёж, повторяющийся по расписанию.

**Budget Forecast (Прогноз бюджета)**  
Прогноз финансовой активности на будущее.

**Linked Finance Event (Финансовое событие календаря)**  
Финансовая запись, привязанная к событию календаря.

**Account (Счёт)**  
Источник средств: карточка, наличные, депозит.

---

## 4. AI и машинное обучение

**AI Planner**  
Модуль, предлагающий оптимальные слоты для задач.

**Rule Compliance (Соблюдение правил)**  
AI должен соблюдать правила пользователя (например, «не ставить задачи вечером»).

**AI Suggestion (AI-рекомендация)**  
Предложение AI (изменить слоты, перенести задачу, убрать перегрузку).

**Fallback**  
Поведение системы, когда AI не может дать валидный результат.

**AI Model Versioning**  
Система управления версиями моделей AI.

---

## 5. Архитектура и backend

**API (Application Programming Interface)**  
Взаимодействие между клиентом и сервером.

**Endpoint**  
Конкретный адрес API (например, POST /tasks).

**Entity**  
Основная сущность в системе (user, task, event, finance_record).

**Migration (Миграция)**  
Изменение структуры базы данных.

**Queue (Очередь синхронизации)**  
Механизм отправки событий офлайн-режима после восстановления сети.

---

## 6. Мобильная разработка

**Flutter**  
Фреймворк кроссплатформенной разработки.

**State Management**  
Архитектурный подход для управления состоянием (в LifeMerge — Riverpod).

**Offline Cache (Оффлайн-кэш)**  
Хранение данных локально на устройстве.

**Sync Entry**  
Единица данных, ожидающая синхронизации.

---

## 7. Метрики и аналитика

**NSM (North Star Metric)**  
Ключевая метрика успеха продукта — Weekly Productive Engagement.

**DAU/WAU/MAU**  
Daily / Weekly / Monthly Active Users.

**Activation Rate**  
Процент пользователей, достигших первой ценности продукта.

**Retention D1/D7/D30**  
Удержание пользователей в динамике.

**AI Adoption Rate**  
Доля пользователей, использующих AI.

**Plan Acceptance Rate**  
Процент принятых планов AI.

---

## 8. Подписки и монетизация

**Free Tier**  
Бесплатный тариф с базовыми возможностями.

**Pro Tier**  
Платный тариф с AI, расширенной аналитикой, автоматизацией.

**Trial Period**  
Пробный период использования Pro.

**LTV (Lifetime Value)**  
Ценность пользователя за всё время.

**Churn**  
Отток пользователей.

---

## 9. Процессы разработки

**DoR (Definition of Ready)**  
Критерии готовности задачи к разработке.

**DoD (Definition of Done)**  
Критерии завершённости задачи.

**Release Candidate (RC)**  
Потенциальная сборка для продакшена.

**Hotfix**  
Срочное исправление критического бага на проде.

**CCB (Change Control Board)**  
Группа, утверждающая крупные изменения.

---

## 10. Специфические термины LifeMerge

**Life Intelligence Layer**  
Аналитический уровень Pro 2.0, анализирующий влияние времени, целей и финансов друг на друга.

**Autonomy Mode**  
Режим полуавтономного AI — управляется только по согласию пользователя.

**Planning Consistency Index**  
Метрика устойчивости планирования: насколько фактические действия совпадают с планом.

**Sphere Cross-Impact Analytics**  
Отчёт взаимного влияния сфер жизни.

---

## История изменений
| Дата | Автор | Изменения |
|------|--------|------------|
| 2025-01-XX | … | Первая версия |
| 2025-01-XX | … | Добавлены термины AI и Analytics |



========================================
FILE: ./Backend/LifeMerge_docs/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning /Mobile Sprint 01 — Technical Breakdown (Jira-ready).md
========================================

# 📱 Mobile — Sprint 01 (Foundation + A1)

## EPIC M0 — Core App Skeleton & Infrastructure

### M0.1 Finalize App Skeleton

**Type:** Story
**Priority:** P0

**Scope:**

* Зафиксировать структуру слоёв: `presentation / application / domain / data / core`.
* Финализировать DI-контейнер (scope per feature).
* App bootstrap (env, flavors, error handling root).
* AppRouter + Shell (Auth / Calendar / Tasks / Inbox / Settings / Pro).

**DoD:**

* Проект собирается.
* Можно подключать фичи без правок core.
* Нет feature-to-feature зависимостей.

---

### M0.2 Core Storage (Secure + KV)

**Type:** Story
**Priority:** P0

**Scope:**

* `SecureStorage` (tokens, sensitive data).
* `KeyValueStorage` (flags, onboarding state, prefs).
* Чистые интерфейсы + реализации.

**Tech notes:**

* Без прямых зависимостей в features.
* Async-safe, ready для offline-first.

**DoD:**

* Используется в Auth и Onboarding.
* Покрыт базовыми unit-тестами.

---

## EPIC M1 — Theme & Design System

### M1.1 AppTheme & Tokens

**Type:** Story
**Priority:** P0

**Scope:**

* Light/Dark theme.
* Color tokens (semantic).
* Typography (H1–Caption).
* Spacing, radii.

**Tech notes:**

* Naming = UI Kit v1.0.
* Ни одного “raw color” в UI.

**DoD:**

* Theme используется по всему приложению.
* Токены — единственный источник правды.

---

### M1.2 Base UI Components

**Type:** Story
**Priority:** P0

**Scope:**

* Button (Primary / Secondary / Tertiary + loading/disabled).
* TextField (all states).
* AppBar.
* BottomNavigation.
* ModalSheet / Dialog.
* Loader / Skeleton.

**DoD:**

* Компоненты используются в Auth/Tasks/Calendar.
* Нет дублирующихся UI-реализаций.

---

## EPIC M2 — Navigation

### M2.1 App Navigation Shell

**Type:** Story
**Priority:** P0

**Scope:**

* Auth flow routes.
* Main shell (tabs).
* Guarded routes по AuthState.
* Placeholder routes для Sprint 02.

**DoD:**

* Навигация соответствует wireframes.
* После онбординга → Calendar Day.

---

## EPIC M3 — Auth & Onboarding (A1 critical)

### M3.1 Auth Domain

**Type:** Story
**Priority:** P0

**Scope:**

* Entities: User, AuthState.
* UseCases: signIn, signUp, refresh, logout, restoreSession.
* Repository interfaces.

**DoD:**

* Domain не зависит от Flutter/UI.
* Готово к mock/real data source.

---

### M3.2 Auth UI & State

**Type:** Story
**Priority:** P0

**Scope:**

* Login / Register / Recovery.
* Form validation.
* Error states.
* Loading states.

**Tech notes:**

* Riverpod.
* Single source of truth для AuthState.

**DoD:**

* Happy path A1 проходит ≤5 минут.
* Ошибки API корректно отображаются.

---

### M3.3 Onboarding Flow

**Type:** Story
**Priority:** P0

**Scope:**

* Onboarding screens.
* Persist onboarding completion.
* Transition → Main Shell.

**Analytics:**

* `Onboarding_Complete`.

**DoD:**

* Логируется один раз.
* Повторный запуск → onboarding не показывается.

---

## EPIC M4 — Tasks Core (CRUD)

### M4.1 Tasks Domain

**Type:** Story
**Priority:** P0

**Scope:**

* Task entity.
* Status lifecycle.
* CRUD use-cases.

**Constraints:**

* Без goals.
* Без recurrence.

---

### M4.2 Tasks UI

**Type:** Story
**Priority:** P0

**Scope:**

* Task List.
* Task Create/Edit.
* Complete task.

**Analytics:**

* `Task_Created`
* `Task_Completed`.

**DoD:**

* Работает offline (через queue).
* UI соответствует design states.

---

## EPIC M5 — Calendar Day (Basic)

### M5.1 Calendar Day View

**Type:** Story
**Priority:** P0

**Scope:**

* Day timeline.
* Event list.
* Empty/loading/offline states.

**Constraints:**

* No drag&drop.
* No recurrence.

---

### M5.2 Event Create (Basic)

**Type:** Story
**Priority:** P0

**Scope:**

* Create event.
* Simple start/end.
* Save to backend / queue.

**Analytics:**

* `Reached_Calendar`.

---

## EPIC M6 — Offline Queue v1

### M6.1 Offline Operations Queue

**Type:** Story
**Priority:** P0

**Scope:**

* Queue for Tasks + Events.
* request_id + updated_at.
* Retry & conflict-safe.

**Tech notes:**

* Единая реализация.
* Прозрачна для features.

**DoD:**

* Можно создавать задачи/ивенты offline.
* Синк без дублей.

---

## EPIC M7 — Analytics (A1)

### M7.1 Analytics Infrastructure

**Type:** Story
**Priority:** P0

**Scope:**

* AnalyticsService abstraction.
* Firebase + Amplitude.
* Debug logging.

---

### M7.2 A1 Events

**Type:** Story
**Priority:** P0

**Events:**

* User_SignUp
* Onboarding_Complete
* Task_Created
* Reached_Calendar

**DoD:**

* События не дублируются.
* Проверены на QA-стенде.

---

# ⏱️ Ownership

* **Даниил:** архитектура, M0, M1, M6, аналитика, ревью.
* **Дмитрий:** реализация M2–M5 под контролем.


========================================
FILE: ./Backend/LifeMerge_docs/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning / Sprint 01–02.md
========================================

**MEETING NOTE — Strategic MVP Planning / Sprint 01–02**

**Проект:** LifeMerge
**Дата:** 12.12.2025
**Тип встречи:** Стратегическое планирование MVP (CEO-level)
**Модератор:** Олег (CEO / Founder)

**Участники:**

* Олег — CEO / Founder
* Антон — Product Manager
* Виктор — Product Analyst
* Борис — Lead UI/UX Designer
* Григорий — Interaction Designer
* Даниил — Tech Lead Mobile (Flutter)
* Дмитрий — Mobile Developer
* Егор — Backend Lead
* Евгений — Backend Developer
* Игорь — AI Lead
* Константин — AI Engineer
* Леонид — QA Lead
* Марк — QA Engineer

---

### 1. Цель встречи

1. Зафиксировать P1-ядро MVP согласно Vision / Roadmap / Charter.
2. Уточнить разделение функционала по Sprint 01 и Sprint 02.
3. Определить технические ограничения и риск-области (TZ, offline, AI Planner).
4. Раздать конкретные Action Items командам с ответственными.

---

### 2. Краткий итог обсуждения

* Подтвержден P1-scope MVP: Auth/Onboarding, Calendar Core (Day), Tasks Core, Goals (базово), Inbox, AI Planner v1 (Pro-only), Notifications, Offline Sync, Core Architecture.
* Уточнено разделение спринтов:

  * Sprint 01 — фундамент + A1 (Auth/Onboarding, Tasks CRUD без целей, Calendar Day без drag&drop, Inbox MVP, Notifications infra, аналитика для A1).
  * Sprint 02 — A2 + связки + AI Planner v1 skeleton (Goals, Task→Calendar, Calendar drag&drop, AI Planner v1, Goal Progress, Calendar Conflicts basic, Digest push).
* Зафиксированы ограничения MVP: 1 задача = 1 слот в календаре; простой рабочий график; AI Planner v1 без продвинутой персонализации.
* Подтверждена готовность Design (UI Kit v1.0, P1 wireframes, страница Ready for Dev).
* Подтверждена готовность Mobile skeleton к старту фич (слои, DI, навигация shell, storage-контракты).
* Backend подтвердил стабильность Auth/Tasks/Calendar API и требует жёсткой дисциплины по TZ/updated_at/request_id.
* AI определил минимальный контракт Planner v1 (Tasks, Calendar, Preferences, Goals, Metadata).
* QA сформулировал требования к качеству базовых модулей и базовый набор smoke-тестов для Sprint 01.

---

## 3. Decisions (Решения)

| #   | Решение                                                                                                                                                       | Обоснование                                                                                                   | Owner внедрения                |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------ |
| D1  | Утверждено P1-ядро MVP: Auth/Onboarding, Calendar Day, Tasks, Goals (базово), Inbox, AI Planner v1 (Pro-only), Notifications, Offline Sync, Core Architecture | Соответствие Product Vision, Roadmap и Metrics Plan; ядро, на котором строится A1/A2 и дальнейшая монетизация | Олег / Антон                   |
| D2  | Разделение спринтов: Sprint 01 = фундамент + A1, Sprint 02 = A2 + AI Planner skeleton                                                                         | Снижение риска расползания скопа, фокус на быстрой активации и устойчивом фундаменте                          | Олег / Антон                   |
| D3  | В Sprint 01 реализуем Calendar Day без drag&drop и сложных recurrence                                                                                         | Ускорение time-to-value, уменьшение технической сложности и рисков миграций на старте                         | Антон / Даниил / Егор          |
| D4  | Вводим MVP-ограничение: 1 задача = 1 слот в календаре (no many-to-many)                                                                                       | Снижение сложности Calendar/Tasks/AI, уменьшение риска сложных миграций по связям                             | Антон / Егор                   |
| D5  | Рабочие графики в MVP реализуются в простом формате (без сложных паттернов и истории смен)                                                                    | Избежать высокой сложности в Calendar и Data Model на MVP-этапе                                               | Антон / Егор                   |
| D6  | AI Planner v1 на MVP работает как rule-based+LLM skeleton с минимальным контрактом (Tasks, Calendar, Preferences, Goals)                                      | Быстрый запуск Pro-ценности, минимизация рисков ML и сложности персонализации на старте                       | Олег / Игорь                   |
| D7  | Все времена храним в UTC, клиент передает TZ в заголовке; единый middleware для idempotency/updated_at/request_id                                             | Устойчивость Offline Sync, консистентность данных, снижение риска критических багов в проде                   | Егор / Даниил                  |
| D8  | Crash-free цель для MVP: ≥99% (цель после стабилизации — 99.5%+)                                                                                              | Поддержка премиального позиционирования продукта и Pro-монетизации                                            | Олег / Леонид                  |
| D9  | Обязательная аналитика для событий A1/A2 с первого релиза (User_SignUp, Onboarding_Complete, Task_Created, Calendar_Connected и др.)                          | Необходимо для измерения активации, конверсии в Pro и продуктовых решений                                     | Антон / Виктор / Даниил / Егор |
| D10 | Design-файлы P1 (UI Kit v1.0, Ready for Dev) считаются единственным источником правды для визуала и взаимодействий                                            | Устранение разночтений, ускорение разработки и QA, снижение design-debt                                       | Борис                          |
| D11 | AI Planner API и JSON-схемы фиксируются как отдельный контракт, backend агрегирует данные, клиент передает только период и request_id                         | Разделение ответственности, упрощение клиента, соблюдение AI Architecture                                     | Игорь / Егор                   |
| D12 | QA Definition of Ready/Done становится обязательной для задач Sprint 01, влияющих на A1/A2                                                                    | Защита от недоделанных задач в критичных сценариях, контроль качества с первого инкремента                    | Леонид / Антон                 |

---

## 4. Action Items

### 4.1 Product

| #  | Action Item                                                                                                                                                                    | Owner          | Deadline (относительно встречи) | Статус |
| -- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------- | ------------------------------- | ------ |
| P1 | Зафиксировать Sprint 01 Scope в формате Sprint Plan (Auth/Onboarding, Tasks CRUD без целей, Calendar Day basic, Inbox MVP, Notifications infra, аналитика A1) и завести в Jira | Антон          | 3 рабочих дня                   | Open   |
| P2 | Подготовить сводную таблицу DoR/DoD по модулям Sprint 01 (Auth, Onboarding, Tasks, Calendar Day, Inbox, Notifications, Analytics)                                              | Антон          | 3 рабочих дня                   | Open   |
| P3 | Формально описать A1/A2 сценарии и добавить их в Metrics Plan                                                                                                                  | Антон / Виктор | 5 рабочих дней                  | Open   |
| P4 | Синхронизировать Event Spec c фактическим scope Sprint 01 (A1-события)                                                                                                         | Виктор         | 5 рабочих дней                  | Open   |

### 4.2 Design

| #    | Action Item                                                                                                                                    | Owner    | Deadline       | Статус |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------- | -------- | -------------- | ------ |
| Dsg1 | Подтвердить и заморозить список P1-экранов для Sprint 01; убедиться, что все состояния (empty/error/loading/offline) находятся в Ready for Dev | Борис    | 3 рабочих дня  | Open   |
| Dsg2 | Обновить Interaction Guidelines для A1-flow и Calendar Day без drag&drop                                                                       | Григорий | 5 рабочих дней | Open   |
| Dsg3 | Зафиксировать дизайн-токены (цвета, типографика, spacing, corner radius, состояния) и согласовать naming c mobile-командой                     | Борис    | 3 рабочих дня  | Open   |

### 4.3 Mobile

| #  | Action Item                                                                                                                          | Owner                              | Deadline                           | Статус |
| -- | ------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------- | ---------------------------------- | ------ |
| M1 | Завершить и зафиксировать skeleton архитектуры (слои, DI, навигация shell, storage-контракты)                                        | Даниил                             | до конца 1-й недели Sprint 01      | Open   |
| M2 | Реализовать Theme / Design System (AppTheme, типографика, colors, базовые компоненты) согласно токенам Figma                         | Даниил / Дмитрий                   | до середины Sprint 01              | Open   |
| M3 | Реализовать Auth/Onboarding (домен, состояние экранов, навигация, валидация, обработка ошибок) с интеграцией с Auth API по контракту | Дмитрий (под руководством Даниила) | до конца Sprint 01                 | Open   |
| M4 | Реализовать базовый Tasks CRUD (список, создание, редактирование, завершение) без целей                                              | Дмитрий                            | до конца Sprint 01                 | Open   |
| M5 | Реализовать Calendar Day: отображение событий + создание простого события, без drag&drop и сложных recurrence                        | Дмитрий                            | конец Sprint 01 / начало Sprint 02 | Open   |
| M6 | Реализовать offline-queue v1 для задач и событий (updated_at + request_id)                                                           | Даниил                             | до конца Sprint 01                 | Open   |
| M7 | Интегрировать аналитические события A1 (User_SignUp, Onboarding_Complete, Task_Created, Reached_Calendar)                            | Даниил / Дмитрий                   | до конца Sprint 01                 | Open   |

### 4.4 Backend

| #  | Action Item                                                                                                                        | Owner          | Deadline                                 | Статус  |
| -- | ---------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------------------------------- | ------- |
| B1 | Реализовать Auth API (/signup, /login, /refresh, /forgot, /reset, /logout) согласно спецификации                                   | Егор / Евгений | до середины Sprint 01                    | Open    |
| B2 | Реализовать Tasks API (CRUD без подзадач/recurrence на MVP-этапе) с полями priority, estimated_minutes, due_at, status, goal_id    | Егор / Евгений | до конца Sprint 01                       | Open    |
| B3 | Реализовать Calendar Events API для Day View (CRUD + базовая логика без сложных recurrence)                                        | Егор / Евгений | конец Sprint 01 / начало Sprint 02       | Open    |
| B4 | Реализовать единый middleware для TZ/idempotency (UTC storage, TZ header, updated_at, request_id) и прокинуть во все критичные API | Егор           | до конца Sprint 01                       | Open    |
| B5 | Реализовать backend-агрегацию данных для AI Planner (tasks_min, calendar_min, preferences, goals_min)                              | Егор / Евгений | Sprint 02 (подготовка в конце Sprint 01) | Planned |

### 4.5 AI

| #   | Action Item                                                                                                                          | Owner                               | Deadline                                 | Статус  |
| --- | ------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------- | ---------------------------------------- | ------- |
| AI1 | Зафиксировать JSON-схемы минимального контракта Planner v1 (tasks_min, calendar_min, preferences, goals_min) и согласовать с backend | Игорь                               | 3 рабочих дня                            | Open    |
| AI2 | Реализовать stub-реализацию /v1/ai/plan_week (детерминированный шаблонный план)                                                      | Константин (под руководством Игоря) | Sprint 02 (подготовка в конце Sprint 01) | Planned |
| AI3 | Добавить audit-поля (request_id, user_hash, model_version, prompt_version) в AI сервис                                               | Игорь / Константин                  | Sprint 02                                | Planned |
| AI4 | Подготовить sample payloads (простая неделя, перегруженная неделя, выходные) для мобайла и QA                                        | Константин                          | до начала Sprint 02                      | Planned |

### 4.6 QA

| #   | Action Item                                                                                                  | Owner         | Deadline              | Статус |
| --- | ------------------------------------------------------------------------------------------------------------ | ------------- | --------------------- | ------ |
| QA1 | Сформировать Smoke Test Checklist для Sprint 01 (Auth, Navigation, Calendar Day basic, Tasks, Offline-queue) | Леонид / Марк | 5 рабочих дней        | Open   |
| QA2 | Оформить QA Definition of Ready/Done для задач Sprint 01, влияющих на A1/A2                                  | Леонид        | 5 рабочих дней        | Open   |
| QA3 | Настроить QA-стенд и debug-режим аналитики (видимость ключевых событий A1/A2)                                | Марк          | до середины Sprint 01 | Open   |
| QA4 | Подготовить e2e-сценарии для проверки TZ и offline-синхронизации (Tasks + Calendar)                          | Леонид / Марк | до конца Sprint 01    | Open   |


========================================
FILE: ./Backend/LifeMerge_docs/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning /Sprint01.md
========================================

## Sprint 01 Backlog — LifeMerge

### 🔖 Эпики (M0–M7)

* **M0 – Skeleton & Infrastructure**
* **M1 – Auth & Onboarding**
* **M2 – Tasks MVP**
* **M3 – Calendar Day MVP**
* **M4 – Inbox MVP**
* **M5 – Notifications Infra**
* **M6 – Analytics Events (A1)**
* **M7 – AI Planner v1 (Stub & Contracts)**

---

### 🧩 Бэклог задач по эпикам

#### 🟦 M0 – Skeleton & Infrastructure

* **[P0] Init project architecture (Mobile skeleton)**
  Assignee: Даниил
  Desc: DI, router shell, layer separation, navigation container
  Status: In Progress
  DoR: структура слоёв согласована, shell-роутинг определён

* **[P0] Storage Layer + SecurePrefs abstraction**
  Assignee: Дмитрий
  Desc: key-value + encrypted storage, clear interfaces
  DoR: согласованы контракты offline-хранилища

* **[P1] AppTheme / Tokens integration**
  Assignee: Дмитрий
  Figma: [Ready for Dev → Theme tokens](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=1001)
  Desc: типографика, цвета, spacing, радиусы — по токенам

* **[P1] Base UI Components (Buttons, TextFields, AppBars)**
  Assignee: Дмитрий
  Figma: [Ready for Dev → Components](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=2002)
  Desc: Button, TextField, BottomNav, Sheet, Dialog — по токенам

---

#### 🟦 M1 – Auth & Onboarding

* **[P0] SignUp / SignIn / Forgot / Reset / Logout flows**
  Assignee: Дмитрий
  Figma: [Ready for Dev → Auth](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=3010)
  Desc: форма, ошибки, интеграция с Auth API

* **[P0] RestoreSession & token refresh**
  Assignee: Даниил
  Desc: проверка токена, автоматическое восстановление

* **[P0] Onboarding flow + schedule setup**
  Assignee: Дмитрий
  Figma: [Ready for Dev → Onboarding](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=3020)
  Desc: мастер из 3 экранов, график работы, завершение онбординга

---

#### 🟦 M2 – Tasks MVP

* **[P0] Task List UI + offline sync**
  Assignee: Дмитрий
  Figma: [Ready for Dev → Tasks List](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=4001)
  Desc: список задач, offline состояние, pull-to-refresh

* **[P0] Create / Edit / Complete Task**
  Assignee: Даниил
  Figma: [Ready for Dev → Task Editor](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=4002)
  Desc: поля: title, priority, due_at, estimated_min, goal_id (nullable)

* **[P1] Offline queue: Tasks CRUD**
  Assignee: Дмитрий
  Desc: очередь операций + conflict resolution по updated_at

---

#### 🟦 M3 – Calendar Day MVP

* **[P0] Calendar Day View: static timeline + event list**
  Assignee: Дмитрий
  Figma: [Ready for Dev → Calendar Day](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=5001)
  Desc: отображение событий по времени, support offline read

* **[P0] Create Event: basic modal**
  Assignee: Даниил
  Figma: [Ready for Dev → Event Modal](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=5002)
  Desc: без повторений, один слот, заглушка времени

---

#### 🟦 M4 – Inbox MVP

* **[P1] Inbox screen + record input**
  Assignee: Дмитрий
  Figma: [Ready for Dev → Inbox](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=6001)
  Desc: запись текста, отображение списка

* **[P2] Convert Inbox Item → Task**
  Assignee: Даниил
  Desc: выбор действия при обработке inbox элемента

---

#### 🟦 M5 – Notifications Infra

* **[P1] Push infra + local permissions request**
  Assignee: Даниил
  Desc: подключение Firebase, регистрация токена, проверка разрешений

---

#### 🟦 M6 – Analytics Events (A1)

* **[P0] Send A1 events to debug: User_SignUp, Onboarding_Complete, Task_Created, Reached_Calendar**
  Assignee: Дмитрий
  Desc: логика вызова и параметров, интеграция в flow

---

#### 🟦 M7 – AI Planner v1 (Stub)

* **[P0] Validate Planner JSON schemas (tasks_min, calendar_min, preferences, goals_min)**
  Assignee: Игорь
  Desc: фиксация схем, валидация, sync с backend

* **[P1] /v1/ai/plan_week stub API**
  Assignee: Константин
  Desc: приём JSON, возвращение шаблонного плана, поля plan[], notes[], audit

* **[P1] Sample payloads: normal / overloaded / weekend-only**
  Assignee: Константин
  Desc: 3 заготовки, используемые для QA и Mobile интеграции


========================================
FILE: ./Backend/LifeMerge_docs/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning /Sprint02.md
========================================

## Metrics Plan — A1 / A2 / Core Metrics (Обновлён)

### A1 Activation (Sprint 01)

| Event               | Trigger                                           | Notes                             |
| ------------------- | ------------------------------------------------- | --------------------------------- |
| User_SignUp         | Завершена регистрация                             | email + метод                     |
| Onboarding_Complete | Пройден мастер онбординга                         | выбран график, дошёл до календаря |
| Task_Created        | Создана первая задача                             | через Task Editor                 |
| Reached_Calendar    | Пользователь открыл Calendar Day после онбординга | первый вход в планировщик         |

### A2 Activation (Sprint 02)

| Event                     | Trigger                                         | Notes                   |
| ------------------------- | ----------------------------------------------- | ----------------------- |
| Goal_Created              | Создана новая цель                              | через Goal Editor       |
| Task_Linked_To_Goal       | Привязана задача к цели                         | через goal_id           |
| Task_Attached_To_Calendar | Задача получила слот в календаре                | manual или drag         |
| AI_Planner_Used           | Пользователь нажал кнопку «Спланировать неделю» | даже если план заглушка |

### AI Metrics

| Event             | Trigger                                | Notes                 |
| ----------------- | -------------------------------------- | --------------------- |
| AI_Plan_Received  | Planner вернул plan[]                  | успешно, без ошибок   |
| AI_Plan_Confirmed | Пользователь применил план             | через UI принятия     |
| AI_Plan_Rejected  | Пользователь отменил предложенный план | измеряет недоверие/UX |

### Retention / WPAR Contribution

* WPAR = Weekly Planning Attachment Rate: есть ли цель → задачи → слот?
* Повторное использование Planner = proxy на perceived value
* Повторное создание целей = прокси на долгосрочную вовлечённость


========================================
FILE: ./Backend/LifeMerge_docs/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning /Sprint Do R Do D.md
========================================

## DoR / DoD Таблица — Sprint 01 (LifeMerge MVP)

| Модуль            | DoR                                                                          | DoD                                                                                                           | Блокирующие зависимости                           |
| ----------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------- |
| Auth              | UI в Ready for Dev, Auth API спецификация финализирована                     | Форма работает, ошибки валидируются, токены обрабатываются, debug-логика событий есть                         | Auth API (B1)                                     |
| Onboarding        | Экраны + flow в Figma, Interaction описан, данные профиля уточнены           | Онбординг сохраняет график, фиксируется `Onboarding_Complete`, навигация завершает на Calendar Day            | Schedule Settings, Event Spec                     |
| Tasks             | Список + форма + состояния экрана готовы, API финализирован                  | CRUD работает, `Task_Created` логируется, offline-queue интегрирован                                          | Tasks API (B2), Storage Layer                     |
| Calendar Day      | Экраны и таймлайн в Ready for Dev, API по /events подтверждён                | События отображаются и создаются, `Reached_Calendar` логируется, поддержка offline                            | Calendar API (B3), Timezone Middleware (B4)       |
| Inbox MVP         | UX поток описан, UI в Ready, структура хранения известна                     | Записи создаются, отображаются, конвертация в задачу работает                                                 | Tasks (M4), Storage                               |
| Notifications     | Push-структура определена, системные разрешения проработаны                  | Приложение может прислать локальный push, инфра не падает, покрыто smoke                                      | Firebase, Permissions                             |
| Analytics Events  | Event Spec готов, события A1 определены                                      | Все ключевые события A1 (`User_SignUp`, `Onboarding_Complete`, `Task_Created`, `Reached_Calendar`) логируются | Event Spec, Analytics SDK                         |
| Core Architecture | Навигация, DI, AppTheme, offline-queue API описаны                           | Навигация работает, UI подключён к теме, offline-операции синкаются                                           | Mobile skeleton (M1), Storage, Backend Middleware |
| AI Planner (stub) | JSON-схемы (tasks_min и др.) согласованы, структура /plan_week зафиксирована | Заглушка API доступна, schema-валидатор встроен, sample payloads готовы                                       | AI1, B5, Tasks, Calendar, Preferences onboarding  |


========================================
FILE: ./Backend/LifeMerge_docs/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning /Sprint Planning.md
========================================

## Sprint Planning — Sprint 01 (LifeMerge MVP)

**Даты спринта:** 15.12.2025 — 29.12.2025
**Product Owner:** Антон (PM)
**Scrum Master:** Олег (CEO, в роли фассилитатора)
**Команда:** Mobile (Даниил, Дмитрий), Backend (Егор, Евгений), AI (Игорь, Константин), QA (Леонид, Марк), Product (Антон, Виктор), Design (Борис, Григорий)

---

### 🎯 Цель Sprint 01

Закладка технического и продуктового фундамента MVP, реализация сценария A1:
**Install → Registration → Onboarding → First Task or Event Created ≤ 5 минут.**

---

### 🧱 Состав фич и модулей

| Модуль            | Описание                                                                 |
| ----------------- | ------------------------------------------------------------------------ |
| Auth              | Регистрация, логин, восстановление, logout                               |
| Onboarding        | Онбординг-мастер, выбор графика, завершение flow                         |
| Tasks             | Список, создание, редактирование, завершение задач                       |
| Calendar Day      | Просмотр событий на день, создание события                               |
| Inbox MVP         | Быстрая запись, отображение входящих                                     |
| Notifications     | Push-инфраструктура, напоминания о событиях и задачах                    |
| Analytics Events  | Интеграция событий: User_SignUp, Onboarding_Complete, Task_Created и др. |
| Core Architecture | DI, навигация, offline-queue, дизайн-система, storage                    |
| AI Planner (stub) | JSON-схемы, /plan_week заглушка, sample payloads, audit metadata         |

---

### 🔗 Связь с метриками и сценариями

* **A1 (Activation):** покрывается полностью.
* **A2 (Goal/Calendar):** подготовка foundation для Sprint 02.
* **WPAR:** подготавливаются элементы (задача, слот, цель) для расчёта.

---

### 📌 Зависимости

* Backend API (Auth, Tasks, Calendar) должны быть готовы в рамках спринта.
* AI контракты JSON (tasks_min и др.) входят в DoR.
* QA стенд и debug-аналитика — обязательны к середине спринта.

---

### ✅ Definition of Ready (DoR)

* Дизайн в статусе "Ready for Dev".
* API/JSON-схемы зафиксированы.
* UI Kit и Interaction Guidelines синхронизированы.
* Сценарии аналитики определены и внесены в Event Spec.

### ✅ Definition of Done (DoD)

* Все критичные баги устранены.
* Интеграционные события шлются в debug.
* Покрытие smoke QA сценариев.
* Модули работают офлайн и проходят sync.
* Визуально соответствуют UI Kit и Interaction Guidelines.

---

### 📁 Подзадачи (см. в Jira)

* [M1] Завершение skeleton архитектуры (Mobile)
* [M3] Auth/Onboarding UI + логика + API интеграция
* [M4] Tasks CRUD MVP
* [M5] Calendar Day View MVP
* [M6] Offline queue для задач/событий
* [B1] Auth API
* [B2] Tasks API
* [B3] Calendar Day API
* [B4] Middleware TZ/idempotency
* [AI1] JSON-схемы Planner v1
* [AI4] Sample payloads
* [QA1] Smoke checklist
* [QA3] Debug-аналитика A1


========================================
FILE: ./Backend/LifeMerge_docs/00_Administration/Meeting_Notes/Template_Meeting_Note.md
========================================

# Meeting Note — {{Название встречи}}
**Дата:**  
**Участники:**  
**Тип:** Product / Design / Tech / AI / Sprint / Planning  

---

## 1. Agenda
- Пункт 1  
- Пункт 2  

---

## 2. Discussion Summary
- Основные решения  
- Открытые вопросы  

---

## 3. Decisions
| Решение | Ответственный | Дедлайн |
|---------|---------------|---------|

---

## 4. Action Items
| Задача | Ответственный | Дата |
|--------|---------------|-------|

---

## 5. Materials & Links
- Figma  
- Jira  
- Документы  



========================================
FILE: ./Backend/LifeMerge_docs/00_Administration/Project_Charter.md
========================================

# Project Charter – LifeMerge

Официальный документ, определяющий цели, границы, принципы, ресурсы, риски и общий контекст проекта LifeMerge.

---

## 1. Project Overview (Обзор проекта)

**Название:** LifeMerge  
**Тип проекта:** Мобильное приложение + AI-платформа  
**Цель:** Создать операционную систему жизни, объединяющую календарь, задачи, цели и финансы в единую систему с AI-планировщиком.  
**Продуктовое обещание:** «Живи осознанно. Управляй всем. Достигай большего.»

---

## 2. Background & Problem Statement (Контекст и проблемы)

Современные профессионалы сталкиваются с:
- фрагментацией инструментов (календарь, задачи, заметки, финансы — отдельно),
- перегруженностью контекстами (работа, семья, здоровье, деньги),
- отсутствием связи между краткосрочными задачами и долгосрочными целями,
- финансовой неопределённостью (нет прогноза, анализа, привязки доходов/расходов к действиям),
- отсутствием персонализированного помощника, учитывающего расписание и правила пользователя.

LifeMerge решает эти проблемы комплексно.

---

## 3. Mission (Миссия проекта)

Помочь людям системно управлять своей жизнью — временем, целями, энергией и деньгами — создавая ясность, контроль и устойчивый прогресс.

---

## 4. Vision (Видение продукта)

LifeMerge станет:
- единым интерфейсом управления жизнью,
- личным помощником по продуктивности и финансам,
- системой, связывающей календарь, задачи, цели и финансы в один поток,
- платформой, адаптирующейся к личности пользователя,
- центральным элементом его ежедневной операционной среды.

---

## 5. Scope (Область проекта)

### В рамках проекта (In Scope)
- Мобильные приложения (iOS, Android) на Flutter.
- Backend-сервис (Auth, Calendar, Tasks, Finance, Inbox, AI).
- AI-планировщик задач: анализ расписания, дедлайнов, приоритетов.
- Финансовый модуль: доходы/расходы, регулярные операции, прогноз.
- GTD Inbox.
- Подписки и Pro-тариф.
- Базовая аналитика.
- Offline-кэш и отложенная синхронизация.
- Push-уведомления.

### Не входит в проект (Out of Scope)
- Полностью автономный AI (только в будущем).
- Полная web-версия (будет в Pro 2.0).
- Интеграция банков по Open Banking (этап Pro).
- Интеграции HealthKit/Google Fit (этап Autonomy).
- ML-модель, обучающаяся на данных пользователя (будущее).

---

## 6. Objectives & Success Criteria (Цели и критерии успеха)

### Основные цели проекта:
1. Создать MVP, соединяющий календарь, задачи, цели и финансы.
2. Реализовать AI-планировщик задач уровня Pro.
3. Обеспечить высокое удержание и ежедневную полезность.
4. Построить технический фундамент для дальнейшей автономности AI.

### Ключевые критерии успеха:
- **Retention D7 ≥ 25%** (целевое).
- **Trial → Pro Conversion ≥ 12–18%**.
- **AI Adoption ≥ 60% среди Pro пользователей.**
- **Crash-free ≥ 99.5%**.
- **Monthly Active Planners ≥ 40% от MAU.**

---

## 7. Deliverables (Основные артефакты)

### MVP Deliverables:
- Мобильные приложения iOS/Android.
- Календарь (день/неделя), задачи, цели.
- Финансовый модуль (доходы/расходы).
- GTD Inbox.
- Backend API + БД.
- Pro Trial + подписки.
- AI Planner v1.
- Система аналитики.
- UI-kit и дизайн систем.

### Документация:
- Product Vision, Roadmap, User Stories.
- Technical Specifications.
- Architecture documents.
- QA Plan.
- Release Plan.
- Change Management Process.
- Metrics Plan.

### MVP Functional Requirements (детализация):
- **Auth & Онбординг:** email+пароль, восстановление через письмо, онбординг 3–5 шагов с выбором рабочего графика, предложение Trial без привязки карты.
- **Календарь & Расписание:** режимы «День/Неделя», создание/редактирование/перетаскивание событий, параллельные слоты, отображение смен, время на дорогу, напоминания, привязка задач.
- **Задачи/Цели/Проекты:** задачи с приоритетами/контекстами/дедлайнами, цели/проекты, связь задач с целями, прогресс по целям, базовая фильтрация, дробление и повторяемость задач.
- **Финансы:** доходы/расходы с категориями и регулярными операциями, привязка к календарю, месячная сводка.
- **Inbox (GTD):** быстрый ввод, конвертация в задачу/цель, пошаговая обработка входящих.
- **AI Planner (Pro/Trial):** генерация плана с учётом занятости и пользовательских правил, ручное подтверждение перед записью в календарь.
- **Подписки и доступ:** просмотр тарифов, запуск Trial без списания, экран статуса подписки, видимые ограничения Free.
- **Уведомления:** запрос разрешений, настраиваемые напоминания по событиям/задачам/финансам, отдельные переключатели категорий.
- **Offline & Синхронизация:** работа с кэшем, очередь действий офлайн, автоматическая отправка и баннер статуса.
- **Настройки:** сменный график, часовой пояс, уведомления, переключение темы (опционально).

---

## 8. Constraints (Ограничения)

### Технические
- Flutter как основной фреймворк.
- PostgreSQL как основная БД.
- Строгая поддержка Offline-first архитектуры в будущем.

### Продуктовые
- Регион СНГ → важны инфляция, валюты, рабочие графики.
- Упрощённый UI — без перегрузки иллюстрациями.
- Прозрачность Pro Trial.

### Временные
- MVP за 4–5 месяцев от старта разработки.  

### Финансовые
- Ограниченные ресурсы → фокус на быстром создании ценности, а не «идеальности».

---

## 9. Assumptions (Предположения)

1. Пользователи готовы использовать приложение ежедневно или несколько раз в неделю.
2. AI-помощник увеличит ценность Pro-тарифа.
3. Финансовый модуль станет важным преимуществом на рынке СНГ.
4. Пользователи предпочтут честный Pro Trial перед paywall-first.
5. Интерфейс «Notion + Apple» хорошо воспринимается целевой аудиторией.

---

## 10. Risks (Риски)

### Технические
- Сложность интеграции AI в планировщик.
- Offline-конфликты и надёжность синхронизации.
- Потенциальные проблемы с производительностью календаря.

### Бизнес-риски
- Низкая конверсия в Pro.
- Сильная конкуренция (Notion, Todoist, TickTick, Google Calendar, local apps).
- Недостаточная привычка пользователей вести финансы.

### Продуктовые риски
- Перегруз функционалом.
- Недостаточно прозрачная ценность AI.

### Риски платформ
- Ограничения App Store/Google Play при работе с подписками.
- Региональные ограничения по платежам.

---

## 11. Stakeholders (Стейкхолдеры)

| Роль | Имя | Интересы |
|------|------|-----------|
| CEO / Founder | … | Успешный продукт, рост подписок |
| Product Manager | … | Ценность продукта, выполнение roadmap |
| Tech Lead | … | Качество архитектуры и скорость разработки |
| Backend Lead | … | Надёжность API и БД |
| AI Lead | … | Качество AI-планировщика |
| Design Lead | … | Высокий UX/UI |
| QA Lead | … | Стабильность и качество релизов |

---

## 12. Governance (Управление проектом)

- Scrum или Kanban (в зависимости от размера команды).  
- Еженедельные синки лидов.  
- Спецификация задач → refinement → DoR.  
- DoD для фич.  
- Release cadence: каждые 2 недели (patch → minor).  

---

## 13. Project Timeline (Ключевые сроки)

| Этап | Длительность | Результат |
|------|--------------|-----------|
| Pre-production | 2–3 недели | Vision, дизайн-концепт, архитектура |
| Design Sprint | 4–5 недель | UI, UX, прототипы |
| Разработка MVP | 12–16 недель | Первый рабочий продукт |
| Полировка & QA | 3–4 недели | Release Candidate |
| Closed Beta | 2–3 недели | Feedback, улучшения |
| Релиз MVP | — | Версия 1.0 |
| Pro 1.0 / Pro 2.0 | — | Дальнейшее развитие |
| Autonomy Mode | — | Дальний горизонт |

---

## 14. Approval (Утверждение)

| Имя | Роль | Статус | Дата |
|------|--------|---------|---------|
| … | CEO | ✔ | … |
| … | Product Manager | ✔ | … |
| … | Tech Lead | ✔ | … |

---

## 15. История изменений

| Дата | Версия | Автор | Изменения |
|------|---------|---------|------------|
| 2025-01-XX | 1.0 | … | Первая версия |
| … | … | … | … |



========================================
FILE: ./Backend/LifeMerge_docs/00_Administration/Team_Roles_and_Contacts.md
========================================

# Team Roles & Contacts — LifeMerge

Документ описывает роли команды, зоны ответственности, контакты и правила коммуникации между участниками.

---

## 1. Состав команды

### Product Team
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| Product Manager |Антон| Визион, roadmap, требования, приоритизация, сценарии | @username, email |
| Product Analyst |Виктор| Метрики, аналитика, дешборды, A/B | @username, email |

### Design Team
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| Lead UI/UX Designer |Борис| Дизайн-система, макеты, прототипы, user flow | @username, email |
| Interaction Designer |Григорий| Анимации, UX-паттерны | @username, email |

### Engineering Team
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| Tech Lead (Mobile) |Даниил| Архитектура Flutter, код-ревью, технические решения | @username, email |
| Flutter Developer |Дмитрий| Реализация экранов, логики, интеграций | @username, email |
| Backend Lead |Егор| Архитектура API, БД, интеграции, DevOps | @username, email |
| Backend Developer |Евгений| Реализация API, миграции БД, очереди задач | @username, email |
| AI Lead |Игорь| Архитектура AI, модели, качество AI Planner | @username, email |
| AI Engineer |Константин| Разработка моделей, тестирование, фичи AI | @username, email |

### QA Team
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| QA Lead |Леонид| QA стратегия, регрессия, e2e | @username, email |
| QA Engineer |Марк| Тестирование фич, тест-кейсы | @username, email |
| Automation QA |Николай| Автотесты, CI/CD интеграция | @username, email |

### Business & Operations
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| CEO / Founder |Олег| Vision, инвестиции, стратегические решения | @username, email |
| Support Lead (после MVP) |Пётр| Поддержка пользователей, база знаний | @username, email |

---

## 2. Карта ответственности (RACI)

### Пример (MVP функции)
| Задача | R (ответственный) | A (утверждающий) | C (консультируемый) | I (информируемый) |
|--------|-------------------|------------------|----------------------|-------------------|
| Product Vision | PM | CEO | Design, Tech Lead | команда |
| Архитектура приложения | Tech Lead | CTO | BE Lead, AI Lead | PM |
| AI Planner MVP | AI Lead | PM | Tech Lead | QA |
| Дизайн календаря | Designer | PM | Tech Lead | QA |
| Финансовый модуль (MVP) | BE Lead | PM | Designer | QA |
| Подписки и Trial | PM | CEO | BE Lead, Tech Lead | QA |
| Offline-синк | Tech Lead | PM | BE Lead | QA |
| Release | PM | CEO | QA Lead | вся команда |

---

## 3. Правила коммуникации

### Каналы
- Slack / Telegram — ежедневная коммуникация  
- Notion / Confluence — документация  
- Jira / Linear — постановка задач  
- Figma — дизайн  
- GitHub / GitLab — код  

### Важные принципы
1. **Асинхронность предпочтительнее**, если вопрос не срочный.  
2. **Встречи только по необходимости**, с чёткой повесткой.  
3. **Решения фиксируются письменно** в Decision Log.  
4. **Общие стендапы** — 10–15 минут.  
5. **Кросс-ревью**: Mobile ↔ Backend, AI ↔ Product.

---

## 4. SLA по коммуникациям

| Тип вопроса | SLA | Канал |
|-------------|------|--------|
| Критический баг (приложение падает, данные теряются) | 15 минут | Tech чат |
| Баг высокой важности | 2 часа | QA чат |
| Запросы по дизайну | 24 часа | Design чат |
| Требования и уточнения | 24 часа | Product чат |
| Код-ревью | 12–24 часа | GitHub/GitLab |
| AI-доработки | 24–48 часов | AI чат |

---

## 5. График встреч
- **Weekly Sync** — PM + Leads  
- **Design Review** — 1–2 раза в неделю  
- **Tech Review / Architecture** — раз в неделю  
- **Sprint Planning** — каждые 2 недели  
- **Sprint Retro** — каждые 2 недели  
- **AI Quality Review** — раз в неделю  

---

## 6. Доступы и владение аккаунтами
- App Store Connect: владелец — …  
- Google Play Console: владелец — …  
- RuStore Developer: владелец — …  
- Firebase: владелец — …  
- Production Database: доступ только Backend Lead + CTO  
- Monitoring/Sentry: Tech Lead + BE Lead  

---

## 7. Экстренные контакты (для hotfix)
- Tech Lead — @…  
- Backend Lead — @…  
- AI Lead — @…  
- QA Lead — @…  
- PM — @…  

---

## 8. История изменений документа
| Дата | Автор | Изменение |
|------|--------|------------|
| 2025-01-XX | … | Создан первый вариант |
| — | — | — |




========================================
FILE: ./Backend/LifeMerge_docs/01_Product/Change_Management/Change_Management_Process.md
========================================

# 🔄 **CHANGE MANAGEMENT PROCESS — LifeMerge**

## Цель процесса

Обеспечить контролируемое, прозрачное, безопасное и предсказуемое внесение изменений в продукт LifeMerge:

* минимизировать риски багов и регрессий,
* защищать стабильность AI-логики,
* не ломать данные пользователей (календарь, задачи, финансы),
* избегать хаоса в Roadmap,
* сохранять предсказуемость релизов.

---

# 1. Типы изменений

Все изменения делятся на 5 категорий:

### **1) Feature Change**

* любые фичи (новые или улучшения)
* пример: AI Planner v2, межсферная аналитика, новый отчёт.

### **2) UX/UI Change**

* изменение внешнего вида и поведения интерфейса
* пример: переработка календаря недели.

### **3) Technical Change**

* архитектурные улучшения, рефакторинг, оптимизация производительности
* пример: переход на новый state-менеджер или новый механизм кэша.

### **4) Data Model Change**

* изменение структуры таблиц, индексов, связей, миграций
* пример: добавление таблицы "accounts" в финансы.

⚠️ **Наиболее критичная для рисков категория.**
Ё
### **5) Hotfix Change**

* быстрые исправления продакшн-багов
* пример: падение при генерации AI-плана.

---

# 2. Change Request Workflow (полный цикл)

Каждое изменение проходит строгий **7-шаговый путь**:

```
Proposal → Analysis → Approval → Implementation → Testing → Release → Monitoring
```

Разберём каждый шаг.

---

# 3. Шаг 1. Change Proposal (инициация)

Инициатор: PM / Tech Lead / Designer / Support / Analytics

Форма Change Request (CR) должна содержать:

1. Заголовок
2. Описание проблемы или потребности
3. Цель изменения
4. Категория change’а
5. Пользовательская ценность
6. Технический impact
7. Зависимости
8. Риски
9. Требования к аналитике
10. Требуемая дата (если есть SLA)

CR создаётся в системе управления задачами (Jira/YouTrack/Linear).

---

# 4. Шаг 2. Analysis (оценка влияния)

Ответственные:

* PM
* Tech Lead
* Backend Lead
* QA Lead
* AI Lead (если затрагивает AI)

Проводится:

### 4.1. Impact Analysis

* затрагиваемые модули: календарь, задачи, финансы, AI, оффлайн-синк
* риски данных: миграции, изменения моделей
* влияние на Free/Pro
* UX-влияние
* зависимость между платформами iOS/Android/Web
* влияние на метрики (Retention / AI Adoption / Conversion)

### 4.2. Estimation

Оценка стоимости:

* FE (Flutter)
* BE
* AI
* QA
* Дизайн

### 4.3. Solution Draft

Черновое решение: схемы, макеты, API-контракт, архитектурная записка.

**Результат:** CR переходит в статус **Ready for Approval**.

---

# 5. Шаг 3. Approval (утверждение изменений)

Решение принимают: PM + Tech Lead
Для изменения Data Model или AI-логики — также AI Lead + Backend Lead.

### Критерий одобрения:

* Решение соответствует Roadmap
* Не ломает пользовательские данные
* Не нарушает принципы UX
* Технически возможно в заданные сроки
* Соответствует бизнес-целям

### Возможные исходы:

* Approved
* Approved with changes
* Rejected
* Deferred (перенос в будущее)

---

# 6. Шаг 4. Implementation (разработка)

Команда создаёт отдельную ветку feature/xxx в репозитории.

### Требования:

1. Следовать архитектурным правилам (Riverpod, Clean Architecture, Dio, offline queue и т.д.)
2. Для Data Model → миграции согласуются заранее с backend.
3. Для AI → используется feature flag.
4. Для UX → никто не отклоняется от Figma-схем.
5. Для сложности оценки → разбить на несколько задач (epic → stories → tasks).

---

# 7. Шаг 5. Testing (QA + авто-тесты)

QA должна протестировать 4 слоя:

1. **Unit tests:** бизнес-логика
2. **Integration tests:** API, offline-sync
3. **UI tests:** корректность отображения и поведения
4. **E2E tests:** пользовательские сценарии

Для AI:

* строгая проверка **hard rule compliance**
* проверка fallback и ошибок
* проверка глубины предложенного плана

После тестирования — отчёт QA → фиксы.

---

# 8. Шаг 6. Release (выкатка)

Варианты релизов:

### Release channels:

* **Internal** (только команда)
* **Closed Beta** (TestFlight / Google Internal)
* **Staged Rollout** (1% → 10% → 50% → 100%)

### Требования перед релизом:

1. Все критерии DoD выполнены
2. Пройдена регрессия по основным модулям
3. Crash-free rate ≥ 99.5% на staging
4. API backward-compatible
5. Чек-лист релиза заполнен PM

---

# 9. Шаг 7. Monitoring (наблюдение после релиза)

Особенно критично для:

* изменений данных (миграции),
* AI-поведения,
* планировщика задач,
* подключения подписок.

### Мониторим:

* Crash-free %
* Ошибки API
* AI rule violation rate
* Drop-offs в новых фичах
* Метрики активации
* Метрики монетизации
* Баг-репорты от пользователей

Если критические ошибки → включаем **Emergency Hotfix Process**.

---

# 10. Emergency Hotfix Process

1. QA подтверждает баг как **Critical**
2. PM/Tech Lead принимают решение → "hotfix required"
3. Создаётся ветка hotfix/xxx
4. Быстрая реализация (≤ 24 часов)
5. Минимальный набор тестов + smoke
6. Выкатка в прод аккуратно (100% или staged)
7. Постморем до 48 часов после фикса

Когда используется:

* приложение не открывается
* AI генерирует опасные/ошибочные планы
* потеря данных задач/финансов
* краши > 1% в проде
* сломанные подписки

---

# 11. Управление версиями продукта

Mobile semantic versioning:

```
MAJOR.MINOR.PATCH (пример: 1.3.2)
```

* MAJOR = крупные изменения (например, Planner v2, новые модули)
* MINOR = новые фичи MVP уровня
* PATCH = багфиксы

Backend versioning:

```
/api/v1/*
/api/v2/* (когда ломаем контракты)
```

AI versioning:

* каждая модель имеет **версию**, хранящуюся в конфиге backend:

  ```
  planner_model_version: "1.2.0"
  ```

---

# 12. Change Control Board (CCB)

Мини-группа, которая принимает решения по крупным изменениям:

### Участники:

* CEO / Founder
* PM
* CTO / Tech Lead
* AI Lead
* Design Lead

Обрабатываемые вопросы:

* крупные фичи roadmap
* изменения бизнес-модели
* рискованные изменения структуры данных
* внедрение Autonomy Mode

---

# 13. Change Risk Matrix

| Тип изменения       | Риск          | Действия                                |
| ------------------- | ------------- | --------------------------------------- |
| UI/UX change        | низкий        | обычный CR процесс                      |
| Feature change      | средний       | CR + тестирование                       |
| Data model change   | высокий       | CCB approval + миграции + staging тесты |
| AI logic change     | очень высокий | feature flag + A/B тест + rollback      |
| Offline sync change | критический   | нагрузочные тесты + E2E + fallback      |

---

# 14. Templates

## 14.1. Change Request Template

```
Title: 
Category: Feature / UI / Tech / Data / Hotfix
Summary:
Problem:
Goal:
User Value:
Technical Impact:
Affected Modules:
Risks:
API Changes:
Migration Needed: Yes/No
Estimated Effort:
Dependencies:
Metrics Affected:
Design Link:
Attachments:
```

## 14.2. Release Checklist Template

```
☐ Все DoD выполнены
☐ Пройдена регрессия
☐ Crash-free ≥ 99.5% на staging
☐ API backwards-compatible
☐ Подписки проверены (Trial, Pro)
☐ AI Planner протестирован
☐ Offline-сценарии проверены
☐ В changelog добавлены изменения
☐ Мониторинг настроен
```

---

# 15. Главные принципы управления изменениями в LifeMerge

1. **Ни одно изменение не должно ухудшать качество планирования.**
2. **AI всегда должен быть под контролем пользователя.**
3. **Структура данных — священная часть системы; менять её — только думая о миграциях.**
4. **Изменения должны улучшать метрики, а не только функциональность.**
5. **Любое изменение может быть отменено (roll back).**
6. **Feature flags — обязательны для AI и крупных модулей.**
7. **Документация обновляется всегда.**

========================================
FILE: ./Backend/LifeMerge_docs/01_Product/Metrics/Alerts_And_Thresholds.md
========================================

# Alerts & Thresholds

- **Crash-free mobile < 98%** за 24 часа → блокируем выкаты, приоритетный фикс.
- **Error rate API > 5%** на ключевых эндпоинтах (/tasks,/calendar,/finance) за 5 минут → page on-call.
- **Активация A1 < 60%** за неделю → проверка онбординга и аналитики.
- **D7 retention < 30%** → анализ когорт и причин оттока.
- **AI planner failure rate > 10%** или время ответа > 5 сек → переключение на fallback/ограничение трафика.
- **Скорость синхронизации > 5 сек** для 90 перцентиля → расследование очередей/сети.


========================================
FILE: ./Backend/LifeMerge_docs/01_Product/Metrics/Dashboards_Structure.md
========================================

# Структура дашбордов

1. **Product Health**
   - MAU/WAU/DAU, активация A1/A2, D1/D7/D30 retention.
   - Функциональное использование: % пользователей с задачами, событиями, финансами.
2. **Acquisition & Funnel**
   - Источники трафика, конверсии онбординга, время до первого value.
3. **Module Dashboards**
   - Tasks/Goals: создано/выполнено, активные цели, прогресс целей.
   - Calendar: события по источникам, конфликтные синхронизации.
   - Finance: транзакции по типам, бюджеты, ARPU (для Pro, если появится).
4. **AI Quality**
   - Успех планов, время ответа, ручные правки, жалобы.
5. **Reliability**
   - Crash-free, error rate, latency p95, нагрузка на очереди.


========================================
FILE: ./Backend/LifeMerge_docs/01_Product/Metrics/Events_Specification.md
========================================

North Star Metric – WPAR (Weekly Planning Activity Rate): доля активных пользователей за неделю, которые составили интегрированный план – связали задачу с событием календаря и целью.
Формула: WPAR = (число пользователей с ≥1 связкой «задача+событие+цель» за неделю) / (общее число Weekly Active Users) × 100%.
Обоснование: этот показатель отражает основную ценность продукта – активное еженедельное планирование. Чем выше WPAR, тем больше пользователей полноценно используют приложение для планирования времени, задач и целей, что коррелирует с долгосрочным удержанием.

Удержание на 7-й день (Retention D7): процент новых пользователей, которые возвращаются в приложение через 7 дней после регистрации. Используется для оценки удержания аудитории; целевой уровень – >30% возвращений на 7-й день. <br/>События: отслеживается по повторным визитам пользователя (например, событие App_Open на 7-й день после Signup).

Task-to-Calendar Attachment Rate: доля задач, которые были привязаны к событиям календаря. Формула: (задачи, добавленные в календарь) / (все созданные задачи) × 100%. Показатель демонстрирует, насколько активно пользователи планируют задачи во времени (в календаре). Стремимся повышать этот процент, так как привязка задач к расписанию свидетельствует о глубоком использовании продукта. <br/>События: отслеживается по событиям Task_Created и Task_Scheduled (сколько задач создано и сколько из них размещено на календаре).

Конверсия онбординга и настройки календаря: доля новых пользователей, которые завершили онбординг и создали первую задачу/событие (A1), а также подключили календарь (настроили расписание, этап A2) после регистрации. Важный показатель активации новых пользователей; целевой уровень A1-конверсии – >70%, при времени до достижения A1 < 5 минут. <br/>События: фиксируется событиями Onboarding_Complete (успешное прохождение onboarding) и Calendar_Connected (подключение внешнего календаря) у каждого нового пользователя.

Events_Specification.md
Ключевые продуктовые события (MVP)
event_name	category	trigger_point (когда фиксируется)	parameters (основные)	used_in_dashboards	notes
User_SignUp	Регистрация	Пользователь успешно зарегистрировался (создан аккаунт)	method (тип регистрации),
source (источник трафика)	Воронка активации (Amplitude)	Логируется один раз на пользователя.
Onboarding_Complete	Онбординг	Завершение всех шагов onboarding-процесса	duration (время прохождения, сек)	Воронка онбординга (Amplitude)	Соответствует достижению A1 (частично).
Task_Created	Задачи	Создание новой задачи пользователем	task_id, via (manual/AI)	Product usage (Amplitude, задачи)	Первое создание задачи используется для метрики A1.
Task_Completed	Задачи	Отметка задачи как выполненной	task_id, completion_time	Engagement (Amplitude, активность)	Используется для расчета активных пользователей (≥3 выполненных задач/неделя).
Calendar_Connected	Интеграция календаря	Подключение внешнего календаря (Google/Exchange и т.д.)	calendar_type (например, Google)	Активация A2 (Amplitude), использование	Пользователь настроил синхронизацию расписания.
Task_Scheduled	Задачи/Календарь	Привязка задачи к слоту в календаре (планирование задачи)	task_id, event_id	Feature usage (Amplitude, связь задач-календарь)	Отслеживается для метрики привязки задач к календарю.
Goal_Created	Цели	Создание новой цели пользователем	goal_type (категория/область)	Активация A2 (Amplitude), использование	Логируется при добавлении цели (альтернатива A2, если не подключён календарь).
AI_Planner_Used	AI Planner	Запуск пользователем AI-планировщика задач	tasks_scheduled (число задач в плане)	Feature usage (Amplitude, AI)	Повторное использование показывает ценность AI-планирования.
Finance_Transaction_Added	Финансы	Добавление новой финансовой транзакции	amount, category	Finance module usage (Amplitude)	Показывает вовлечённость в модуль финансов.
Finance_Initialized	Финансы	Завершение начальной настройки финансов (категории/бюджет)	categories_count	Product usage (Amplitude, Finance)	Пользователь начал использовать финансы (заполнил категории расходов).

Формат именования событий: [object]_[action] в UpperCamelCase через underscore. Например: User_SignUp (регистрация пользователя), Task_Completed (выполнение задачи), Calendar_Connected (интеграция календаря). Имена отражают сущность и совершенное действие.

Общие требования к логированию:

Каждое продуктовое событие должно логироваться одновременно в Firebase и Amplitude (дублировать события в обе системы для консистентности данных).

Логируются только значимые действия пользователя: необходимо минимизировать технический шум (не отправлять события о внутренних вызовах, рендерах UI и т.п.).

Вся логика отправки событий должна быть тщательно протестирована: проверяем, что события срабатывают единожды в нужный момент, содержат корректные параметры, и не дублируются. Желательно использовать sandbox/тестовые окружения и debug-режимы аналитики для проверки.

Структура дашбордов MVP на старте

Amplitude (продуктовая аналитика):
– Воронки по ключевым сценариям (регистрация → онбординг → A1/A2) для анализа конверсий.
– Retention: показатели удержания D1, D7, D30 (когортный анализ возвращаемости пользователей).
– North Star Metric: трекинг динамики WPAR по неделям.
– Использование функций: доля пользователей, использующих задачи, календарь, цели, финансы (активность по модулям).
– Отток на онбординге: выявление шагов онбординга с наибольшим отсевом (падение конверсии между этапами).

Firebase (качество и технические метрики):
– Crash-free sessions: процент сессий без сбоев (стабильность приложения).
– Статистика устройств: версия приложения, ОС, модель устройства (для отслеживания технических характеристик аудитории).
– Error rate: уровень ошибок (HTTP 5xx, сбои) на бэкенде и в приложении.
– Доставка push-уведомлений: метрики отправки и открытия push (сколько push доставлено и сколько из них открыто пользователями).

Metabase (бизнес-показатели, при необходимости):
– ARPU (Average Revenue Per User) – средний доход на пользователя (если в MVP предусмотрены платные функции).
– Trial‑to‑Pro конверсия – процент пользователей, перешедших с пробной версии на платную (при наличии подписки).
– LTV (Lifetime Value) – пожизненная ценность пользователя, на основе данных о доходах и удержании.
– Дополнительные аналитические запросы (SQL) для глубокой сегментации и анализа использования, которые не покрываются стандартными дашбордами.

========================================
FILE: ./Backend/LifeMerge_docs/01_Product/Metrics/Metrics_Plan.md
========================================

# Metrics Plan (MVP)

## North Star
- «Планирование, выполняемое пользователями»: доля активных, у которых есть связка задачи+событие+цель за неделю.

## Активация
- A1: завершён онбординг и создана первая задача/событие.
- A2: подключён календарь или создана цель.
- Время до A1 < 5 минут, конверсия онбординга >70%.

## Удержание
- D1/D7/D30 retention.
- Weekly Active with ≥3 выполненными задачами.
- Повторное использование AI-планировщика.

## Модульные метрики
- Календарь: % пользователей с ≥1 событием в неделю, синхронизация без конфликтов.
- Задачи/цели: среднее количество задач в день, прогресс целей.
- Финансы: MAU модуля, доля пользователей с заполненными категориями и ≥5 транзакциями/месяц.

## Качество
- Crash-free mobile >98%.
- Ошибки API (5xx) <1%.
- SLA синхронизации офлайн очереди <5 сек.

## North Star Metric – WPAR (Weekly Planning Activity Rate):
доля активных пользователей за неделю, которые составили интегрированный план – связали задачу с событием календаря и целью.
Формула: WPAR = (число пользователей с ≥1 связкой «задача+событие+цель» за неделю) / (общее число Weekly Active Users) × 100%.
Обоснование: этот показатель отражает основную ценность продукта – активное еженедельное планирование. Чем выше WPAR, тем больше пользователей полноценно используют приложение для планирования времени, задач и целей, что коррелирует с долгосрочным удержанием.

## Удержание на 7-й день (Retention D7): процент новых пользователей, которые возвращаются в приложение через 7 дней после регистрации. 
Используется для оценки удержания аудитории; целевой уровень – >30% возвращений на 7-й день. <br/>События: отслеживается по повторным визитам пользователя (например, событие App_Open на 7-й день после Signup).

## Task-to-Calendar Attachment Rate:
доля задач, которые были привязаны к событиям календаря. Формула: (задачи, добавленные в календарь) / (все созданные задачи) × 100%. Показатель демонстрирует, насколько активно пользователи планируют задачи во времени (в календаре). Стремимся повышать этот процент, так как привязка задач к расписанию свидетельствует о глубоком использовании продукта. <br/>События: отслеживается по событиям Task_Created и Task_Scheduled (сколько задач создано и сколько из них размещено на календаре).

## Конверсия онбординга и настройки календаря: 
доля новых пользователей, которые завершили онбординг и создали первую задачу/событие (A1), а также подключили календарь (настроили расписание, этап A2) после регистрации. Важный показатель активации новых пользователей; целевой уровень A1-конверсии – >70%, при времени до достижения A1 < 5 минут. <br/>События: фиксируется событиями Onboarding_Complete (успешное прохождение onboarding) и Calendar_Connected (подключение внешнего календаря) у каждого нового пользователя.


========================================
FILE: ./Backend/LifeMerge_docs/01_Product/MVP_Scope_v1.md
========================================

Регистрация и онбординг

Входящие модули и фичи: Регистрация нового аккаунта по email + паролю, вход и восстановление пароля, а также первичный онбординг пользователя. Онбординг реализован в виде мастера из ~3–5 экранов: краткое представление ценности продукта, настройка параметров (например, выбор рабочего графика 5/2, 2/2, 3/3 или кастомного расписания) и предложение активировать бесплатный Trial Pro-подписки.

Статус реализации: Входит в MVP. Все перечисленные возможности (создание учётной записи, авторизация, сброс пароля, онбординг и базовая пробная подписка) реализованы в мобильном приложении.

Пользовательская ценность: Обеспечивает быстрый старт работы с приложением. Пользователь получает защищённый доступ к своим данным и синхронизацию между устройствами, знакомится с основными возможностями LifeMerge и настраивает приложение под свой образ жизни (например, график работы) для персонализированного опыта.

Зависимости: Модуль аутентификации (для управления аккаунтами и токенами), модуль профиля/настроек (сохранение рабочего графика, часового пояса и предпочтений), интеграция с системой подписок (для активации Trial). Онбординг взаимодействует с календарём (применяет выбранный рабочий график к расписанию пользователя).

Сценарии использования: 1) Новый пользователь устанавливает приложение, регистрируется через email и пароль, после чего проходит серию экранов онбординга – узнаёт о возможностях приложения, выбирает свой рабочий график, и на финальном шаге при желании активирует Trial Pro-функций. 2) Возвращающийся пользователь входит в аккаунт и видит синхронизированные данные (ранее созданные задачи, события, цели) сразу после авторизации.

Планирование задач и целей

Входящие модули и фичи: Модуль задач (Task Manager) и модуль целей/проектов. Пользователь может создавать, редактировать и удалять задачи; указывать для них приоритет, дедлайн, контекст и статус выполнения. Поддерживаются подзадачи и повторяющиеся задачи. Задачи можно связывать с целями/проектами – для этого реализован модуль целей, позволяющий создавать цели в разных сферах жизни и отслеживать прогресс их достижения. Отображается процент выполнения цели на основе выполненных связанных задач. Также реализована базовая фильтрация и организация задач по проектам.

Статус реализации: Входит в MVP. Базовый функционал задач и целей реализован полностью в мобильном приложении. (Продвинутые возможности управления проектами, такие как совместная работа или подробная аналитика по целям, в MVP не входят.)

Пользовательская ценность: Позволяет пользователю управлять своими делами и долгосрочными целями в одном месте. Задачи привязаны к конкретным целям, что даёт понимание, как ежедневные действия приближают пользователя к его целям. Пользователь получает инструмент планирования по методологии GTD: можно разгружать голову, фиксируя задачи, и быть уверенным, что ничего не потеряется.

Зависимости: Связка с модулем календаря (задачи могут отображаться в расписании, если назначены на слот времени), с модулем уведомлений (напоминания о дедлайнах задач), с модулем аналитики (отображение прогресса по целям), а также с inbox/входящими (идея из инбокса может быть преобразована в задачу или цель). Работает в связке с офлайн-системой (создание и изменение задач/целей офлайн с последующей синхронизацией).

Сценарии использования: 1) Создание задачи и цели: пользователь добавляет новую цель (например, “Подготовиться к сертификации”), затем создаёт несколько задач внутри этой цели. Он указывает дедлайны и приоритеты, после чего видит прогресс выполнения цели (например, 0% выполнено, позже процент растёт по мере закрытия задач). 2) Управление задачами: пользователь просматривает список задач на день, отмечает некоторые из них выполненными, изменяет приоритет других. Если задача становится нерелевантной – удаляет или переносит дедлайн. Все изменения синхронизируются и при необходимости будут отражены в календаре и общей статистике целей.

Управление календарём

Входящие модули и фичи: Календарный модуль – центральный элемент приложения. Реализованы основные представления календаря: режим “День” и “Неделя” (интерактивный таймлайн) для обзора расписания. Пользователь может создавать события в календаре (с указанием названия, времени начала, длительности/конца, а также опционально места и типа события) и редактировать их. Поддерживаются повторяющиеся события (например, еженедельные встречи) и параллельные события на одно время (учёт случаев многозадачности). Предусмотрен Drag & Drop – возможность перетаскивать события и задачи по календарю для быстрого изменения времени. В календаре автоматически отображается выбранный при онбординге рабочий график (смены) – рабочие дни и выходные визуально различаются. Также учитывается время на дорогу между событиями (заложены промежутки) и конфликты по времени (приложение предупредит, если события пересекаются). Задачи из списка задач можно привязывать к временны́м слотам календаря, превращая их в запланированные активности на день.

Статус реализации: Входит в MVP. Основные функции (день/неделя, события, повторения, перемещение, отображение сменного графика) реализованы. Просмотр месяца как целого календарного сетка не реализован полноценно в MVP (может быть добавлен в будущих версиях). Синхронизация с внешними календарями (Google/Apple) не выполняется в рамках MVP, фокус сделан на собственном календаре приложения.

Пользовательская ценность: Позволяет пользователю видеть полную картину своего времени и планировать дни и недели с учётом всех активностей. Календарь интегрирован с задачами и финансами, поэтому в одном месте отображаются и события (встречи, тренировки, рабочие смены) и запланированные задачи, и даже важные финансовые транзакции (например, день зарплаты). Это обеспечивает целостное управление временем. Гибкость календаря (поддержка нестандартных графиков, параллельных задач) помогает адаптировать планировщик под реальную жизнь пользователя.

Зависимости: Интеграция с модулем задач/целей (задачи добавляются в календарь), с модулем финансов (календарь может отображать финансовые события, привязанные к датам, такие как регулярные платежи или поступления), с уведомлениями (напоминания о наступлении событий). Зависит от настроек пользователя (рабочий график, часовой пояс) и от модуля офлайн-синхронизации, чтобы изменения в расписании не терялись без сети.

Сценарии использования: 1) Планирование недели: пользователь открывает вид “Неделя” и видит рабочие дни и выходные. Он перетаскивает 3 задачи из списка на свободные окна во вторник и четверг, создаёт событие “Встреча с клиентом” в среду 15:00, дублирует его на каждую неделю (повторение), и убеждается, что в календаре не осталось конфликтов. 2) Ежедневный просмотр: утром пользователь переключается в режим “День” и просматривает текущий день – отмечены рабочие часы согласно графику, запланированы две задачи (например, с 10:00 до 11:00 и с 17:00 до 18:00) и одно событие в обед. Приложение напомнит уведомлением за выбранное время до начала каждой активности.

Финансы

Входящие модули и фичи: Финансовый модуль для базового учёта личных финансов. Пользователь может добавлять транзакции доходов и расходов с указанием суммы, категории и даты. Поддерживаются регулярные операции (например, ежемесячная зарплата или аренда) для автоматического добавления в бюджет. Имеется справочник категорий расходов и доходов, адаптированных под СНГ. Реализован дашборд “Месяц” – агрегированная сводка финансов за текущий месяц: общая сумма доходов, расходов и расчёт баланса; прогресс исполнения бюджета. Пользователь может устанавливать простые бюджетные ограничения (например, лимит расходов на месяц) и видеть прогноз до конца месяца с учётом регулярных транзакций.

Статус реализации: Входит в MVP (базовая версия). Основной функционал учёта финансов реализован: ручной ввод транзакций, категории, повторяющиеся платежи, просмотр статистики за месяц. Расширенные возможности (например, несколько счетов, детальная аналитика по категориям за период, интеграции с банковскими API для авто-импорта) – не включены в MVP.

Пользовательская ценность: Позволяет пользователю отслеживать свои финансы в том же приложении, где он планирует время и задачи. Благодаря этому он видит целостную картину ресурсов: куда уходит не только время, но и деньги. Это повышает осознанность расходов и помогает планировать бюджеты. Связка с календарём даёт понимание, когда ожидаются крупные траты или поступления (например, приложение может отобразить день зарплаты в календаре). В результате пользователь лучше контролирует финансовые цели (накопления, сокращение долгов и т.п.).

Зависимости: Модуль категорий (для классификации транзакций), модуль календаря (отображение финансовых событий – для регулярных платежей, дат зарплаты и т.д.), модуль уведомлений (напоминания о предстоящих платежах). Зависит от системы синхронизации (чтобы данные о транзакциях были доступны офлайн и синкались при восстановлении сети). Также связан с аналитикой приложения – финансовые данные могут влиять на AI-аналитику и подсказки в будущем.

Сценарии использования: 1) Учёт расходов: пользователь после каждой покупки открывает раздел “Финансы” и добавляет расход – например, 500₽ в категории “Продукты” сегодня. В течение месяца он вносит доход (зарплата) и десятки расходов. На экране дашборда он видит, что, например, за текущий месяц потрачено 20,000₽ из бюджета 30,000₽ (оставшийся лимит 10,000₽). 2) Регулярные платежи: пользователь задаёт регулярный расход “Абонемент в спортзал 1000₽ каждый месяц 1-го числа”. Приложение автоматически добавляет такую транзакцию в начале нового месяца и может отобразить событие в календаре 1-го числа с пометкой, что будет списание. Пользователь получает уведомление в этот день и не забывает заложить нужную сумму.

GTD Inbox (Входящие)

Входящие модули и фичи: Модуль Inbox для сбора входящей информации и идей по принципу GTD. Пользователь в любой момент может быстро зафиксировать новую мысль, задачу или напоминание в виде элемента “Inbox” (минимум полей – например, только текст заметки). Далее предусмотрена обработка входящих: элемент из Inbox можно преобразовать в задачу, событие календаря или цель одним нажатием, когда пользователь разбирает накопившиеся записи. Inbox поддерживает базовый список уведомлений из разных модулей (например, непрочитанные напоминания также могут попадать во входящие для обзора). Присутствует функционал последовательной обработки: пользователю предлагается просмотреть каждый элемент inbox и решить, во что его конвертировать или удалить, что соответствует GTD-практикам “разбора входящих”.

Статус реализации: Входит в MVP. Реализованы создание элементов Inbox, их хранение локально и на сервере, а также конвертация входящего элемента в запись другого модуля (задачу, событие календаря или цель). Дополнительные AI-подсказки для автоматической категоризации или рекомендации действий (заявленные в Pro-версии) – не входят в функционал MVP.

Пользовательская ценность: Позволяет оперативно фиксировать любые мысли или задачи, не заботясь сразу о их месте в структуре. Пользователь освобождает голову, зная, что ничего не потеряется: всё незакреплённое временно складируется во входящих. Затем, в удобное время, он обрабатывает Inbox и раскладывает элементы “по своим местам” – планирует как задачу, добавляет в календарь или относит к какой-то цели. Это повышает продуктивность и снижает стресс от необходимости держать всё в памяти.

Зависимости: Тесно интегрирован с модулями задач, календаря и целей (так как преобразование создаёт объекты в этих модулях). Связан с уведомлениями (например, пропущенное уведомление может сохраниться во входящих для внимания пользователя) и с AI-модулем (в будущем – для умных подсказок классификации, которые в MVP отключены). Зависит от офлайн-режима: записи Inbox можно делать без сети, они синхронизируются позже.

Сценарии использования: 1) Быстрая запись идеи: пользователь по пути на работу открывает Inbox и быстро печатает заметку “Купить подарок на др\n рождения мамы”. Пока он занят, эта запись просто хранится во входящих. Вечером он открывает приложение, заходит в Inbox и конвертирует эту заметку в задачу с дедлайном на нужную дату. 2) Обработка входящих: пользователь раз в день открывает Inbox, где накопилось, скажем, 5 элементов (заметки, идеи). Он последовательно проходит по каждому: какие-то сразу удаляет как неактуальные, какие-то превращает в задачи, назначая им дату, а один элемент преобразует в событие календаря. В итоге Inbox очищается, все дела разнесены по своим категориям.

AI-планировщик

Входящие модули и фичи: Модуль AI Planner – интеллектуальный помощник для планирования расписания. На этапе MVP доступен ограниченно и только для Pro-пользователей (либо на период Trial). Функциональность: пользователь может запросить у AI-сервиса сформировать оптимальное недельное расписание на основе текущих задач, событий календаря и предпочтений. Первая версия AI-планировщика учитывает базовые правила: не планировать задачи на позднюю ночь, соблюдение выходных дней, добавление буферов между событиями. AI анализирует список невыполненных задач пользователя, их приоритеты, длительности, а также занятость календаря, после чего предлагает расписание – распределяет задачи по свободным слотам недели с учётом указанных ограничений. Результат планирования показывается пользователю в виде черновика расписания, пользователь может внести правки и подтвердить план, после чего задачи расставляются в календаре. Также AI может предоставить текстовые инсайты – например, краткое объяснение, почему выбрано такое расписание, или советы по продуктивности.

Статус реализации: Частично входит в MVP. Первая версия AI-планировщика реализована и работает через внешний AI-сервис (LLM API). Однако функциональность доступна только в платной версии (ограничение тарифа Free). Бесплатные пользователи увидят заглушку с предложением попробовать Trial. Продвинутые функции AI (учёт энергии пользователя, голосовые команды, полностью автономное планирование и т.д.) находятся за рамками MVP.

Пользовательская ценность: Предоставляет уникальное преимущество приложения – экономит время пользователя на ручное планирование. AI выступает как “умный ассистент”, который на основе данных о задачах и расписании генерирует оптимальный план недели. Пользователь получает персональные рекомендации – когда лучше выполнить ту или иную задачу, как сбалансировать работу и отдых. В итоге повышается продуктивность: меньше прокрастинации и забытых дел, более равномерная нагрузка в течение недели. Даже в первой ограниченной версии AIPlanner помогает пользователю увидеть возможный план и снять с него часть когнитивной нагрузки по распределению задач.

Зависимости: Глубоко интегрирован с модулями задач, календаря и целей – AI берёт входные данные из них. Зависит от backend AI-сервиса (вычисления плана происходят на стороне сервера/модели). Требует актуальной информации о предпочтениях пользователя (рабочие часы, выходные, личные запретные временные окна – эти настройки берутся из профиля). После составления плана создаёт события в календаре (через backend API). Также связан с модулем уведомлений (например, может присылать уведомление “Новый AI-план готов”) и с модулем подписки (чтобы проверять доступность функции для данного пользователя).

Сценарии использования: 1) Запуск недельного планирования: в воскресенье вечером пользователь нажимает “Спланировать неделю (AI)”. Приложение показывает индикатор, затем отображает предварительное расписание: все несделанные задачи распределены по дням предстоящей недели с учётом его уже запланированных встреч. Пользователь видит, что, например, в понедельник AI поставил 3 задачи высокой приоритетности утром, а вечер оставил свободным для отдыха. Он принимает план, и задачи автоматически занимают слоты в календаре. 2) Частичный ре-план: в середине недели пользователь выполнил не все задачи за понедельник. Он удаляет пропущенные задачи из календаря и снова обращается к AI с запросом перепланировать оставшиеся на оставшиеся дни. AI пересчитывает и предлагает скорректированный план, который пользователь редактирует (например, убирает задачу с четверга) и сохраняет.

Уведомления

Входящие модули и фичи: Модуль уведомлений отвечает за отправку push-уведомлений пользователю о важных событиях и задачах. Реализованы напоминания о событиях календаря и дедлайнах задач – с настраиваемым временем упреждения (например, за 10 минут до события, за 1 день до дедлайна задачи). Также предусмотрены уведомления о финансовых событиях (например, напоминание “сегодня день оплаты счета” на основе регулярной транзакции). Пользователь может управлять категориями уведомлений – например, отключить пуши о финансах, но оставить о задачах. Помимо точечных напоминаний, реализован ежедневный и еженедельный дайджест: утром приложение может прислать краткий обзор дня (сколько дел запланировано, ближайшие события, прогноз погоды – при интеграции, и т.п.), а в конце недели – сводку выполненных задач, прогресса по целям и финансового баланса. (Дайджесты настраиваемые, их можно выключить.)

Статус реализации: Входит в MVP. Базовые пуш-уведомления реализованы через сервисы FCM/APNs. Настройка времени и типа напоминаний доступна в приложении. Отправка дайджест-уведомлений реализована ограниченно (например, только текстом, без сложной инфографики). Внешние интеграции (например, погодные уведомления или email-рассылки) не используются в MVP.

Пользовательская ценность: Помогает пользователю ничего не пропустить – приложение своевременно напоминает о запланированных событиях и дедлайнах, тем самым повышая надёжность ведения дел в LifeMerge. Дайджесты позволяют оглянуться на прогресс: сколько всего сделано за день/неделю, что потрачено, чего достигли – это мотивирует продолжать использование и улучшает осознанность пользователя о своих достижениях и планах. Уведомления делают приложение более “живым” и полезным в ежедневной рутине без необходимости постоянно его открывать.

Зависимости: Интеграция с модулями задач, календаря и финансов – эти модули предоставляют события, по которым нужно отправлять уведомления (время начала события, срок задачи или дата платежа). Зависит от системных сервисов уведомлений (Firebase Cloud Messaging для Android, Apple Push Notification service для iOS). Связан с настройками профиля (пользовательские предпочтения по уведомлениям, временные окна “Do not Disturb”). Также зависит от точности данных календаря/задач: если задача не имеет дедлайна, уведомление не сформируется.

Сценарии использования: 1) Напоминание о событии: за 15 минут до начала встречи, добавленной в календарь, пользователь получает push на телефон: “⚡️ Встреча с клиентом в 14:00 (через 15 мин)”. Благодаря этому он успевает подготовиться и не пропускает событие. 2) Еженедельный отчёт: в воскресенье вечером приложение присылает уведомление: “Ваш прогресс за неделю: выполнено 12 задач, достигнут прогресс в 2 целях, баланс финансов +5% от плана. На следующей неделе – 3 задачи запланированы. Отличная работа! ✨”. Пользователь открывает приложение, чтобы подробнее посмотреть аналитику, вдохновлён результатами.

Оффлайн-режим и синхронизация

Входящие модули и фичи: Поддержка полнофункциональной работы приложения офлайн. Реализована локальная база данных (SQLite через пакет sqflite) для хранения всех основных сущностей: задачи, события календаря, цели, финансовые транзакции, а также специальная очередь операций для синхронизации. При отсутствии интернет-соединения все изменения, вносимые пользователем (создание или редактирование задач, событий, целей, финансовых записей), сохраняются локально и ставятся в очередь. Как только связь восстановится, приложение автоматически отправит накопленные операции на сервер. Реализован механизм разрешения конфликтов: у каждой записи есть метка updated_at, при синхронизации возможен детект конфликтов (например, запись была изменена на другом устройстве) – тогда сервер вернёт ошибку, и клиент покажет пользователю уведомление или выполнит стратегию слияния изменений. В UI приложения предусмотрен индикатор состояния синхронизации (например, значок офлайн-режима или баннер “Соединение потеряно/восстановлено”). Также все просмотренные данные кэшируются, чтобы были доступны без сети в режиме Read-Only.

Статус реализации: Входит в MVP. Офлайн-режим поддерживается для всех основных сценариев: создание/редактирование задач, событий, целей и финансовых записей без интернета – с последующим автоматическим sync. Покрыт базовый случай конфликтов (последний updated_at побеждает). Ограничения: в MVP синхронизация происходит сразу при появлении сети или вручную по открытию приложения; более тонкая настройка (например, выбор только Wi-Fi для sync) не реализована.

Пользовательская ценность: Даёт уверенность, что приложение доступно в любое время и в любом месте, даже без подключения к интернету. Пользователь может, к примеру, в самолёте или в метро продолжать работать: добавлять задачи, отмечать выполненное, смотреть календарь. Все изменения надёжно сохраняются локально и не будут потеряны. Это особенно важно для планировщика, претендующего на роль “операционной системы жизни” – он должен быть надёжным и автономным. Офлайн-синхронизация повышает доверие: пользователь знает, что данные синхронизируются корректно, даже если связь прерывалась.

Зависимости: Зависит от модулей хранения данных на устройстве (локальная БД, шифрование хранилища для чувствительных данных). Тесно связан с backend API – все операции повторяются на сервере, когда появляется связь. Требует поддержки в каждом функциональном модуле: задачи, календарь, финансы и т.д. должны правильно ставить операции в очередь. Также интегрирован с модулем уведомлений: при длительном офлайне может быть показан баннер о режиме офлайн. Безопасность: учитывается ограничение на количество офлайн-сессий (до 3 активных устройств на аккаунт).

Сценарии использования: 1) Создание задачи без сети: пользователь находится под землёй без интернета и добавляет новую задачу в приложении. Приложение моментально сохраняет её локально и помечает значком синхронизации. Когда пользователь выйдет в сеть, задача автоматически отправится на сервер, и значок пропадёт. 2) Редактирование календаря офлайн: пользователь в отпуске, Интернет дорогой. Он вносит несколько изменений в календарь (двигает события, добавляет задачи на дни). Приложение сохраняет всё локально. Позже, подключившись к Wi-Fi, пользователь открывает приложение – оно синхронизирует все изменения за несколько секунд (батчем). Все устройства пользователя теперь обновлены с учётом этих правок.

Free vs Pro Rules (MVP)

В рамках MVP реализовано разграничение функциональности между бесплатной версией (Free) и платной подпиской (Pro). Ниже перечислены ограничения для бесплатных пользователей и соответствующие преимущества Pro:

AI-планировщик задач: Доступен только пользователям Pro-тарифа (включая Trial-период); у бесплатных аккаунтов эта функция отключена. То есть Free-пользователь не может запустить автоматическое расписание недели – в приложении ему будет предложено оформить Trial или подписку для использования AI.

Продвинутые аналитические отчёты: В бесплатной версии доступны только базовые метрики и отчёты (например, количество выполненных задач, общий прогресс целей, суммарные доходы/расходы за месяц). Расширенная аналитика и прогнозы доступны в Pro. Например, детальная статистика по времени (помесячные тренды, разбивка дня по сферам), по финансам (анализ категорий, уведомления о превышении бюджета) и по целям (вклад каждой задачи в прогресс цели) будут эксклюзивом Pro-подписки.

Финансовые счета и бюджеты: Бесплатный пользователь может вести только один счёт (кошелёк) для учёта финансов; функция добавления нескольких счетов открывается на Pro-тарифе. Также в Free доступен лишь простой месячный бюджет (общий лимит расходов на месяц). Настройка нескольких бюджетов (например, отдельные лимиты по категориям) и продвинутые финансовые функции планирования доступны в Pro.

Количество целей и задач: В бесплатном плане предусмотрены ограничения на масштаб использования. Например, можно активно вести не более 5 целей одновременно; создание большего числа целей требует перехода на Pro. По задачам ограничение может составлять 100 активных задач (попытка добавить свыше покажет уведомление о необходимой подписке). В Pro-версии ограничения на количество целей и задач сняты (можно вести неограниченно проектов и задач). Примечание: сами базовые функции создания/редактирования задач и целей есть в обеих версиях – речь идёт лишь об ограничении объёма данных.

Дополнительные функции и сервисы: Некоторые возможности, не критичные для ядра, зарезервированы за Pro. Например, шаблоны расписаний и повторяющихся задач, а также расширенные правила планирования (тонкая настройка условий, когда планировщик может назначать задачи) отнесены к Pro-тарифу. Приоритетная поддержка (более быстрый ответ службы поддержки) также доступна только Pro-подписчикам. Мультиязычность и веб-версия планируются как часть развития Pro-предложения в будущем. На этапе MVP приложение доступно на русском языке, веб-интерфейс отсутствует для всех пользователей.

Trial-период: Новый пользователь может активировать бесплатный Trial (пробный период) продолжительностью 7–14 дней. На время Trial доступны все Pro-функции (AI, расширенные отчёты и др.) в полном объёме, что позволяет оценить преимущества платного тарифа. После окончания Trial функциональность откатывается до Free, если пользователь не оформит платную подписку.

========================================
FILE: ./Backend/LifeMerge_docs/01_Product/Product_Vision/Competitors_Comparison.md
========================================

# Сравнение с конкурентами

| Продукт | Сильные стороны | Ограничения | Что делаем иначе |
|---------|-----------------|-------------|------------------|
| Todoist | Простота задач, кроссплатформенность | Нет финансов и календаря, AI ограничен | Единая связка задачи+календарь+финансы, локализация СНГ |
| Notion | Гибкость, базы данных | Высокий порог входа, нет готовых шаблонов календаря/финансов | Готовые сценарии, мобильный UX, автоматизация AI |
| Google Calendar | Стабильная синхронизация событий | Нет целей/задач/финансов | Добавляем управление задачами и целями поверх календаря |
| YNAB/Дзен-мани | Глубокий финучёт | Нет задач/целей/AI | Объединяем финансы с планированием времени и целей |


========================================
FILE: ./Backend/LifeMerge_docs/01_Product/Product_Vision/Personas/Persona_1.md
========================================

# Персона 1: Мария, 32, продакт-менеджер

- Живёт в Москве, работает в ИТ, совмещает работу, спорт, личные проекты.
- Боли: много встреч, задачи разлетаются по почте/мессенджерам, нет связки с личными финансами.
- Цели: успевать тренироваться 3 раза в неделю, закрывать квартальные OKR, копить на отпуск.
- Как помогает LifeMerge: планирует неделю с учётом встреч, видит нагрузку по дням, отслеживает расходы и бюджет, AI предлагает фокус-задачи.


========================================
FILE: ./Backend/LifeMerge_docs/01_Product/Product_Vision/Personas/Persona_2.md
========================================

# Персона 2: Алексей, 28, врач-ординатор

- Работает по сменам, часто меняется график, нужно планировать экзамены и личные дела.
- Боли: отсутствие единого календаря смен, забывает оплачивать счета, нет времени распределять учебные задачи.
- Цели: пройти курс повышения, сдать экзамен, контролировать расходы.
- Как помогает LifeMerge: синхронизирует смены в календаре, напоминает о платежах, предлагает слоты для учёбы и отдыха.


========================================
FILE: ./Backend/LifeMerge_docs/01_Product/Product_Vision/Personas/Persona_3.md
========================================

# Персона 3: Ирина, 35, предприниматель

- Управляет небольшим интернет-магазином, много задач по команде, финансам и маркетингу.
- Боли: хаос в задачах, сложность видеть кассовые разрывы, нет времени на стратегические цели.
- Цели: увеличить выручку, запустить новые продукты, держать личный баланс работы и семьи.
- Как помогает LifeMerge: объединяет задачи по проектам, показывает бюджет и прогноз расходов, AI помогает распределить время между бизнесом и семьёй.


========================================
FILE: ./Backend/LifeMerge_docs/01_Product/Product_Vision/Product_Vision.md
========================================

# ✅ **PRODUCT VISION — версия 1.0 для LifeMerge (рабочее название)**

*Кроссплатформенное приложение для интегрированного управления временем, целями и финансами.*

# **1. Назначение продукта (Purpose)**

LifeMerge создаётся как **операционная система жизни для молодых профессионалов 25–40 лет**, совмещающих работу, саморазвитие, личные проекты, здоровье и финансовые цели.
Основная ценность продукта:

### **«Живи осознанно. Управляй всем. Достигай большего.»**

Это не просто планировщик задач — это интегрированная среда, объединяющая:

* **время**,
* **цели**,
* **деньги**,
* **энергию**,
* **приоритеты**,
* **и прогресс пользователя в разных сферах жизни**.

---

# **2. Видение (Vision Statement)**

LifeMerge создаёт единое пространство, где человек понимает:

* что он делает,
* почему он это делает,
* сколько это стоит (во времени, энергии и деньгах),
* и как это приближает его к личным и профессиональным целям.

Приложение помогает превратить жизнь из хаотичного списка задач в **систему, работающую на долгосрочный рост**.

---

# **3. Проблема, которую решает продукт**

Пользователи 25–40 из СНГ часто сталкиваются с:

1. **Фрагментацией информации**

   * расписание в одном приложении,
   * финансы — в другом,
   * цели — в третьем,
   * заметки/идеи — в четвёртом.

Это создаёт перегрузку контекстом и отсутствие общей картины.

2. **Перегрузкой обязанностями**
   Работа, семья, здоровье, саморазвитие — всё требует внимания одновременно.

3. **Нестабильностью среды**
   Непредсказуемый график, переработки, финансовые колебания, инфляция, валютные риски.

4. **Прокрастинацией и слабой связью задач с реальными целями**
   Большинство приложений не показывают: *как ежедневные действия влияют на долгосрочные цели*.

5. **Отсутствием персонализированных рекомендаций**
   Классические планировщики не анализируют:

* энергию,
* контексты,
* сменные графики,
* финансовую нагрузку,
* временные ограничения.

LifeMerge решает всё это в единой системе.

---

# **4. Уникальное ценностное предложение (UVP)**

### **LifeMerge — первый в СНГ интегрированный планировщик, который объединяет цели, время и деньги в одном месте и использует AI как продвинутого ассистента.**

**Ключевые отличия:**

* Календарь — **центр продукта**, а не дополнение к задачам.
* Задачи автоматически связаны с целями, временем и финансовыми последствиями.
* Поддержка сложных графиков (2/2, 3/3, ночные смены).
* Финансовый слой встроен в ежедневное планирование.
* Аналитика показывает реальную взаимосвязь сфер жизни.
* AI строго следует пользовательским правилам (этика контроля).

---

# **5. Целевая аудитория**

### **Основная:**

* Возраст: **25–40**
* Регионы: страны СНГ
* Профиль:

  * молодые специалисты,
  * менеджеры,
  * IT-специалисты,
  * медики,
  * специалисты сменных профессий,
  * фрилансеры,
  * предприниматели.

### **Психографика:**

* амбициозные,
* ценят самосовершенствование,
* живут в многозадачном мире,
* стремятся к порядку, но не хотят тратить много сил на рутину,
* ищут систему, которая *понимает их жизнь*, а не просто хранит данные.

---

# **6. Ключевые функции продукта**

### **1) Календарь нового поколения**

* Гибкие рабочие графики: **5/2, 2/2, 3/3, ночные смены, пользовательские циклы**
* Учёт дороги
* Параллельные активности
* Временные блоки, связанные с целями и финансами
* Drag&drop, умная раскладка, шаблоны расписаний

### **2) Интегрированные задачи и цели**

* Задачи привязаны к целям
* Поддержка разовых, регулярных и дробимых задач
* Приоритеты, контексты, энергозатраты
* Цели → проекты → задачи → календарь → аналитика

### **3) Финансовый модуль**

* Доходы/расходы
* Регулярные платежи
* «Финансовые события» в календаре
* Прогноз бюджета
* Несколько счетов (Pro)
* Категории расходов СНГ
* Учет валют и инфляции

### **4) GTD-фреймворк**

* Входящие (Inbox)
* Обработка и превращение элементов в задачи/цели/события
* AI-подсказки в Pro-версии

### **5) AI Pro-функции**

* Умный планировщик задач
* Рекомендации по продуктивности
* Финансовая аналитика и предупреждения
* Предложения по структуре целей
* Будущий режим полуавтономного планирования

---

# **7. Продуктовая стратегия (High-level)**

### **Free — ядро системы**

* Календарь
* Базовые задачи
* Цели
* Простая финансовая учётка
* GTD и Inbox
* Базовые отчёты

### **Pro — автоматизация жизни**

* AI
* Расширенная аналитика
* Прогнозы
* Счета и бюджеты
* Шаблоны
* Расширенные правила планирования
* Приоритетная поддержка
* Мультиязычность + Web

### **Trial**

* 7–14 дней
* Активируется после привязки карты
* Демонстрация полной мощности экосистемы

---

# **8. Дизайн-принципы**

### **1) Осознанность > визуальный шум**

Минимализм, пространство, структурность.

### **2) 70% Notion + 30% Apple**

* строгая сетка, простота, модульность
* плавность, микроанимации, depth, слабые градиенты

### **3) Прозрачность логики**

Пользователь всегда понимает, *почему* AI сделал предложение.

### **4) Контроль остаётся у пользователя**

AI — помощник, а не оператор.

### **5) Данные — главный контент**

Минимум иллюстраций, максимум аналитики и смысла.

---

# **9. Ключевые метрики успеха**

### **North Star Metric (NSM):**

**Weekly Productive Engagement (WPE)**
= количество пользователей, которые в течение недели **создают задачи + планируют время + взаимодействуют с аналитикой**.

То есть не просто открывают приложение, а реально *живут в нём*.

### **Сопутствующие метрики:**

* 7- / 30-day Retention
* Количество запланированных задач в календаре
* Количество целей с привязанными задачами
* Частота использования AI-планировщика
* LTV / CAC Ratio
* Конверсия Free → Trial → Pro
* Доля пользователей, использующих 3+ сферы (время + цели + финансы)

---

# **10. Долгосрочное видение (3–5 лет)**

### **Life OS уровня СНГ**

Платформа, которая объединяет всё:

* время
* цели
* финансы
* здоровье
* energy management
* AI-планировщик
* автоматизация рутин

### **AI-агент уровня персонального помощника**

Понимает контексты, даёт советы, анализирует состояние дел, прогнозирует будущее.
Автономность — опциональна, под контролем пользователя.

### **Экосистема из мобильного, веба и десктопа**

Единый Pro-доступ на всех устройствах.


========================================
FILE: ./Backend/LifeMerge_docs/01_Product/Product_Vision/Value_Proposition.md
========================================

# Ценностное предложение

LifeMerge экономит время и деньги, объединяя планирование задач, целей и финансов в одном приложении. Пользователь видит, куда уходит время и бюджет, и получает AI-подсказки, как двигаться к целям.

**Ключевые выгоды:**
- Единый поток: из inbox → задачи → календарь → цели.
- Контроль ресурсов: время, энергия, деньги в одном месте.
- Умные рекомендации: AI предлагает расписание недели и советы по приоритетам.
- Офлайн и локализация под СНГ, привычные валюты.


========================================
FILE: ./Backend/LifeMerge_docs/01_Product/Roadmap/Roadmap_Pro_Stages.md
========================================

# Roadmap Pro (beyond MVP)

1. **Collaboration**
   - Шеринг задач/проектов, комментарии, упоминания, история изменений.
2. **Automation & Integrations**
   - Интеграции с таск-трекерами (Jira/Trello), банковскими сервисами (для автоимпорта расходов).
   - Правила: если задача просрочена → предложить слот, если бюджет превышен → уведомление.
3. **Advanced AI**
   - Голосовые команды, чат-помощник, прогноз достижимости целей, персональные эксперименты A/B.
4. **Web/Desktop**
   - Веб-версия и десктоп-клиенты, синхронизация с мобильным приложением.
5. **Монетизация**
   - Pro-подписка: расширенные отчёты, совместная работа, дополнительные интеграции.


========================================
FILE: ./Backend/LifeMerge_docs/01_Product/Roadmap/Roadmap_Stages.md
========================================

# 🚀 **ROADMAP (Этапы развития LifeMerge)**

**MVP → Pro 1.0 → Pro 2.0 → Autonomy Mode**

---

# 🟩 **Этап 1 — MVP (Product Foundations & Validation)**

Главная цель: **проверить ядро продукта и ценность интеграции времени, целей и финансов**.

---

## 🎯 1. Основные модули

* Календарь (день/неделя)
* Сменные графики (5/2, 2/2, 3/3)
* Inbox (GTD)
* Задачи + цели (базово)
* Финансы (базовый доход/расход + регулярные операции)
* Привязка задач/финансов к календарю

---

## 🤖 2. AI — ограниченный

* Умный планировщик задач (первая версия)
* Соблюдение базовых правил:

  * не планировать в поздние часы,
  * запретные дни,
  * буфер между задачами.

---

## 💳 3. Подписки и Trial

* Trial при привязке карты
* Тарифы Free / Pro
* Ограниченные Pro-функции: AI, выделенная аналитика

---

## 🔔 4. Уведомления

* Напоминания о событиях
* Дедлайны задач
* Финансовые события (зарплата, платежи)

---

## 📊 5. Аналитика (базовая)

* Часы задач по категориям
* Доход/расход за месяц
* Прогноз бюджета (простая модель)

---

## 🧱 6. Архитектура

* Локальный кэш + отложенная синхронизация
* Инфраструктура мультиязычности (только RU)
* Готовность к Web (responsive-компоненты)

---

## 🧪 7. Цели этапа

* Проверка product-market fit
* Измерение retention 7/30
* Оценка использования AI-планировщика
* Выявление лидирующих сценариев (календарь vs цели vs финансы)

---

---

# 🟦 **Этап 2 — Pro 1.0 (Automation & Insights Layer)**

Главная цель: **повысить ценность Pro-тарифа, усилить аналитику и автоматизацию**.

---

## 🔥 1. Расширенная аналитика

### Время:

* Разбивка дня по сферам (работа/спорт/личное)
* Почасовая продуктивность
* Недельные и месячные отчёты

### Цели:

* Динамика прогресса
* «Вклад задач» в цели
* velocity (скорость выполнения задач)

### Финансы:

* Анализ категорий
* Week-over-week spending
* Зоны риска (категории, превышающие план)

---

## ⚙️ 2. Расширенные правила планирования (Pro)

* Мягкие и жёсткие запреты (например, «после 20:00 — только лёгкие задачи»)
* Лимиты по контексту день/неделя
* Распределение задач по приоритету
* Система weighting (весовые коэффициенты для AI)

---

## 🤖 3. AI Planner 2.0

* Учет энергии (лёгкие/тяжёлые задачи)
* Учет road time (переезды)
* Улучшенные алгоритмы распределения
* Гибкое редактирование предложенного плана

---

## 🧭 4. Улучшения календаря

* Режим «Месяц» в полной версии
* Быстрые шаблоны расписания
* История изменений (undo для сессий AI)

---

## 🛠 5. Улучшения GTD

* Интеллектуальные подсказки при обработке Inbox (не авто-категоризация, а рекомендации)
* Связка Inbox ↔ Проекты

---

## 🧪 6. Цели этапа

* Рост конверсии Free → Pro
* Формирование привычки «недельного планирования»
* Увеличение времени взаимодействия с задачами/целями

---

---

# 🟧 **Этап 3 — Pro 2.0 (Life Intelligence Layer)**

Главная цель: **создать интеллектуальный слой, который соединяет цели, время и деньги в единую картину жизни**.

---

## 🔗 1. Межсферная аналитика (ключевое отличие LifeMerge)

* «Как переработки влияют на здоровье/цели/бюджет»
* «Как часто финансовые стрессоры нарушают выполнение задач»
* «Как изменения в графике влияют на выполнение проектов»

---

## 🧠 2. AI-советник (Pro)

### Продуктивность:

* рекомендации по распределению задач,
* советы по концентрации,
* анализ паттернов работы.

### Финансы:

* предупреждения о превышении бюджета,
* рекомендации по перераспределению средств,
* поиск аномалий.

### Цели:

* рекомендация структуры целей,
* выявление «мертвых зон» (цели без задач),
* автоматическое создание подключаемых «дорожных карт».

---

## 🤖 3. Smart Context Awareness

* AI учитывает контекст:

  * где находится пользователь,
  * свободные временные окна,
  * привычки дня недели.
* Пример: «У тебя окно 45 минут, доступные задачи из контекста @телефон — хочешь выбрать одну?»

---

## 📲 4. Web-версия (Pro)

* Полноценный интерфейс
* Двухпанельный режим (список + календарь)
* Отчёты + работа с AI

---

## 📊 5. Финансовые улучшения

* Поддержка нескольких счетов
* Простая интеграция с банками (ручная загрузка CSV/экспорт)
* Планирование бюджета на квартал/год
* Мультивалютность + модели инфляции

---

## 🧪 6. Цели этапа

* Повышение LTV
* Перевод Pro в категорию «незаменимого ассистента»
* Повышение accuracy AI

---

---

# 🟥 **Этап 4 — Autonomy Mode (SuperPro / AI Life OS)**

Главная цель: **частичная автономность планирования жизни под контролем пользователя**.

---

## 🤖 1. Автономный режим планирования (опциональный)

AI может автоматически:

* распределять рутинные задачи,
* оптимизировать слотирование задач под цели,
* учитывать нагрузку и баланс сфер,
* корректировать план на основе новых событий.

### Контроль:

* Пользователь всегда подтверждает авто-изменения.
* Есть «история решений» AI.

---

## 🔄 2. Self-Adjusting Policy Engine

Алгоритмы, автоматически адаптирующиеся под паттерны пользователя:

* когда он наиболее продуктивен,
* когда он чаще переносит задачи,
* когда он тратит больше денег,
* как меняется энергия в течение недели.

AI подстраивает:

* буферы,
* время для тяжёлых задач,
* бюджеты,
* нагрузки по сферам.

---

## 🌐 3. Полная интеграция с экосистемами Apple/Google

* HealthKit / Google Fit для энергии и сна
* Calendar API для внешних событий
* Shortcuts / Automations
* Умные виджеты на iOS/Android

---

## 💸 4. Финансовая автономность

* автоматическая категоризация транзакций (где разрешено)
* прогнозы на основе ML
* предупреждения о рисках по целям («не уложитесь в бюджет проекта»)

---

## 🧠 5. LifeMerge Genome (личная модель пользователя)

LLM-ориентированная модель, которая знает:

* поведение,
* ритмы,
* предпочтения,
* цели,
* стиль работы,
* финансовые привычки.

Это даёт:

* гиперперсонализированные рекомендации,
* стратегическое планирование («через 6 месяцев вы достигнете X, если продолжите темп Y»).

---

## 🎯 6. Цели этапа

* Создать продукт, который работает *не вместо человека*, а *за человека*, под его контролем.
* Стать лучшим AI-Life-OS в СНГ.

---

# 📌 Сводная таблица Roadmap

| Этап              | Основные улучшения                                           | AI-уровень    | Ценность                      |
| ----------------- | ------------------------------------------------------------ | ------------- | ----------------------------- |
| **MVP**           | Календарь, задачи, финансы, базовый AI                       | Planner v1    | Проверка ядра                 |
| **Pro 1.0**       | Расширенная аналитика, правила, Planner v2                   | Context rules | Monetization power            |
| **Pro 2.0**       | Межсферная аналитика, Smart Context, Web                     | Advisor       | Жизненная система             |
| **Autonomy Mode** | Частичное авто-планирование, интеграции, персональная модель | Autonomous AI | AI-операционная система жизни |



========================================
FILE: ./Backend/LifeMerge_docs/01_Product/User_Stories/User_Stories_All.md
========================================

# 📘 **USER STORIES — LifeMerge MVP**

---

## 🎯 Обязательные функциональные требования MVP

- **Регистрация и онбординг:** US-REG-001…003, US-ONB-001…003. Обязательны email + пароль, восстановление через письмо, онбординг-мастер из 3–5 шагов с выбором рабочего графика и предложением Trial без привязки карты.
- **Календарь и расписание:** US-CAL-001…009. Поддержка режимов «День/Неделя», создание/редактирование/перетаскивание событий, параллельные слоты, отображение сменного графика, учёт дороги, напоминания и привязка задач.
- **Задачи, цели, проекты:** US-TASK-001…007. Создание задач с приоритетом/контекстом/дедлайном, цели/проекты, привязка задач к целям, отображение прогресса, базовая фильтрация, дробление и повторяемость задач.
- **Финансы:** US-FIN-001…005. Добавление доходов/расходов с категориями, регулярные операции, календарные связи и месячная сводка.
- **Inbox (GTD):** US-INB-001…004. Быстрый ввод, преобразование в задачу или цель, последовательная обработка.
- **AI (Pro):** US-AI-001…003. Планировщик доступен только в Pro/Trial, учитывает рабочий график и уже забронированные события, финальное расписание подтверждается пользователем.
- **Подписки и Trial:** US-SUB-001…004. Прозрачный просмотр тарифов, запуск Trial без списания, отображение статуса, понятные ограничения Free.
- **Уведомления:** US-NOT-001…003. Получение системного разрешения, напоминания о событиях/финансах/задачах с настраиваемым упреждением, возможность отключать категории.
- **Offline & синхронизация:** US-OFF-001…003. Просмотр кэша и создание/редактирование сущностей офлайн с отложенной синхронизацией и индикацией статуса.
- **Настройки и профиль:** US-SET-001…004. Изменение рабочего графика, часового пояса, уведомлений; переключение темы как пользовательская опция.

---

# 1. Регистрация, логин, онбординг

## 1.1. Регистрация аккаунта

**US-REG-001**
**Как** новый пользователь,
**я хочу** зарегистрироваться по email и паролю,
**чтобы** получить доступ к своим данным и синхронизации на всех устройствах.

**Acceptance Criteria:**

* Поля email и пароль обязательные.
* Ошибка при некорректном email.
* Ошибка при слишком коротком пароле.
* После регистрации пользователь автоматически авторизуется.

---

## 1.2. Вход в аккаунт

**US-REG-002**
Как пользователь,
я хочу войти по email и паролю,
чтобы получить доступ к своему профилю и данным.

**Acceptance Criteria:**

* Валидация формата email и минимальной длины пароля.
* Ошибка при неверных учётных данных.
* После успешного входа данные профиля и календаря синхронизируются.
* Сессия сохраняется до выхода или истечения токена.

---

## 1.3. Восстановление пароля

**US-REG-003**
Как пользователь,
я хочу восстановить пароль через email,
чтобы вернуть доступ в аккаунт.

**Acceptance Criteria:**

* Ввод email с валидацией формата.
* Отправка письма с одноразовой ссылкой или кодом.
* Установка нового пароля после перехода по ссылке.
* Сообщение об успехе или ошибке (не раскрывающее наличие аккаунта).

---

## 1.4. Первичный онбординг

**US-ONB-001**
Как новый пользователь,
я хочу пройти онбординг с кратким объяснением ценности приложения,
чтобы понять, чем LifeMerge может мне помочь.

**Acceptance Criteria:**

* Серия из 3–5 экранов с навигацией «вперёд/назад» и прогресс-баром.
* Возможность пропустить онбординг и вернуться к нему через настройки.
* Последний шаг ведёт к настройке графика и предложению Trial.

---

## 1.5. Настройка рабочего графика при онбординге

**US-ONB-002**
Как пользователь,
я хочу выбрать свой рабочий график (5/2, 2/2, 3/3, пользовательский),
чтобы календарь корректно отражал моё расписание.

**Acceptance Criteria:**

* Пресеты смен 5/2, 2/2, 3/3 + кастом со временем начала/длительностью смены.
* Предпросмотр того, как график отобразится в календаре.
* Сохранённый график влияет на все будущие дни календаря.

---

## 1.6. Предложение активировать Pro Trial

**US-ONB-003**
Как новый пользователь,
я хочу увидеть предложение активировать Pro Trial,
чтобы попробовать продвинутые функции перед покупкой.

**Acceptance Criteria:**

* Trial доступен без привязки карты (достаточно подтвердить email/аккаунт магазина).
* Есть понятное описание того, что включено в Pro.
* Пользователь может отложить активацию и вернуться через настройки/профиль.

---

# 2. Календарь и расписание

## 2.1. Просмотр календаря в режиме «День»

**US-CAL-001**
Как пользователь,
я хочу видеть свой день в виде таймлайна,
чтобы понимать, какие события меня ждут.

**Acceptance Criteria:**

* Интервалы не мельче 15 минут, доступна прокрутка по времени.
* Отображаются пересекающиеся события и время на дорогу между ними.
* Быстрый переход к текущему времени.

---

## 2.2. Просмотр календаря в режиме «Неделя»

**US-CAL-002**
Как пользователь,
я хочу видеть неделю целиком,
чтобы планировать распределение задач.

**Acceptance Criteria:**

* Неделя начинается с выбранного в настройках дня.
* События отображаются с укрупнёнными слотами и поддержкой зума.
* Есть переключение между «День» ↔ «Неделя» без потери контекста даты.

---

## 2.3. Создание события

**US-CAL-003**
Как пользователь,
я хочу создавать события в календаре,
чтобы фиксировать обязательные активности (работа, тренировки, встречи).

**Acceptance Criteria:**

* Обязательные поля: название, дата, время начала и длительность/конец.
* Можно указать локацию и категорию/тип события.
* Событие создаётся как из пустого слота, так и через кнопку «+».

---

## 2.4. Перемещение события (drag & drop)

**US-CAL-004**
Как пользователь,
я хочу перетаскивать события в календаре,
чтобы быстро изменять расписание.

**Acceptance Criteria:**

* Поддержка drag & drop в режимах «День» и «Неделя».
* При перемещении учитывается время на дорогу и предупреждение о конфликте.
* После подтверждения событие пересохраняется с новой датой/временем.

---

## 2.5. Параллельные события

**US-CAL-005**
Как пользователь,
я хочу иметь возможность создания нескольких событий в одно и то же время,
чтобы учитывать многозадачные процессы (например, аудиокурс во время уборки).

---

## 2.6. Отображение рабочего графика (смены)

**US-CAL-006**
Как пользователь,
я хочу, чтобы мой сменный график отображался в календаре автоматически,
чтобы всегда видеть рабочие и выходные дни.

**Acceptance Criteria:**

* Шаблон смены из настроек наносится на календарь на ближайшие 90 дней.
* Рабочие дни визуально отличаются от выходных.
* При обновлении графика расписание пересчитывается.

---

## 2.7. Учёт времени на дорогу

**US-CAL-007**
Как пользователь,
я хочу добавлять время дороги между событиями,
чтобы планирование было реалистичным.

**Acceptance Criteria:**

* Время на дорогу задаётся вручную или из пресетов (15/30/45/60 минут).
* В расписании отображается как отдельный слот между событиями.
* При перемещении исходных событий дорожные слоты сдвигаются.

---

## 2.8. Привязка задачи к календарю

**US-CAL-008**
Как пользователь,
я хочу привязывать задачу к конкретному времени,
чтобы планировать выполнение задач в контексте расписания.

**Acceptance Criteria:**

* Задачу можно назначить на свободный слот или на существующее событие.
* Ссылка на задачу видна в карточке события и на таймлайне.
* Из календаря можно открыть карточку задачи.

---

## 2.9. Напоминания о событиях

**US-CAL-009**
Как пользователь,
я хочу получать уведомления о начале событий,
чтобы не забывать о встречах и обязательствах.

**Acceptance Criteria:**

* По умолчанию уведомление за 15 минут, пользователь может выбрать другие опции.
* Push приходит даже при закрытом приложении (если разрешение выдано).
* Уведомление ведёт к экрану события.

---

# 3. Задачи, цели, проекты

## 3.1. Создание задачи

**US-TASK-001**
Как пользователь,
я хочу создавать задачи с приоритетами, контекстами и дедлайнами,
чтобы эффективно организовать свою деятельность.

---

## 3.2. Создание проекта / цели

**US-TASK-002**
Как пользователь,
я хочу создавать цели и проекты,
чтобы структурировать долгосрочные намерения.

---

## 3.3. Привязка задачи к цели

**US-TASK-003**
Как пользователь,
я хочу связывать задачи с целями,
чтобы видеть вклад действий в итоговый результат.

---

## 3.4. Отображение прогресса цели

**US-TASK-004**
Как пользователь,
я хочу видеть процент выполнения цели,
чтобы отслеживать продвижение.

---

## 3.5. Фильтрация задач

**US-TASK-005**
Как пользователь,
я хочу фильтровать задачи по приоритету, контексту и проекту,
чтобы быстро находить нужные элементы.

---

## 3.6. Дробимые задачи

**US-TASK-006**
Как пользователь,
я хочу разбивать большую задачу на несколько временных слотов,
чтобы гибко распределять нагрузку.

---

## 3.7. Регулярные задачи

**US-TASK-007**
Как пользователь,
я хочу создавать повторяющиеся задачи,
чтобы автоматизировать рутину.

---

# 4. Финансы

## 4.1. Создание расхода

**US-FIN-001**
Как пользователь,
я хочу добавлять расходы с категорией и суммой,
чтобы вести учёт финансов.

---

## 4.2. Создание дохода

**US-FIN-002**
Как пользователь,
я хочу фиксировать доходы,
чтобы видеть баланс месяца.

---

## 4.3. Привязка финансового события к календарю

**US-FIN-003**
Как пользователь,
я хочу привязывать финансовые операции к календарным событиям,
чтобы видеть, как деньги связаны со временем.

---

## 4.4. Регулярные операции

**US-FIN-004**
Как пользователь,
я хочу создавать регулярные доходы/расходы,
чтобы не вводить их вручную каждый месяц.

---

## 4.5. Просмотр месячного финансового отчёта

**US-FIN-005**
Как пользователь,
я хочу видеть сводку (доходы, расходы, баланс),
чтобы понимать финансовое состояние.

---

## 4.6. Уведомления о предстоящих финансовых событиях

**US-FIN-006**
Как пользователь,
я хочу получать пуш-уведомления о важной финансовой активности,
чтобы ничего не пропускать.

---

# 5. GTD: Inbox

## 5.1. Добавление элемента во входящие

**US-INB-001**
Как пользователь,
я хочу быстро добавлять идеи/заметки в Inbox,
чтобы не держать их в голове.

---

## 5.2. Превращение элемента Inbox в задачу

**US-INB-002**
Как пользователь,
я хочу превращать элемент Inbox в задачу,
чтобы он становился частью моего рабочего процесса.

---

## 5.3. Превращение элемента Inbox в цель

**US-INB-003**
Как пользователь,
я хочу создавать цели на основе элементов Inbox,
чтобы быстро оформлять долгосрочные планы.

---

## 5.4. Обработка Inbox

**US-INB-004**
Как пользователь,
я хочу просматривать элементы Inbox по одному,
чтобы принимать решения о дальнейших действиях.

---

# 6. AI (Pro)

## 6.1. Запуск AI-планировщика

**US-AI-001**
Как Pro-пользователь,
я хочу запустить умный планировщик задач,
чтобы получить оптимальное распределение нагрузки.

---

## 6.2. Получение предложенного плана

**US-AI-002**
Как Pro-пользователь,
я хочу увидеть предложенный AI-план,
чтобы сравнить его со своим расписанием.

---

## 6.3. Принятие/Частичное принятие/Отмена плана

**US-AI-003**
Как Pro-пользователь,
я хочу принимать или отклонять предложения AI,
чтобы сохранять контроль над своим временем.

---

## 6.4. Пользовательские правила для AI

**US-AI-004**
Как Pro-пользователь,
я хочу задавать правила (не планировать поздно, перерывы, запреты по дням),
чтобы AI подстраивался под мои предпочтения.

---

# 7. Подписки и Trial

## 7.1. Просмотр тарифов

**US-SUB-001**
Как пользователь,
я хочу видеть различия между Free и Pro,
чтобы понять смысл апгрейда.

---

## 7.2. Активация Trial

**US-SUB-002**
Как новый пользователь,
я хочу активировать Trial без привязки карты,
чтобы протестировать все Pro-функции.

**Acceptance Criteria:**

* Trial запускается по кнопке из онбординга или экрана тарифов.
* На экране указаны длительность Trial и дата автоотмены/окончания.
* В течение Trial доступны все Pro-функции, после — откат к Free без списания.

---

## 7.3. Просмотр статуса подписки

**US-SUB-003**
Как пользователь,
я хочу видеть мой текущий тариф и дату списания,
чтобы управлять подпиской.

**Acceptance Criteria:**

* На экране статуса отображаются тариф, срок действия, дата следующего списания/окончания Trial.
* Есть кнопки продления/отмены (по платформенным правилам).
* Для Free — подсказки, какие функции недоступны.

---

## 7.4. Ограничения Free (UX)

**US-SUB-004**
Как пользователь Free,
я хочу видеть прозрачные ограничения (например, «AI доступен в Pro»),
чтобы понимать, что даёт апгрейд.

**Acceptance Criteria:**

* Маркеры «Pro» видны в интерфейсе у недоступных функций.
* Переход по маркеру ведёт на экран тарифов.
* Ограничения не блокируют базовые сценарии Free.

---

# 8. Уведомления

## 8.1. Разрешение на уведомления

**US-NOT-001**
Как пользователь,
я хочу дать приложению разрешение на уведомления,
чтобы получать напоминания о задачах и событиях.

**Acceptance Criteria:**

* Системный диалог запрашивается один раз и повторно только по запросу пользователя.
* Отклонённое разрешение отображается как статус с инструкцией, как включить его в настройках устройства.
* Без разрешения напоминания не создаются и пользователь получает подсказку.

---

## 8.2. Получение напоминаний о событиях

**US-NOT-002**
Как пользователь,
я хочу получать уведомление за 15 минут до начала события,
чтобы ничего не пропускать.

**Acceptance Criteria:**

* Настраиваемое время упреждения: 5/15/30/60 минут и «в момент».
* Напоминание создаётся автоматически при создании события, если разрешения выданы.
* Тап по уведомлению открывает событие в календаре.

---

## 8.3. Управление уведомлениями

**US-NOT-003**
Как пользователь,
я хочу отключать и включать категории уведомлений,
чтобы контролировать информационный поток.

**Acceptance Criteria:**

* Отдельные переключатели для событий, задач, финансовых напоминаний и системных сообщений.
* Настройки синхронизируются между устройствами.
* Изменение настроек применяется к будущим уведомлениям.

---

# 9. Offline & Синхронизация

## 9.1. Работа без интернета (кэш)

**US-OFF-001**
Как пользователь,
я хочу иметь возможность продолжать работу без интернета,
чтобы приложение не блокировало меня.

**Acceptance Criteria:**

* Последние данные календаря/задач/финансов доступны из локального кэша.
* Созданные/изменённые сущности ставятся в очередь синхронизации.
* Пользователь видит, какие действия находятся «в очереди».

---

## 9.2. Отложенная синхронизация

**US-OFF-002**
Как пользователь,
я хочу, чтобы действия автоматически отправлялись на сервер после восстановления сети,
чтобы мне не приходилось делать это вручную.

**Acceptance Criteria:**

* Фоновые попытки синхронизации запускаются при восстановлении соединения.
* При успехе локальный статус действий обновляется без участия пользователя.
* При ошибке отправки отображается уведомление/баннер с возможностью повторить.

---

## 9.3. Оповещение о режиме офлайн

**US-OFF-003**
Как пользователь,
я хочу получать ненавязчивый баннер «Синхронизация отложена»,
чтобы понимать текущее состояние.

**Acceptance Criteria:**

* Баннер показывает статус: «Онлайн», «Оффлайн», «Синхронизация…».
* Баннер не перекрывает основной контент и может быть свернут.
* При переходе в онлайн баннер автоматически обновляется.

---

# 10. Настройки и профиль

## 10.1. Изменение рабочего графика

**US-SET-001**
Как пользователь,
я хочу изменять рабочий график в настройках,
чтобы календарь адаптировался к моей реальной жизни.

---

## 10.2. Переключение темы (Тёмная / Светлая)

**US-SET-002**
Как пользователь,
я хочу управлять темой оформления,
чтобы адаптировать интерфейс под освещение.

---

## 10.3. Изменение уведомлений

**US-SET-003**
Как пользователь,
я хочу настраивать уведомления,
чтобы приложение соответствовало моим привычкам.

---

## 10.4. Изменение временной зоны

**US-SET-004**
Как пользователь,
я хочу изменять часовой пояс,
чтобы корректно отображались все события.

---

# 11. Free / Pro дифференциация

### Free-пользователь может:

* пользоваться календарём;
* создавать задачи и цели;
* пользоваться Inbox;
* вести базовый бюджет;
* получать напоминания;
* видеть базовую аналитику.

### Pro-пользователь получает:

**US-PRO-001** — Доступ к AI-планировщику.
**US-PRO-002** — Расширенную аналитику по времени и финансам.
**US-PRO-003** — Расширенные правила планирования.
**US-PRO-004** — Неограниченное количество целей/проектов (если Free ограничен).
**US-PRO-005** — Приоритетную поддержку.

---

# 12. Autonomy Mode (опциональный AI-режим)

## 12.1. Активация и контроль режима

**US-AUTO-001**
Как пользователь,
я хочу включать/выключать Autonomy Mode через настройки и давать явное согласие на автоизменения,
чтобы автономное планирование включалось только под моим контролем.

**Acceptance Criteria:**

* Режим выключен по умолчанию и требует явного согласия.
* Есть тумблер и экран условий (что будет менять AI).
* Можно поставить на паузу без потери данных.

---

## 12.2. Автопланирование с подтверждением

**US-AUTO-002**
Как пользователь,
я хочу получать пакетные предложения от AI по перераспределению задач и событий,
чтобы быстро применять улучшенный план одним подтверждением.

**Acceptance Criteria:**

* Показывается список изменений (переносы, вставки буферов, отмены).
* Каждое изменение можно принять/отклонить, есть кнопка «Применить всё».
* Применение фиксируется в журнале AI-решений.

---

## 12.3. Self-Adjusting Policy Engine

**US-AUTO-003**
Как пользователь,
я хочу, чтобы AI автоматически подстраивал правила планирования под мои привычки (энергия, переносы, загруженность),
чтобы расписание оставалось реалистичным без ручной настройки.

**Acceptance Criteria:**

* AI обновляет буферы/слоты на основе наблюдаемых паттернов.
* Есть прозрачный лог: какие правила обновлены и почему.
* Можно откатить последние изменения правил.

---

## 12.4. Интеграции для автономности

**US-AUTO-004**
Как пользователь,
я хочу подключать HealthKit/Google Fit и внешние календари,
чтобы AI учитывал сон, активность и сторонние события при автопланировании.

**Acceptance Criteria:**

* Права запрашиваются отдельно для каждого источника.
* Пользователь видит, как данные влияют на предложения (лейблы «сон», «нагрузка», «внешнее событие»).
* Можно временно отключить использование конкретного источника данных.

---

## 12.5. История и безопасность изменений

**US-AUTO-005**
Как пользователь,
я хочу видеть историю действий AI и иметь возможность отката изменений,
чтобы чувствовать контроль над автономным режимом.

**Acceptance Criteria:**

* Есть журнал с датой, причиной и списком изменений.
* Откат возвращает расписание/правила в предыдущее состояние.
* Оповещение при массовых изменениях (например, >5 правок за раз).



========================================
FILE: ./Backend/LifeMerge_docs/01_Product/User_Stories/User_Story_Map.md
========================================

# User Story Map (high-level)

1. **Onboarding**
   - Как новый пользователь, я хочу пройти короткий опрос целей, чтобы получить персональные подсказки.
   - Как пользователь, я хочу импортировать календарь, чтобы сразу видеть свои события.
2. **Plan Day/Week**
   - Как пользователь, я хочу создать задачи и разместить их в календаре, чтобы понимать нагрузку.
   - Как пользователь, я хочу получить AI-предложение расписания недели.
3. **Execute & Track**
   - Как пользователь, я хочу отмечать задачи выполненными и видеть прогресс по целям.
   - Как пользователь, я хочу фиксировать расходы и видеть бюджет.
4. **Review**
   - Как пользователь, я хочу недельный дайджест (выполнено/финансы/цели).
   - Как пользователь, я хочу предложения, что улучшить на следующей неделе.


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/Branding/Brand_Guidelines.md
========================================

# Brand Guidelines

- Название: **LifeMerge** (одно слово, F заглавная).
- Логотип: комбинация волны/потока и чекбокса; в темной теме используем светлый логотип.
- Цвета бренда: primary #5B8DEF, accent #FF9F1C, фон #0F1115.
- Тональность: поддерживающая, практичная, без излишнего пафоса.
- Фото: реальные люди 25–40, работающие и занимающиеся хобби, с тёплым светом.
- Айконсет: линийные иконки 24px с округлыми углами.


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/Interaction_Guidelines.md
========================================

# Interaction Guidelines — LifeMerge (MVP)

*Григорий — Interaction Design / Motion / Micro-interactions*

Документ определяет принципы анимаций, переходов и микро-взаимодействий для MVP LifeMerge. Опираться на UI Kit, тёмную тему, производительность Flutter и общие UX‑паттерны из дизайн-системы.

---

## 1. Цели анимаций в LifeMerge

1. Повысить ясность интерфейса — анимации должны помогать ориентироваться в данных (календарь, задачи, финансы).
2. Передавать тактильность — физические паттерны, реалистичная инерция, лёгкие пружины.
3. Снизить когнитивную нагрузку — направлять внимание, а не привлекать его без причины.
4. Работать в тёмной теме без визуального шума.
5. Быть лёгкими для производительности (60 fps, минимизация слоёв, избегать тяжёлых эффектов).

---

## 2. Паттерны анимаций для MVP

### 2.1. Fade-Scale для появления контента

**Использование:** карточки задач, элементы списков, записи Inbox, модальные окна.

* Время: 120–160 мс
* Кривая: easeOutCubic
* Поведение: лёгкое увеличение от 0.96 → 1.0 + fade 0 → 1
* Flutter: `FadeTransition + ScaleTransition`, без лишних RepaintBoundary

### 2.2. Slide-Fade вертикальный для переходов между вкладками

**Использование:** переключение Home → Calendar → Tasks → Finance.

* Время: 160–200 мс
* Кривая: standard (0.4, 0.0, 0.2, 1)
* Избегать больших параллаксов — акцент на плавности.

### 2.3. Shared Axis (Horizontal) для Calendar / Tasks

**Использование:** переходы между списками задач, карточкой задачи, карточкой события.

* Время: 180–220 мс
* Кривая: easeInOut
* Оси:

  * Горизонталь — для навигации между sibling‑экранами
  * Вертикаль — для переходов уровня вложенности (список → детальная)

### 2.4. Opacity Lift для выделения активного элемента

**Использование:** нажатие на карточку задачи, событие календаря, элемент Inbox.

* Время: 80–120 мс
* Лёгкое повышение яркости и глубины (elevation.sheet → elevation.card)
* Без масштабирования более чем на 1–2%

### 2.5. Animated Drag Feedback

**Использование:** drag & drop событий в Calendar.

* Время обратной связи: < 16 мс (реакция в один кадр)
* Эффект: при захвате — небольшое увеличение 1.00 → 1.04, тень усиливается.
* Возврат при отмене — пружина 180–220 мс.

---

## 3. Переходы для Calendar

### 3.1. День ↔ Неделя

**Цель:** сохранить пространственное восприятие времени.

**Анимация:**

* Изменение высоты таймлайнов с анимацией layout (AnimatedSize).
* События плавно перебираются в новую сетку.
* Duration: 220–260 мс.
* Кривая: easeInOutCubic.

**Рекомендации:**

* Не масштабировать весь экран — изменять лишь сетку.
* Включить hero‑анимацию для текущей временной метки.

### 3.2. Переход список событий → карточка события

**Паттерн:** Shared Axis Vertical.

* Деталь «выезжает» сверху, список слегка затемняется.
* Duration: 180–220 мс.
* Плавный elevation shift.

### 3.3. Drag & Drop: перемещение события

* Захват: тень ↑, масштаб 1.00 → 1.04.
* Перемещение: курсор/палец «ведёт» карточку без задержки.
* Drop: пружина 160–200 мс + небольшой fade на подтверждение.
* Конфликт времени (overlap): короткий красный highlight 80 мс.

---

## 4. Переходы для Tasks

### 4.1. Список задач → карточка задачи

**Паттерн:** Shared Axis Vertical.

* Сжатие списка вниз, карточка поднимается вверх.
* Duration: 200 мс.

### 4.2. Добавление задачи

**Паттерн:** Fade-Scale Up.

* Скейл 0.96 → 1.0 + opacity 0 → 1.
* Duration: 140–160 мс.
* Подчеркнуть момент появления и облегчить восприятие нового элемента.

### 4.3. Отметка «выполнено»

**Паттерн:** Completion Sweep.

* Иконка галочки анимируется sweep‑движением 120 мс.
* Карточка выцветает 1 → 0.4 opacity + лёгкий подъём 4 px.
* Полное исчезновение через 200 мс, если настроено автоскрытие.

### 4.4. Работа с подзадачами

* Раскрытие: height animation (AnimatedSize) 160 мс.
* Чёткая визуальная иерархия за счёт сдвига и линии слева.

---

## 5. Общие принципы Micro‑Interactions

### 5.1. Реалистичные тайминги

* Малые взаимодействия: 80–120 мс.
* Средние переходы: 160–220 мс.
* Большие изменения структуры: 220–300 мс.

### 5.2. Физичность без «пружинности ради пружинности»

* Использовать пружину только для drag/drop и подтверждений.
* Для всего остального — bezier-кривые UI Kit.

### 5.3. Отсутствие лишней хореографии

* Никаких «сложных входов» списков и карточек.
* Ключевой принцип MVP — скорость и визуальная ясность.

### 5.4. Темная тема

* Избегать светящихся элементов.
* Анимации должны работать без изменения контраста.

### 5.5. Производительность

* До 2 одновременно анимируемых свойств: opacity + scale или offset + opacity.
* Layout изменения через AnimatedSize, избегать анимации больших списков.

### 5.6. Обратная связь при ошибках

* Ошибочные состояния — короткий shake или highlight 80 мс.
* Для сетевых ошибок — fade‑banner сверху 200 мс.

---

## 6. Компоненты с обязательными анимациями

* Календарь: drag/drop, переход день⇄неделя, открытие карточки события.
* Задачи: отметка выполнения, открытие карточки, добавление новой.
* Inbox: появление элемента, преобразование в задачу/цель.
* Модальные окна: fade‑scale.

---

## 7. Не допускается

* Масштабирование экрана > 4% — вызывает дезориентацию.
* Избыточные тени на тёмной теме.
* Длительные (>300 мс) переходы в основных сценариях.
* Нелинейные кривые типа bounce для текстовых списков.

---

## 8. Требования к реализации (Flutter)

* Использовать Implicit Animations там, где возможно.
* Для Calendar использовать RepaintBoundary вокруг крупных таймлайнов.
* Обязательный тест performance профилем: 60 fps на Pixel 6 / iPhone 12.
* Анимации должны учитываться в DoD: UI соответствует макетам и спецификациям анимации.

---

## 9. Следующие шаги

1. Утвердить с Lead UI/UX Designer.
2. Синхронизировать с Flutter-командой по реализуемости.
3. Добавить анимации в прототип Figma.
4. Создать библиотеку motion‑токенов (durations, curves).

---

Документ готов к итерациям и расширению для Pro 1.0.


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/Prototypes/Dark_Mode/Readme.md
========================================

# Dark Mode – Prototypes

Здесь хранятся дизайн-спецификации тёмной темы:
- основные экраны,
- компоненты,
- цветовые токены,
- уровни теней и контрастности.

Файлы пригодны для передачи разработчикам.


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/Prototypes/Notes/MVP_Wireframes.md
========================================

Структура MVP_Wireframes.md:

Введение: кратко описано, что ниже приведён список экранов MVP с пояснениями. Указано, что эти экраны отражены в прототипах/wireframes, и что детальные визуальные макеты доступны на странице "Ready for Dev" (с общим линком на файл Figma). Также поясняется система приоритетов (например, P1 – критически необходим для MVP, P2 – желательный, но может быть отложен, если не успеваем).

Список экранов по разделам: экраны сгруппированы по тем же блокам: Auth, Calendar, Tasks:

Auth:

Onboarding_v1 – Цель: познакомить нового пользователя с приложением (welcome-скрины). Приоритет: P1 (высокий), т.к. влияет на конверсию новых пользователей. Figma: Onboarding_v1.

ScheduleSetup_v1 – Цель: сбор данных о графике пользователя для персонализации. Приоритет: P2 (средний) – полезно, но не блокирует MVP, может быть упрощено. Figma: ScheduleSetup_v1.

Register_v1 – Цель: регистрация пользователя. Приоритет: P1. Figma: Register_v1.

Login_v1 – Цель: вход в аккаунт. Приоритет: P1. Figma: Login_v1.

Recovery_v1 – Цель: восстановление пароля. Приоритет: P2. Figma: Recovery_v1.

Calendar:

Calendar_Day_v1 – Цель: показать расписание на день. Приоритет: P1 (основной экран календаря). Figma: Calendar_Day_v1.

Calendar_Week_v1 – Цель: обзор недели. Приоритет: P2 (можно запустить MVP и без недельного вида, но желателен). Figma: Calendar_Week_v1.

Calendar_Month_v1 – Цель: обзор месяца. Приоритет: P2. Figma: Calendar_Month_v1.

Event_New_v1 – Цель: создание нового события. Приоритет: P1 (ядро функционала календаря). Figma: Event_New_v1.

Event_Details_v1 – Цель: просмотр/редактирование события. Приоритет: P1. Figma: Event_Details_v1.

Tasks:

Task_List_v1 – Цель: список всех задач (с фильтрами). Приоритет: P1 (основной экран задач). Figma: Task_List_v1.

Task_Detail_v1 – Цель: детали задачи. Приоритет: P1. Figma: Task_Detail_v1.

Task_Form_v1 – Цель: создание/редактирование задачи. Приоритет: P1. Figma: Task_Form_v1.

(Каждый пункт содержит имя фрейма, краткое описание цели/функции экрана, приоритет и гиперссылку на макет Figma. Ссылки указывают прямо на конкретные фреймы на странице "Ready for Dev".)

Примечания/Допущения: в конце файла приведены общие заметки. Например: «Экран “Week View” отмечен как P2 – может быть реализован во вторую очередь, если сроки поджимают, основной функционал календаря обеспечит Day и Month». Или: «В MVP не включён раздел Finance (финансы) – он в планах на будущее, поэтому в списке отсутствуют соответствующие экраны». Также зафиксировано, что критерий успешности MVP – наличие как минимум одного рабочего сценария для каждой ключевой сущности (задачи, события, цели), и перечисленные экраны этому соответствуют.

Документ MVP_Wireframes.md становится частью проектной документации. Он облегчает коммуникацию: новые члены команды или сторонние участники могут быстро понять, какие экраны будут в первом релизе и почему. При изменениях (scope change) документ обновляется. Кроме того, наличие ссылок на Figma обеспечивает актуальность: всегда можно кликнуть и увидеть последний дизайн соответствующего экрана.

========================================
FILE: ./Backend/LifeMerge_docs/02_Design/Prototypes/Web_Future/Notes/Web_Adaptive_Design_Principles.md
========================================

Здесь пока пусто

========================================
FILE: ./Backend/LifeMerge_docs/02_Design/Prototypes/Web_Future/Notes/Web_Navigation_Concepts.md
========================================

Здесь пока пусто

========================================
FILE: ./Backend/LifeMerge_docs/02_Design/Prototypes/Web_Future/Readme.md
========================================

# Web Future – Prototypes

Папка хранит концепты будущей web-версии LifeMerge:
- адаптивная панель,
- двухпанельный режим,
- календарь и финансы на широких экранах.

Файлы делятся на:
- Wireframes — структурные макеты,
- High_Fidelity — высокодетализированные дизайны,
- Notes — описание UX решений.


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/UI_Kit/Colors.md
========================================

# Цвета

| Токен | Значение | Использование |
|-------|----------|---------------|
| `primary` | #5B8DEF | Кнопки, активные элементы |
| `primaryDark` | #3562C2 | Hover/нажато, тёмная тема |
| `accent` | #FF9F1C | Уведомления, акценты на карточках |
| `success` | #34C759 | Выполнено, позитивные статусы |
| `error` | #FF3B30 | Ошибки, критичные уведомления |
| `bg` | #0F1115 | Фон приложения (dark first) |
| `surface` | #181C22 | Карточки, модальные окна |
| `textPrimary` | #FFFFFF | Основной текст |
| `textSecondary` | #B8C2D1 | Вторичный текст, подписи |


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/UI_Kit/Components/Buttons.md
========================================

# Кнопки

- **Primary**: background `primary`, текст `textPrimary`, радиус `12`, высота `52`. Состояния: default, pressed (`primaryDark`), disabled (20% opacity).
- **Secondary**: обводка `primary`, текст `primary`, фон `surface`. Hover/pressed затемнение 8%.
- **Ghost/Icon**: без рамки, padding 12, иконка 24px.
- Минимальная ширина 120px, tap area 44px.


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/UI_Kit/Components/Cards.md
========================================

# Карточки

- Фон `surface`, радиус `12`, тень `elevation.card`.
- Внутренние отступы: `16` по всем сторонам; между элементами `8`.
- Поддерживаются вариации: задача, событие, финоперация, цель (отличаются иконкой и акцентом).
- Для задач и событий показываем бейдж статуса/источника в правом верхнем углу.


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/UI_Kit/Components/Chips.md
========================================

# Чипсы

- Радиус 16, высота 32, padding 12.
- Варианты: фильтр (toggle), статус (filled), тег (outline).
- Цвета: primary для активных, surface + текст вторичный для неактивных.
- Иконка слева опциональна, крестик для удаления тегов справа.


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/UI_Kit/Components/Inputs.md
========================================

# Поля ввода

- Высота 52, радиус `12`, фон `surface`.
- Обводка 1px `primary` при фокусе, `textSecondary` по умолчанию.
- Подписи/лейблы `Caption`, плейсхолдер вторичным цветом.
- Поддержка иконки слева, кнопки очистки справа.
- Ошибка: обводка и текст `error`, вспомогательный текст под полем.


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/UI_Kit/Components/Modals.md
========================================

# Модальные окна/боттомшиты

- Радиус верхних углов 16, фон `surface`, тень `elevation.sheet`.
- Хэндл для перетягивания 40x4, отступ сверху 8.
- Внутренние отступы 20 по сторонам, кнопки внизу закреплены.
- Поддержка full-screen модалов для создания задач/событий.


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/UI_Kit/Components/Navigation.md
========================================

# Навигация

- Нижняя таб-бар на 5 вкладок: Home, Calendar, Tasks, Finance, AI/Inbox.
- FAB на Home для быстрого создания задачи/события/финоперации.
- Вторичный top-bar с переключением вида календаря (день/неделя/месяц).
- Deeplink из пушей ведёт на конкретную задачу/событие.


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/UI_Kit/Dark_Theme.md
========================================

# Темная тема

- **Dark-first:** интерфейс по умолчанию использует тёмную палитру (`bg`, `surface`), светлая тема не проработана.
- **Контраст:** минимально `4.5:1` для текста и `3:1` для иконок/бордеров. Используем `textPrimary` для основного текста и `textSecondary` для подписи/плейсхолдера.
- **Состояния поверхностей:** hover — осветляем фон на `8%`, pressed — на `12%` (можно через белый overlay), disabled — понижаем непрозрачность до `60%`.
- **Блики и тени:** карточки и модалки опираются на токены `elevation.card` и `elevation.sheet`; избегаем жёстких теней, используем мягкие размытия.
- **Акценты:** `primary` — основной брендовый цвет, `primaryDark` — для hover/pressed и тёмных фоновых элементов; `accent` применяем только для уведомлений и бейджей.
- **Изображения и логотипы:** на тёмном фоне применяем светлые версии логотипа и иллюстраций (см. бренд-гайд).
- **Градиенты и шум:** допускаются лёгкие шумовые/радиальные градиенты на фоне, но без ухудшения читаемости текста.


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/UI_Kit/Design_Tokens.json
========================================

{
  "colors": {
    "primary": "#5B8DEF",
    "primaryDark": "#3562C2",
    "accent": "#FF9F1C",
    "success": "#34C759",
    "error": "#FF3B30",
    "bg": "#0F1115",
    "surface": "#181C22",
    "textPrimary": "#FFFFFF",
    "textSecondary": "#B8C2D1"
  },
  "typography": {
    "fontFamily": "Inter",
    "h1": {"size": 32, "weight": 700, "lineHeight": 38},
    "h2": {"size": 24, "weight": 700, "lineHeight": 30},
    "body": {"size": 16, "weight": 400, "lineHeight": 22},
    "caption": {"size": 13, "weight": 400, "lineHeight": 18}
  },
  "radius": {"s": 8, "m": 12, "l": 16},
  "spacing": {"xs": 4, "s": 8, "m": 12, "l": 16, "xl": 24},
  "elevation": {"card": 8, "sheet": 16}
}


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/UI_Kit/Typography.md
========================================

# Типографика

- Базовый шрифт: **Inter**.
- Заголовки: `H1 32/38 bold`, `H2 24/30 bold`, `H3 20/26 semibold`.
- Текст: `Body 16/22 regular`, `Caption 13/18 regular`.
- Используем `1.2–1.3` line-height для читаемости в темной теме.
- Максимум 2 цвета текста: `textPrimary` и `textSecondary`.


========================================
FILE: ./Backend/LifeMerge_docs/02_Design/UI_Kit/UI_Kit_v1.0.md
========================================

UI Kit v1.0 для проекта LifeMerge
Обязательные компоненты дизайна (Приоритет 1)
Кнопки (Buttons)

Включены три стиля кнопок – Primary (основная), Secondary (второстепенная) и Tertiary (дополнительная). Все кнопки имеют высоту 48pt и скругленные углы с радиусом 10pt, обеспечивая достаточную площадь нажатия (что соответствует минимальному рекомендованному размеру тап-таргета ~48dp
m1.material.io
). Для каждой кнопки проработаны состояния: обычное (default), наведение/нажатие (pressed), неактивное (disabled) и загрузка (loading).

Primary-кнопки используются для ключевых действий и выделяются основным цветом темы; Secondary – для второстепенных действий (может быть с контуром или более мягким цветом), Tertiary – для вспомогательных действий (часто отображаются как текстовые кнопки без заливки). Состояние загрузки оформлено либо встроенным индикатором на кнопке, либо заменой текста на спиннер. Неактивное состояние визуально приглушено (более бледный фон и текст) и не допускает взаимодействия.

Поля ввода (Input Fields)

В UI Kit присутствуют текстовые поля для ввода (например, логин, пароль, поиск и т.п.) с метками (label) и вспомогательным текстом. Все поля оформлены в едином стиле с рамкой или подчеркиванием, обеспечивая достаточный контраст и размер шрифта для читабельности. Предусмотрены различные состояния: дефолтное (пустое поле без фокуса), фокус (focused) – с подсветкой рамки или тени, заполненное (filled) – когда пользователь ввёл данные, состояние ошибки (error) – с красной рамкой и сообщением об ошибке, и неактивное (disabled) – с бледным текстом/рамкой и без возможности ввода. Наличие всех этих состояний соответствует лучшим практикам дизайн-систем: поля ввода являются одними из наиболее распространённых компонентов и должны включать метку, подсказку и визуальную индикацию ошибок
uxpin.com
uxpin.com
.

Например, для состояния ошибки отображается понятный текст ошибки и изменяется цвет рамки на цвет ошибки из палитры.

Карточки (Cards)

Разработаны три вида карточек для разных типов контента: TaskCard, EventCard, FinanceCard. Все карточки имеют скругление углов 12pt и лёгкую тень, чтобы выделяться над фоном. Карточки служат контейнерами для связанной информации и действий по задачам, событиям или финансам. Единый стиль карточек помогает пользователям быстрее сканировать содержимое
uxpin.com
. Каждая карточка содержит заголовок, иконки или превью (если применимо) и краткие детали: например, TaskCard включает название задачи, статус и дедлайн; EventCard – название события, дату/время и место; FinanceCard – сумму, категорию расхода/дохода. При взаимодействии карточки могут слегка подниматься (эффект hover) или изменять тень. Все карточки адаптированы под светлую и тёмную тему (фон и текст автоматически меняют цвет согласно токенам темы).

Чипсы (Chips)

Небольшие метки-фильтры высотой 28pt, используемые для отображения категорий или атрибутов и для фильтрации контента. Чипсы имеют скруглённые углы (радиус примерно 14pt) и содержат короткий текст или иконку с текстом. Реализованы состояния: обычное (default) – нейтральный фон (или обводка) и стандартный цвет текста; выбранное (selected) – фон или обводка подсвечены основным цветом, текст контрастный (например, белый на активном фоне); неактивное (disabled) – элемент бледнее, недоступен для взаимодействия. Чипсы помогают пользователю отмечать выборы или фильтровать элементы и часто используются группами, позволяя множественный выбор.

Верхняя панель (App Bar)

Фиксированная верхняя панель высотой 56pt, содержащая заголовок экрана и иконки действий. App Bar обеспечивает контекст и навигацию на всех основных экранах. Слева обычно располагается иконка навигации (например, “бургер” для меню или стрелка назад для возврата), по центру – заголовок текущего раздела, а справа – одна или две иконки действий (например, поиск, настройки). Высота 56pt соответствует гайдлайнам Material для мобильных приложений, обеспечивая удобство касания элементов. В тёмной теме App Bar меняет цвет фона на более тёмный, а текст/иконки – на светлые, чтобы сохранить контраст.

Нижняя навигация (Bottom Navigation)

Нижняя панель навигации с пятью основными разделами приложения, представленными иконками и подписями. Каждый элемент отображается как иконка (и текст) и имеет состояния: default (не выбран) – обычно монохромная или приглушённая иконка, selected (выбран) – окрашенная основным цветом и (если предусмотрено) сопровождаемая яркой подписью. Bottom Navigation фиксируется внизу экрана, облегчая пользователю переключение между разделами (например, Календарь, Задачи, Финансы, Профиль). Пять пунктов – это максимум для сохранения читаемости и удобства нажатия; каждый пункт имеет достаточную ширину (~минимум 48pt) для комфортного взаимодействия. При выборе раздела может отображаться небольшая анимация или изменение фона под иконкой, сигнализируя о смене текущего раздела.

Индикаторы загрузки (Spinners & Progress)

Для состояний загрузки и ожидания предусмотрены анимированные индикаторы. Используется спиннер (круговой индикатор) для фоновых коротких процессов и прогресс-бар (линейная полоска) для более продолжительных или многошаговых операций. Спиннер оформлен в цвете primary (например, вращающийся кружок основного цвета на прозрачном фоне для светлой темы, и наоборот для тёмной темы). Размер спиннера адаптируется под контекст: маленький – внутри кнопки при её состоянии loading, стандартный (~24pt) – по центру экрана при загрузке контента. Наличие явных индикаторов прогресса важно для обратной связи пользователю
uxpin.com
.

Пользователь видит, что приложение обрабатывает запрос и не зависло. Дополнительно применяются скелетоны – placeholders в виде серых блоков вместо контента, чтобы показать структуру данных во время их загрузки (например, серые прямоугольники вместо карточек списка).

Цветовые токены и темы (Colors)

Определена цветовая палитра с разделением на семантические токены для светлой и тёмной тем. Основные токены включают: primary (брендовый основной цвет – используется для акцентных элементов, кнопок, активных состояний), secondary (дополнительный цвет для акцентов или второстепенных элементов интерфейса), background (основной цвет фона приложения), surface (цвет поверхностей, например, карточек, панелей), error (цвет для состояний ошибок), success и warning (для индикации успешных действий и предупреждений), а также текстовые цвета вроде onPrimary и onSurface (цвет текста/иконок поверх соответствующих фонов).

Для каждого токена задано два значения – для light и dark темы. При переключении темы значения меняются на соответствующие, но имя токена остаётся тем же (это реализовано через дизайн-токены Figma или CSS-переменные). Это позволяет единообразно применять цвета в коде и дизайне: например, токен primary может быть синим в светлой теме и светло-голубым в тёмной для контраста, но в дизайне везде обозначается как color.primary. Такой механизм соответствует современным дизайн-системам: дизайн-токен связывает абстрактное имя цвета с конкретными значениями под каждую тему
atlassian.design
. Палитра подобрана с учётом контрастности (для текста на фоне, иконок на кнопках и т.п.) согласно WCAG.

Типографика (Typography)

Установлены стили текста для заголовков и базового текста, основанные на единой шкале размеров. Предусмотрено 3 уровня заголовков: H1, H2, H3 – от самого крупного к меньшим. Например, H1 используется для самых важных заголовков (размер порядка 32pt, полужирный), H2 – для подпунктов или разделов (около 24pt, полужирный), H3 – для подразделов/секций (около 20pt, полужирный либо обычный). Основной текст имеет два базовых стиля: Body1 (например, 16pt, нормальный вес) – для основного содержания, Body2 (около 14pt) – для вторичного текста. Также задан стиль Caption (~12pt, мелкий шрифт для подписей, дат и т.п.) и стиль Button (для текста кнопок – обычно 14–16pt, полужирный, может быть верхним регистром).

Все текстовые стили определены с указанием шрифта (семейство), начертания, размера, межстрочного интервала и пр. Благодаря этому при разработке используются именно эти значения, а дизайн остаётся цельным. Стили вынесены в отдельные Text Styles в Figma, что ускоряет применение. Определение типографической иерархии в UI Kit гарантирует, что дизайнеры и разработчики говорят “на одном языке” и соблюдается визуальная иерархия текста
productstar.ru
.

Все перечисленные компоненты и стили включены в финальную версию UI Kit 1.0. Это соответствует лучшим практикам: полноценный UI Kit содержит базовые интерактивные элементы (кнопки, поля ввода, переключатели), контейнеры и карточки, навигационные блоки, типографику и цветовую палитру
productstar.ru
productstar.ru
. Компоненты согласованы между собой по стилю, отступам, радиусам скругления, цветовому оформлению и поведению. Благодаря этому единообразию разработчики смогут использовать UI Kit как единый источник правды, а пользователи ощутят целостный и знакомый опыт работы с приложением.

Крайние сценарии (Edge Cases & States)

При разработке дизайна учтены особые состояния интерфейса – ситуации, когда контент отсутствует, произошла ошибка, идёт загрузка или нет подключения. Проработка этих сценариев повышает качество UX и предотвращает замешательство пользователей. Ниже описаны подходы к таким состояниям:

Пустые состояния (Empty States)

Для экранов или разделов, где отсутствуют данные (например, нет задач, нет событий в календаре, результаты поиска пусты), разработаны специальные макеты. Вместо пустого экрана отображается дружелюбное сообщение и иллюстрация/иконка, объясняющие ситуацию и предлагающие следующий шаг. Например, на экране списка задач, если задач нет, выводится сообщение: «У вас пока нет задач. Нажмите +, чтобы добавить первую.» – вместе с условной иконкой (например, чекбокс или папка) в приглушённых тонах. Такое сообщение сразу информирует о состоянии системы и подсказывает пользователю, что делать дальше
nngroup.com
. Без этого пользователь мог бы задуматься: загрузились ли данные, произошла ли ошибка или нужно самостоятельно добавить что-то? Каждый пустой экран выдержан в фирменном стиле (цвета, шрифты) и может содержать CTA – например, кнопку для создания нового элемента прямо из пустого состояния. Таким образом, пустой экран превращается в полезный: информирует и направляет пользователя, вместо того чтобы просто показывать пустое место.

Ошибочные состояния (Error States)

Предусмотрены экраны и всплывающие уведомления для различных ошибок – от ошибок ввода (не пройдена валидация формы) до сбоев загрузки или проблемы с сетью. Каждое сообщение об ошибке сформулировано понятно и содержит инструкцию для пользователя, как действовать (например: «Не удалось загрузить данные. Проверьте подключение и попробуйте снова.»). Визуально ошибки выделяются использованием цвета error из палитры (как правило, ярко-красного) и соответствующей иконкой (например, красный восклицательный знак). Для критических сбоев, которые блокируют работу приложения, спроектирован отдельный экран-заглушка: крупная иконка ошибки, текст пояснения и кнопка действия («Повторить» или «Помощь»). Для локальных ошибок (скажем, не загрузилась отдельная карточка списка) – на её месте может отображаться небольшой серый блок с сообщением об ошибке. В компоненты форм также встроено отображение ошибок: у поля ввода появляется красная рамка и текст-подсказка под ним. Благодаря унифицированному оформлению ошибок пользователь сразу распознаёт проблему и понимает, как её решить.

Состояния загрузки (Loading States)

Когда данные загружаются или выполняется длительная операция, пользователь видит явные индикаторы процесса. Помимо упомянутых выше спиннеров и прогресс-баров, на местах контента используются скелетоны – временные серые блоки, имитирующие структуру страницы. Например, пока список задач не подгрузился, на экране отображаются несколько серых полос вместо текста и круглые заготовки вместо иконок/аватаров. Это лучше, чем просто пустой экран, так как даёт представление о том, что именно загружается (список, карточки и т.д.). Если операция критична и происходит на отдельном экране (например, авторизация), может показываться полноэкранный спиннер или блокирующий индикатор. По завершении загрузки скелетоны исчезают, и появляются реальные данные, либо происходит автоматический переход на другой экран. Таким образом, всегда соблюдается принцип обратной связи: приложение явно показывает, что оно занято, и пользователь понимает, что нужно подождать
nngroup.com
 (избегаем ситуации, когда пустой экран заставляет гадать, идет загрузка или нет).

Офлайн-режим (Offline States)

Приложение распознаёт отсутствие интернет-соединения и уведомляет об этом пользователя. В UI предусмотрен офлайн-баннер – заметная полоса в верхней части экрана (либо всплывающее toast-сообщение), появляющаяся при потере сети. В нём отображается сообщение вроде: «Вы офлайн. Данные могут быть не обновлены.» вместе с иконкой отсутствия сигнала. Такое уведомление появляется сразу, как только соединение пропадает, чтобы пользователь понял, почему новый контент не загружается
web.dev
. Одновременно некоторые действия в офлайн-режиме ограничиваются: например, кнопки, требующие соединения (обновить, отправить форму), могут становиться неактивными, сопровождаясь подсказкой. Если часть функционала доступна офлайн (например, просмотр ранее загруженных данных, создание элементов с отложенной синхронизацией), приложение позволяет продолжать работу и помечает несинхронизированные изменения специальным значком. Как только связь восстановлена, пользователь получает сигнал (исчезновение баннера или уведомление «Соединение восстановлено»), и отложенные действия могут быть автоматически выполнены. Такой подход соответствует рекомендациям по офлайн-UX: чётко информировать о состоянии приложения и доступных действиях при потере связи
web.dev
web.dev
. Пользователь остаётся в курсе событий и не теряет доверия к приложению даже при нестабильном интернете.

Проработка этих крайних сценариев на этапе дизайна предотвращает состояние неопределённости для пользователя. Каждый ключевой экран в макетах имеет вариант под эти случаи (empty/error/loading/offline), и они вынесены на страницу Figma для разработки. Например, присутствует отдельный экран списка задач без задач, экран ошибки сети, офлайн-баннер и т.д. – все они учтены в дизайне и будут реализованы разработчиками.

Wireframes низкой детализации для основных блоков

Для планирования UX-логики проекта подготовлен комплект wireframes (простых схематичных экранов) по основным функциональным блокам: Auth, Calendar, Tasks. Эти наброски отражают структуру экранов и последовательность действий пользователя, без детальной прорисовки UI – что позволяет команде сфокусироваться на функциональности, а не на стиле
interaction-design.org
. Wireframes легко корректировать и обсуждать; они служат основой для последующей детальной дизайна. Ниже перечислены экраны и сценарии, покрытые wireframes, с пояснением их целей:

Блок авторизации (Auth)

Onboarding (онбординг): Серия стартовых экранов, знакомящих пользователя с возможностями приложения при первом запуске. Обычно это 2–3 экрана-слидера с краткими описаниями и иллюстрациями. Цель: вовлечь нового пользователя и кратко показать ценность LifeMerge до регистрации. Wireframe отображает место под изображение/иконку, несколько строк текста-инструкции и кнопку «Далее» (или «Начать»). После онбординга пользователь переходит к регистрации.

Schedule/Graph (настройка графика): Примечание: В ТЗ упомянут «График» в контексте Auth. Предположительно, это экран, где новый пользователь настраивает свой распорядок (например, рабочие часы, предпочтительные часы для задач) либо демонстрация календарного графика. Цель: собрать персональные данные для персонализации (если это часть онбординга) – например, когда удобно планировать задачи. Wireframe показывает интерактивный элемент (календарь или шкалу времени), где пользователь отмечает свой график. Если этот шаг необязателен, предусмотрена кнопка «Пропустить».

Registration (регистрация): Экран создания нового аккаунта с формой ввода (имя, email, пароль и т.п.). Цель: позволить пользователю зарегистрироваться. Wireframe отображает поля ввода, кнопку «Зарегистрироваться» и ссылку «Уже есть аккаунт? Войти». Учтены детали UX: кнопка остается неактивной, пока не заполнены обязательные поля; при ошибке (например, email уже занят) будет показано сообщение ошибки под полем.

Login (вход): Экран входа для существующих пользователей. Содержит поля логина (например, email) и пароля, кнопку «Войти» и ссылку «Забыли пароль?». Цель: предоставить быстрый доступ к аккаунту. Wireframe минималистичен: логотип/название приложения, поля и кнопка – ничего лишнего. Добавлена опция «Keep me signed in» (если требуется).

Password Recovery (восстановление пароля): Процесс сброса пароля. Цель: помочь пользователю восстановить доступ. Wireframe представляет два шага: ввод email/телефона на первом экране и подтверждение на втором. На первом – поле «Email» и кнопка «Восстановить пароль». На втором – сообщение «Мы отправили ссылку для сброса на ваш email» и кнопка «OK». Продуманы нюансы: например, если email не найден, отобразится соответствующая ошибка.

Эти wireframes охватывают полный путь нового пользователя от установки приложения до входа, а также сценарий восстановления. Они показывают, как пользователь переходит от онбординга к регистрации, от регистрации к входу и т.д. Несмотря на простоту (низкая детализация), уже на этом этапе проверена логика: никакой необходимый шаг не упущен, навигация между экранами очевидна (например, из регистрации можно перейти на экран входа и наоборот). Такой подход помогает рано выявить и устранить проблемы в UX потоке.

Блок календаря (Calendar)

Day View (День): Экран календаря для одного дня. Цель: детально показать расписание пользователя на выбранный день. Wireframe отображает верхний бар с датой и, возможно, переключателями просмотра (день/неделя/месяц) или кнопкой «Сегодня». Основная часть – список событий за день, отсортированных по времени. Каждый элемент содержит время, название события (и, возможно, место или пометку). Если событий нет, внизу экрана – иллюстрация и текст пустого состояния («Нет событий»). Предусмотрена кнопка «+» (Floating Action Button) для создания нового события.

Week View (Неделя): Экран календаря на неделю. Цель: дать обзор нагрузки на неделю. Wireframe показывает сетку 7 дней (пн-вс) с краткими отметками событий (например, маленькие блоки или полоски внутри ячеек дней). Верхняя панель – управление (стрелки переключения недель, выпадающий список выбора недели, либо табы для разных видов). Если событий мало, они могут отображаться списком по дням. Этот экран поможет пользователю планировать недельную занятость.

Month View (Месяц): Экран календаря на месяц. Цель: показать долгосрочный план (даты с событиями). Wireframe представляет типичную сетку календаря (5–6 строк недель, 7 столбцов дней). Внутри ячеек дней отмечены события, например, маленькими точками или цветными метками (если много событий, может отображаться число «+3» и т.д.). Выбранный день подсвечивается. Этот экран удобен для выбора конкретной даты – по тапу на день пользователь перейдёт в Day View.

Create Event (Новое событие): Экран создания события. Цель: позволить пользователю добавить новую встречу или напоминание. Wireframe включает форму: поля «Название», «Дата и время» (с кнопкой выбора на календаре/таймпикере), «Место» (с иконкой карты), «Описание» и, возможно, переключатели или список участников. Кнопка «Сохранить» активна, когда заполнено обязательное поле (название). Также показана кнопка «Отмена» для закрытия формы. Все элементы размещены компактно, возможно, экран реализуется как модальное окно поверх календаря.

Event Details (Детали события): Экран просмотра информации о событии. Цель: дать полный контекст по выбранному событию и опции действий. Wireframe показывает заголовок события, дату и время, место (с иконкой местоположения), описание, список участников (с аватарками или инициалами). Внизу – кнопки «Редактировать» и «Удалить событие». Этот экран может вызываться по тапу на событие из календаря. Если событие прошло, оно может быть отображено серым или с пометкой «Прошедшее».

Wireframes календаря охватывают все основные задачи пользователя, связанные с управлением временем: от просмотра расписания (на разных уровнях детализации) до создания и редактирования событий. Они обеспечивают последовательность: пользователь может перейти с Month к Day, создать событие, увидеть его тут же в списке. Навигация и действия проверены: FAB «+» открывает форму, тап на событие – экран деталей, стрелки переключают периоды и т.д. Благодаря низкой детализации, эти схемы были использованы для быстрого UX-тестирования (например, в обсуждениях команды): убедиться, что все понятны и ничего не забыто.

Блок задач (Tasks)

Task List (список задач): Экран со списком всех задач пользователя. Цель: предоставить удобный обзор дел и инструменты фильтрации. Wireframe включает верхнюю панель с заголовком («Задачи» или «Мои задачи») и иконками (поиск, фильтр). Ниже – горизонтальный список фильтров (например, вкладки: «Все», «Сегодня», «Выполненные», «По проектам»), реализуемый как Chip-группа. Основное пространство – перечень задач вертикально. Каждая строка содержит чекбокс (для отметки выполнения), название задачи, возможно, значок приоритета или дедлайн датой. Если задач нет, выводится сообщение пустого состояния. В углу – плавающая кнопка «+» для добавления новой задачи.

Task Detail (детали задачи): Экран подробностей задачи. Цель: показать всю информацию по задаче и дать возможность действий (изменить, отметить выполненной). Wireframe отображает заголовок задачи крупным шрифтом, под ним – переключатель или чекбокс статуса («Выполнена / Не выполнена»). Далее – описание задачи (многострочный текст), информация о дедлайне (иконка календаря и дата), категория/проект (если есть), вложения (иконки файлов). Также может быть блок подзадач, если концепция поддерживает чек-лист внутри задачи. Внизу экрана – кнопки «Редактировать» и «Удалить».

Task Form (форма задачи): Экран создания/редактирования задачи. Цель: позволить пользователю добавить новую задачу или изменить существующую. Wireframe показывает форму с полями: «Название задачи» (текстовое поле), «Описание» (многострочное поле), «Дедлайн» (с выбором даты/времени), «Категория/Проект» (выпадающий список), «Приоритет» (например, выбор P0/P1/P2), возможно «Напоминание» (переключатель). Верхняя панель – заголовок «Новая задача» или «Редактировать задачу» и кнопка «Сохранить». Если редактирование, поля предзаполнены текущими значениями. При валидации – например, если не заполнено название – под полем или всплывающим сообщением будет указано, что оно обязательное.

Wireframes для задач покрывают полный функционал менеджера задач: от обзора всего списка до деталей и создания. Они показывают, как пользователь может фильтровать дела (например, выбрав «Сегодня» увидит только сегодняшние задачи), как может быстро отметить задачу выполненной (чекбокс в списке), как просмотреть подробности (тап по задаче) и отредактировать их. Связи между экранами продуманы: после нажатия «Сохранить» на форме – возвращаемся к списку, обновлённому; при удалении задачи – она убирается из списка и, возможно, показывается snackbar с опцией «Отменить». Поскольку эти схемы были согласованы с командой, все обязательные элементы UI (например, фильтры, кнопка добавления) включены заранее, а не добавляются в последний момент.

Примечание: Все указанные wireframes интегрированы в прототип (например, связаны в Figma), чтобы можно было последовательно пройти пользовательский путь: регистрация → вход → основной экран (например, календарь или задачи), создание элемента, и т.д. Это помогло убедиться, что переходы понятны, а также послужило основой для обсуждения с командой и раннего тестирования. Wireframes намеренно низкой детализации (без цвета, шрифтов, лишь блоки и условные обозначения) – это соответствует практике постепенного повышения fidelity: сначала проработка содержания и логики, потом визуального стиля
interaction-design.org
.

Страница "🌟 Ready for Dev" в Figma

После завершения дизайна подготовлена отдельная страница 🌟 Ready for Dev в файле Figma. На эту страницу скопированы все утверждённые фреймы UI Kit и экранов, описанных выше. Выделение отдельной страницы для финальных макетов – часть процесса hand-off, которая облегчает работу разработчиков
jobs.ataccama.com
. Они могут открыть страницу и сразу увидеть все готовые экраны и компоненты, без черновых версий и лишней информации.

Организация страницы:

Сначала размещён блок UI Kit v1.0 – все приоритетные компоненты и стили. Компоненты сгруппированы по категориям: кнопки (со всеми их состояниями), поля ввода, карточки, чипсы, AppBar, BottomNav, индикаторы, примеры цветовой палитры (светлая/тёмная) и образцы текстовых стилей. Каждый компонент представлен единообразно и подписан. Это позволяет разработчикам легко находить нужный элемент и сверяться с его параметрами (например, размеры кнопки, отступы, цвет текста). Страница фактически служит справочником: UI Kit всегда «под рукой» у команды разработки.

Далее идут фреймы экранов, разбитые на разделы по функциональным блокам: Auth, Calendar, Tasks. Например, в секции Auth находятся фреймы Onboarding_v1, Register_v1, Login_v1, Recovery_v1 (названия условные, но следуют шаблону [Экран]_v1). В секции Calendar – Calendar_Day_v1, Calendar_Week_v1, Calendar_Month_v1, Event_New_v1, Event_Details_v1. В секции Tasks – Task_List_v1, Task_Detail_v1, Task_Form_v1. Такое именование (с суффиксом версии) упрощает отслеживание изменений: если экран потребуется доработать, появится версия v2 на той же странице.

Ключевое свойство – все эти фреймы используют компоненты из UI Kit. То есть кнопки, поля, иконки и прочее вставлены как инстансы готовых компонентов. Благодаря этому дизайн экранов строго соответствует библиотеке компонентов: например, Primary-кнопка на экране регистрации – это экземпляр компонента Primary Button из UI Kit (в Figma). Если в UI Kit обновится стиль (скажем, цвет или радиус), он автоматически обновится на всех экранах. Для разработчиков это сигнал, что дизайн консистентен, и они могут переиспользовать одни и те же ресурсы (кнопки, поля) в коде.

Каждый экран на странице снабжён необходимыми аннотациями. В Figma использованы комментарии и Section descriptions для пояснений. Например, рядом с экранами онбординга может быть примечание «Свайп или кнопка “Далее” переводит на следующий слайд», на экране задачи – «Чекбокс помечает задачу выполненной, при этом она уходит из активного списка». Эти пояснения выделены так, чтобы в режимах Dev Mode Figma их тоже было видно. Они помогают разработчикам понять динамику и интерактивное поведение, которое неявно из статичного макета.

Помимо основных (happy path) экранов, на страницу Ready for Dev добавлены и edge-case экраны: пустые состояния, ошибки, офлайн-баннеры. Они либо расположены рядом с соответствующими основными экранами, либо в отдельной секции «States». Например, рядом с Task_List_v1 находится мини-экран Task_List_Empty_v1 с сообщением «У вас нет задач»; рядом с Calendar_Day_v1 – состояние «нет событий»; вынесен отдельно offline-banner. Благодаря этому разработчики видят все вариации интерфейса в одном месте
jobs.ataccama.com
, и ничего не упустится при реализации.

После финальной проверки дизайна все эти фреймы помечены статусом Figma «Ready for dev» (если используется функциональность статусной маркировки). Это служит явным индикатором, что дизайн зафиксирован для разработки
figma.com
. Дизайнеры воздерживаются от внесения изменений на этой странице без соглашения с командой, чтобы избежать расхождений. Более того, по договорённости, любые новые версии экранов (v2) или альтернативные концепты будут на других страницах (например, «Discovery»), а Ready for Dev остается стабильной и отражает именно то, что должно быть реализовано в текущем спринте/MVP.

Такой подход к организации файла получил положительные отзывы внутри команды: «Если макеты явно отмечены как “готово к разработке” и собраны на одной странице, ориентироваться очень легко». Разработчики точно знают, где смотреть, и уверены, что эти экраны актуальны и утверждены. Это снижает количество вопросов и ошибок на этапе реализации, ускоряет интеграцию (так как компоненты и стили уже систематизированы).

========================================
FILE: ./Backend/LifeMerge_docs/02_Design/UI_Kit/UI Kit & Wireframes figma.md
========================================

LifeMerge UI Kit & Wireframes Implementation

This document summarises the finalised UI Kit v1.0, outlines the key wireframes for the MVP, and lists the screens that are marked as Ready for Development. Since direct editing in Figma is unavailable in this environment, the specifications are provided here for import into your design tool of choice.

UI Kit Components
Buttons

Three button styles are defined: Primary, Secondary and Tertiary. All buttons have a fixed height of 48 pt and rounded corners with a 10 pt radius. States include:

Default – normal background and label colours based on button type.

Pressed – background darkens slightly to indicate active press.

Disabled – lower opacity and muted colours; the button is not interactive.

Loading – shows an inline spinner in place of, or alongside, the label.

Input Fields

Text input fields are sized at 48 pt high and include a label, placeholder, optional icon and helper text. Supported states:

Default – empty field with placeholder text.

Focused – border highlights and the label floats above the input.

Filled – displays the user’s input; label remains above the field.

Error – border changes to the error colour; an error message appears below.

Disabled – muted appearance; the field is read‑only.

Cards

Cards act as containers for related content. They have 12 pt corner radius and a subtle shadow elevation. Three variants exist:

Variant	Use case
TaskCard	Shows task title, due date, priority and status
EventCard	Displays event name, date/time and location
FinanceCard	Contains transaction amount, category and type

Cards may elevate slightly or change shadow on hover or press.

Chips

Chips (tags) are used for categories and filters. They have a height of 28 pt with rounded ends. States include default (neutral border or background), selected (filled with accent colour and contrasting text) and disabled (reduced opacity).

App Bar

The top navigation bar is 56 pt high and contains a title and action icons. It adapts to light and dark themes. The bar may include a back button or menu icon on the left and context‑specific actions on the right.

Bottom Navigation

Bottom navigation consists of five items – Calendar, Tasks, Finance, Inbox and Profile. Each item shows an icon and optional label. States: default (neutral colour) and selected (accent colour and bold label). Icons switch colours in dark mode.

Spinners & Loading Indicators

Use circular spinners for indeterminate processes and skeleton placeholders for loading lists or cards. Where possible, use progress bars to indicate determinate progress. Indicators adopt neutral or primary colours appropriate for the active theme.

Colour Tokens

The palette is defined via tokens to support light and dark themes. Key tokens include:

Token	Description
primary	Main brand colour for highlights
secondary	Secondary accent or supporting colour
background	Page background colour
surface	Surface backgrounds (cards, panels)
error	Colour used for error states
success	Colour used for success messages
warning	Colour used for warnings
onPrimary	Colour of text/icons on a primary surface
onSecondary	Colour of text/icons on secondary surfaces
onBackground	Colour of text/icons on the background
onSurface	Colour of text/icons on a surface

Each token has values for both the light and dark themes to maintain sufficient contrast.

Typography

The type scale defines a clear hierarchy:

Style	Approximate size	Use
H1	32 pt	Main page titles
H2	24 pt	Section titles
H3	20 pt	Subsection headings
Body 1	16 pt	Primary body text
Body 2	14 pt	Secondary text
Caption	12 pt	Annotations and captions
Button	16 pt (bold)	Labels on buttons
Edge Cases & States

Proper handling of edge cases is critical for a polished user experience:

Empty states – when there is no content, show a friendly illustration and a brief message that explains the situation and offers a call‑to‑action to add content.

Error states – use the error colour token to highlight inputs or modules in error; provide clear messages and actions to recover (e.g. a Retry button for network errors).

Loading states – display skeleton placeholders or spinners while data is loading; subtle animations convey that the content is on its way.

Offline states – when connectivity is lost, show a banner or toast informing the user. Disable network‑dependent actions and allow offline functionality where possible. Notify the user once the connection returns.

MVP Wireframes

The following wireframes outline the core screens for the MVP. They are described at a structural level without visual styling so they can be implemented in any design tool.

Auth Screens

Onboarding – a series of slides introducing the value of the app with imagery and short text. Users can navigate forward or skip entirely.

Schedule Setup – an optional step where the user specifies their working pattern or preferred hours to personalise scheduling.

Registration – a form capturing email and password with inline validation and error feedback.

Login – a simple form for returning users to sign in with their credentials; includes an option to stay signed in.

Password Recovery – a two‑step flow to request a password reset via email and to confirm the reset.

Calendar Screens

Day View – detailed schedule for a single day with time slots and events stacked vertically. A floating action button allows creation of a new event.

Week View – a grid of seven columns representing days of the week with events displayed as blocks. Suitable for viewing relative occupancy across the week.

Month View – an overview calendar showing days of the month with subtle markers indicating the presence of events. Selecting a day drills down to the Day View.

Create Event – a form to add a new event: name, date/time picker, location and optional description; includes options for repetition and reminders.

Event Details – displays all information about an event (title, date/time, location, description, participants) and provides actions to edit or delete the event.

Task Screens

Task List – shows all tasks grouped by filters (e.g. by status or priority). Each item has a checkbox to mark it complete.

Task Detail – presents full details of a task: description, due date, context, priority, attachments, and allows editing or deletion.

Task Form – a form for creating or editing tasks; fields include name, description, due date, priority, context and reminder settings.

Ready for Development Screens

The following screens and components have been finalised and are ready to be handed off to engineering. They comply with the UI Kit and meet the Definition of Ready/Done criteria:

Onboarding_v1

Register_v1

Login_v1

Recovery_v1

Calendar_Day_v1

Task_List_v1

Task_Detail_v1

Event_New_v1

Each screen uses components defined in UI Kit v1.0 and accounts for all edge cases and states. These designs align with the MVP scope and can be imported into Figma or another design tool to continue development.

========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/AI/JSON Schema/calendar_min.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/calendar_min.json",
    "title": "CalendarMin",
    "type": "array",
    "items": {
        "type": "object",
        "additionalProperties": false,
        "required": [
            "id",
            "starts_at",
            "ends_at",
            "type",
            "source"
        ],
        "properties": {
            "id": {
                "type": "string",
                "minLength": 1
            },
            "starts_at": {
                "type": "string",
                "format": "date-time"
            },
            "ends_at": {
                "type": "string",
                "format": "date-time"
            },
            "type": {
                "type": "string",
                "enum": [
                    "event",
                    "task_block",
                    "finance_event"
                ]
            },
            "source": {
                "type": "string",
                "enum": [
                    "lifemerge",
                    "google",
                    "apple"
                ]
            },
            "task_id": {
                "type": "string",
                "minLength": 1
            }
        }
    }
}

========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/AI/JSON Schema/goals_min.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/goals_min.json",
    "title": "GoalsMin",
    "type": "array",
    "items": {
        "type": "object",
        "additionalProperties": false,
        "required": [
            "id",
            "title"
        ],
        "properties": {
            "id": {
                "type": "string",
                "minLength": 1
            },
            "title": {
                "type": "string",
                "minLength": 1,
                "maxLength": 128
            }
        }
    }
}

========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/AI/JSON Schema/metadata.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/metadata.json",
    "title": "PlannerMetadata",
    "type": "object",
    "additionalProperties": false,
    "required": [
        "request_id",
        "user_hash",
        "model_version",
        "prompt_version"
    ],
    "properties": {
        "request_id": {
            "type": "string",
            "minLength": 8,
            "maxLength": 128
        },
        "user_hash": {
            "type": "string",
            "minLength": 16,
            "maxLength": 128
        },
        "model_version": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64
        },
        "prompt_version": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64
        },
        "ab_bucket": {
            "type": "string",
            "maxLength": 64
        }
    }
}

========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/AI/JSON Schema/plan_week_request.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/plan_week_request.json",
    "title": "PlanWeekRequest",
    "type": "object",
    "additionalProperties": false,
    "required": [
        "period",
        "tasks",
        "calendar",
        "preferences",
        "goals",
        "metadata"
    ],
    "properties": {
        "period": {
            "type": "object",
            "additionalProperties": false,
            "required": [
                "start_utc",
                "end_utc"
            ],
            "properties": {
                "start_utc": {
                    "type": "string",
                    "format": "date-time"
                },
                "end_utc": {
                    "type": "string",
                    "format": "date-time"
                }
            }
        },
        "tasks": {
            "$ref": "tasks_min.json"
        },
        "calendar": {
            "$ref": "calendar_min.json"
        },
        "preferences": {
            "$ref": "preferences.json"
        },
        "goals": {
            "$ref": "goals_min.json"
        },
        "metadata": {
            "$ref": "metadata.json"
        }
    }
}

========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/AI/JSON Schema/plan_week_response.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/plan_week_response.json",
    "title": "PlanWeekResponse",
    "type": "object",
    "additionalProperties": false,
    "required": [
        "plan",
        "notes",
        "model_version"
    ],
    "properties": {
        "plan": {
            "type": "array",
            "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                    "starts_at",
                    "ends_at",
                    "type"
                ],
                "properties": {
                    "starts_at": {
                        "type": "string",
                        "format": "date-time"
                    },
                    "ends_at": {
                        "type": "string",
                        "format": "date-time"
                    },
                    "type": {
                        "type": "string",
                        "enum": [
                            "task",
                            "rest",
                            "focus"
                        ]
                    },
                    "task_id": {
                        "type": "string",
                        "minLength": 1
                    }
                }
            }
        },
        "notes": {
            "type": "array",
            "items": {
                "type": "string",
                "maxLength": 280
            },
            "maxItems": 32
        },
        "constraints_applied": {
            "type": "array",
            "items": {
                "type": "string",
                "maxLength": 64
            },
            "maxItems": 64
        },
        "model_version": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64
        }
    }
}

========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/AI/JSON Schema/preferences.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/preferences.json",
    "title": "PlannerPreferences",
    "type": "object",
    "additionalProperties": false,
    "required": [
        "timezone",
        "weekend_policy",
        "buffer_minutes_default",
        "focus_windows",
        "forbidden_windows"
    ],
    "properties": {
        "timezone": {
            "type": "string",
            "minLength": 1
        },
        "weekend_policy": {
            "type": "string",
            "enum": [
                "no_tasks",
                "light_only",
                "allow"
            ]
        },
        "buffer_minutes_default": {
            "type": "integer",
            "minimum": 0,
            "maximum": 120
        },
        "focus_windows": {
            "type": "array",
            "items": {
                "$ref": "#/definitions/time_window"
            },
            "maxItems": 28
        },
        "forbidden_windows": {
            "type": "array",
            "items": {
                "$ref": "#/definitions/time_window"
            },
            "maxItems": 56
        }
    },
    "definitions": {
        "time_window": {
            "type": "object",
            "additionalProperties": false,
            "required": [
                "weekday",
                "start",
                "end"
            ],
            "properties": {
                "weekday": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 7
                },
                "start": {
                    "type": "string",
                    "pattern": "^([01]\\d|2[0-3]):[0-5]\\d$"
                },
                "end": {
                    "type": "string",
                    "pattern": "^([01]\\d|2[0-3]):[0-5]\\d$"
                }
            }
        }
    }
}

========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/AI/JSON Schema/tasks_min.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/tasks_min.json",
    "title": "TasksMin",
    "type": "array",
    "items": {
        "type": "object",
        "additionalProperties": false,
        "required": [
            "id",
            "title",
            "priority",
            "estimated_minutes",
            "status"
        ],
        "properties": {
            "id": {
                "type": "string",
                "minLength": 1
            },
            "title": {
                "type": "string",
                "minLength": 1,
                "maxLength": 256
            },
            "priority": {
                "type": "string",
                "enum": [
                    "P0",
                    "P1",
                    "P2"
                ]
            },
            "estimated_minutes": {
                "type": "integer",
                "minimum": 5,
                "maximum": 1440
            },
            "due_at": {
                "type": "string",
                "format": "date-time"
            },
            "goal_id": {
                "type": "string",
                "minLength": 1
            },
            "status": {
                "type": "string",
                "enum": [
                    "open",
                    "done",
                    "canceled"
                ]
            }
        }
    }
}

========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/API/AI_Planner_API.md
========================================

# AI Planner API (v1)

## Общие правила
- Требуется Bearer JWT + заголовки `Accept-Language`, `X-Timezone`; лимит 5 запросов/мин на пользователя.
- Используем `request_id` или `X-Idempotency-Key` для отслеживания повторов, все ответы содержат `model_version`.
- Формат ошибок: `{error: {code, message, details?}}`; при недоступности LLM возвращается `503 ai_unavailable`.
- Поля `user_id` не передаются в LLM; вместо них хэш. Все вызовы проходят через сервис аудита с логированием промптов/ответов (без чувствительных данных).

## POST /v1/ai/plan_week
- Body: `{goals[], tasks[], calendar[], preferences{focus_hours[], sleep, timezone}, request_id}`
- Response: `{plan: [ {day, slots:[{starts_at, ends_at, type(task|focus|rest), task_id?}]} ], notes, model_version}`
- В ответ добавляется `request_id` и `generated_at`; сохраняется в таблицу `ai_plans` вместе с `X-AI-Model` и `X-Prompt-Version`.

## POST /v1/ai/insights
- Body: `{period, metrics, request_id}`
- Response: текстовые выводы и списки рекомендаций.
- Поддерживает параметр `tone` (friendly|neutral|direct) для адаптации копирайта.

## POST /v1/ai/rephrase
- Body: `{text, tone (friendly|formal), request_id}`
- Ответ содержит `variants[]` и оценку токсичности входного текста.

## Безопасность
- Требуется Bearer токен; лимит 5 запросов/мин на пользователя.
- Поля `user_id` не передаются в LLM; вместо них хэш.

## Версионирование
- Заголовок `X-AI-Model` и `X-Prompt-Version` для отслеживания качества; сохраняем в `ai_plans`.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/API/Auth_API.md
========================================

# Auth API (v1)

## Общие правила
- Все ответы используют структуру ошибок `{error: {code, message, details?}}`; успешные ответы содержат `request_id` для трассировки.
- Авторизация по Bearer JWT в `Authorization`, кроме `/signup`, `/login`, `/refresh`, `/forgot`, `/reset`.
- Локализация через `Accept-Language`; часовой пояс клиента передаётся в `X-Timezone` и фиксируется в сессии.
- Для защищённых операций поддерживаются `X-Idempotency-Key` и `request_id` (обязательно для серверного аудита и офлайн-синхронизации).
- Все токены выдаются только по HTTPS; refresh токены привязаны к `device_id` и могут быть отозваны для конкретного устройства или всех устройств.

## POST /v1/auth/signup
- body: `{email, password, full_name?, timezone}`
- result: `{user, access_token, refresh_token}`
- Ограничение по частоте: rate limit на пользователя/IP для предотвращения брутфорса.

## POST /v1/auth/login
- body: `{email, password, device_id}`
- result: `{user, access_token, refresh_token}`
- Ответ включает `created_at`, `updated_at`, `deleted` флаг пользователя для корректного состояния клиента.

## POST /v1/auth/refresh
- body: `{refresh_token, device_id}`
- result: `{access_token}`
- При несовпадении `device_id` возвращаем `401` с кодом `refresh_invalid_device`.

## POST /v1/auth/logout
- headers: `Authorization`
- body: `{all_devices?: boolean}`
- result: `{success: true}`

## POST /v1/auth/forgot
- body: `{email}` → письмо с кодом/ссылкой
- Ответ содержит TTL кода и маскированный email назначения.

## POST /v1/auth/reset
- body: `{email, code, new_password}`
- После успешного сброса старые refresh токены инвалидируются.

Общие правила: rate limit для `/signup` и `/forgot`, ответы содержат `request_id`.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/API/Calendar_API.md
========================================

# Calendar API (v1)

## Общие правила
- Требуется `Authorization: Bearer <token>`, заголовки `Accept-Language` и `X-Timezone` для корректного расчёта повторений и длительности.
- Идемпотентность через `request_id` или `X-Idempotency-Key` для всех операций создания/изменения/удаления.
- Ошибки в формате `{error: {code, message, details?}}`; при конфликте `updated_at` возвращается `409` с актуальным событием.
- Ответы включают `created_at`, `updated_at`, `deleted`, `source` (lifemerge/google/apple) для офлайн-синхронизации и разрешения конфликтов.

## GET /v1/calendar/events
- Query: `from`, `to`, `cursor?`, `limit?`, `sources?` (lifemerge/google/apple)
- Пагинация cursor-based; ответ содержит `next_cursor`.

## POST /v1/calendar/events
- Body: `{title, starts_at, ends_at, location?, recurrence_rule?, task_id?, source?, request_id}`
- При `task_id` создаётся привязка задачи к слоту.
- Принимаются временные зоны в ISO-8601; сервер нормализует к TZ пользователя.

## PATCH /v1/calendar/events/{id}
- Body: `{title?, starts_at?, ends_at?, location?, recurrence_rule?, request_id}`
- Для правок серии допускается `apply_to` (this|future|all) в `details`.

## DELETE /v1/calendar/events/{id}
- Soft delete; body `{request_id}`
- Для повторяющихся событий поддерживается `scope` (this|future|all).

## Синхронизация
- `POST /v1/calendar/import` — подключение внешнего календаря (OAuth token в защищённом хранилище).
- `POST /v1/calendar/webhook/google` — точка для уведомлений; подписки на 60 дней вперёд.
- Все события содержат `updated_at` и `source` для разрешения конфликтов.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/API/Finance_API.md
========================================

# Finance API (v1)

## Общие правила
- Все запросы требуют Bearer JWT, а также заголовки `Accept-Language` и `X-Timezone` для нормализации дат и валютных обозначений.
- Для операций записи используем `request_id` или `X-Idempotency-Key`; ответы содержат `created_at`, `updated_at`, `deleted`.
- Пагинация cursor-based (`cursor`, `limit`); формат ошибок `{error: {code, message, details?}}`.
- Все суммы передаются в минорных единицах (integer) или decimal строго с указанием `currency`.

## Категории
- `GET /v1/finance/categories` — список (с `next_cursor` при пагинации).
- `POST /v1/finance/categories` — `{name, type: income|expense, color?, request_id}`
- `PATCH /v1/finance/categories/{id}` — обновление.

## Транзакции
- `GET /v1/finance/transactions` — фильтры: `from`, `to`, `category_id`, `cursor`, `limit`.
- `POST /v1/finance/transactions` — `{amount, currency, category_id?, happened_at, note?, request_id}`
- `PATCH /v1/finance/transactions/{id}` — любые поля + `request_id`.
- `DELETE /v1/finance/transactions/{id}` — soft delete.

## Бюджеты и отчёты
- `POST /v1/finance/budgets` — `{category_id?, period_start, period_end, limit_amount, currency, request_id}`
- `GET /v1/finance/summary` — агрегаты по периодам, прогноз до конца месяца, перерасход.
- Все отчёты содержат поле `currency` и временные интервалы, нормализованные к TZ пользователя.

Все суммы в API передаются в копейках/центах (integer) либо decimal, согласовано по `currency`.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/API/Goals_API.md
========================================

# Goals API (v1)

## Общие правила
- Все запросы защищены Bearer JWT; заголовки `Accept-Language` и `X-Timezone` обязательны для корректного отображения сроков.
- Изменяющие операции требуют `request_id` или `X-Idempotency-Key` для идемпотентности (офлайн-режим, повторные отправки).
- Пагинация cursor-based: `cursor`, `limit`; ответы возвращают `next_cursor`.
- Ошибки оформляются как `{error: {code, message, details?}}`; при конфликте по `updated_at` возвращается `409`.

## GET /v1/goals
- Query: `status?`, `area?`, `cursor?`, `limit?`
- Ответ дополнительно отдаёт агрегаты по связанным задачам (`tasks_open`, `tasks_done`).

## POST /v1/goals
- Body: `{title, description?, area?, target_date?, request_id}`
- При создании можно передать стартовый `progress` и список связанных `task_ids`.

## PATCH /v1/goals/{id}
- Body: `{title?, description?, area?, target_date?, status?, progress?, request_id}`
- При смене статуса на `completed` фиксируется `completed_at`.

## DELETE /v1/goals/{id}
- Soft delete; body `{request_id}`.
- Удаление каскадно архивирует связанные задачи (статус deferred).

## Метрики и прогресс
- `GET /v1/goals/{id}/progress` — агрегированный прогресс по задачам.
- `POST /v1/goals/{id}/progress` — ручное обновление прогресса `{progress, note?, request_id}`.
- Ответ включает связанные активные задачи (до 5) для виджета «Фокус дня».


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/API/Inbox_API.md
========================================

# Inbox API (v1)

## Общие правила
- Авторизация: `Authorization: Bearer <token>`, поддержка `Accept-Language` и `X-Timezone`.
- Все записи имеют `created_at`, `updated_at`, `deleted`; изменяющие операции требуют `request_id` или `X-Idempotency-Key`.
- Ответы и ошибки следуют формату `{error: {code, message, details?}}` и всегда возвращают `request_id` для трассировки.
- Пагинация cursor-based (`cursor`, `limit`) с `next_cursor` в ответе.

## GET /v1/inbox
- Query: `status?`, `cursor?`, `limit?`
- Возвращает список входящих элементов с метаданными источника (`source`, `payload_type`).

## POST /v1/inbox
- Body: `{source, payload, request_id}` — создание входящего элемента (из виджета/интеграции).
- Для ассистента допускается `context` (текст) для последующей конвертации AI.

## POST /v1/inbox/{id}/convert
- Body: `{type: task|event|note, mapped_fields, request_id}` — конвертация во внутренние сущности.
- В ответе возвращается созданная сущность и обновлённый статус inbox-элемента.

## PATCH /v1/inbox/{id}
- Body: `{status?, payload?, request_id}` (статусы: new, converted, archived).
- При конфликте по `updated_at` возвращается `409`.

## DELETE /v1/inbox/{id}
- Body: `{request_id}`

Ответы содержат `created_at` и `updated_at`, пригодны для офлайн-синхронизации.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/API/OpenAPI.yaml
========================================

openapi: 3.0.3
info:
  title: LifeMerge API
  version: 1.0.0
servers:
  - url: https://api.stage.lifemerge/v1
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  parameters:
    AcceptLanguage:
      in: header
      name: Accept-Language
      schema: { type: string, example: ru-RU }
      required: false
      description: UI локализация, влияет на тексты ошибок и уведомлений
    Timezone:
      in: header
      name: X-Timezone
      schema: { type: string, example: Europe/Moscow }
      required: false
      description: Часовой пояс клиента, используется для дат и повторений
    Cursor:
      in: query
      name: cursor
      schema: { type: string }
      required: false
      description: Токен курсора для пагинации
    Limit:
      in: query
      name: limit
      schema: { type: integer, minimum: 1, maximum: 100, default: 20 }
      required: false
      description: Количество элементов в ответе
  schemas:
    ErrorResponse:
      type: object
      properties:
        error:
          type: object
          properties:
            code: { type: string }
            message: { type: string }
            details: { type: object }
    Task:
      type: object
      properties:
        id: { type: string, format: uuid }
        title: { type: string }
        description: { type: string }
        goal_id: { type: string, format: uuid, nullable: true }
        due_at: { type: string, format: date-time, nullable: true }
        created_at: { type: string, format: date-time }
        updated_at: { type: string, format: date-time }
        deleted: { type: boolean }
    TaskCreate:
      type: object
      required: [title]
      properties:
        title: { type: string }
        description: { type: string }
        goal_id: { type: string, format: uuid }
        due_at: { type: string, format: date-time }
        request_id: { type: string }
paths:
  /auth/login:
    post:
      summary: User login
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - $ref: '#/components/parameters/Timezone'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email: { type: string, format: email }
                password: { type: string }
                device_id: { type: string }
      responses:
        '200':
          description: tokens
        '401':
          description: invalid credentials
          content:
            application/json:
              schema: { $ref: '#/components/schemas/ErrorResponse' }
  /tasks:
    get:
      summary: List tasks
      security:
        - bearerAuth: []
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - $ref: '#/components/parameters/Timezone'
        - in: query
          name: status
          schema: { type: string }
        - in: query
          name: goal_id
          schema: { type: string, format: uuid }
        - in: query
          name: due_from
          schema: { type: string, format: date-time }
        - in: query
          name: due_to
          schema: { type: string, format: date-time }
        - $ref: '#/components/parameters/Cursor'
        - $ref: '#/components/parameters/Limit'
      responses:
        '200':
          description: ok
          content:
            application/json:
              schema:
                type: object
                properties:
                  items:
                    type: array
                    items: { $ref: '#/components/schemas/Task' }
                  next_cursor: { type: string, nullable: true }
        '401':
          description: unauthorized
          content:
            application/json:
              schema: { $ref: '#/components/schemas/ErrorResponse' }
    post:
      summary: Create task
      security:
        - bearerAuth: []
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - $ref: '#/components/parameters/Timezone'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TaskCreate'
      responses:
        '201':
          description: created
          content:
            application/json:
              schema: { $ref: '#/components/schemas/Task' }
        '409':
          description: conflict (duplicate request_id)
          content:
            application/json:
              schema: { $ref: '#/components/schemas/ErrorResponse' }


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/API/Tasks_API.md
========================================

# Tasks API (v1)

## Общие правила
- Требуется `Authorization: Bearer <token>`, `Accept-Language` и `X-Timezone` для корректных дат дедлайнов.
- Для всех изменяющих операций передаётся `request_id` или `X-Idempotency-Key` (гарантия идемпотентности при офлайн-синхронизации).
- Пагинация cursor-based: параметры `cursor`, `limit`; ответы возвращают `next_cursor`.
- Ошибки: `{error: {code, message, details?}}`, например `validation_error`, `not_found`, `conflict` (при обновлении устаревшей версии `updated_at`).

## GET /v1/tasks
- Query: `status?`, `goal_id?`, `due_from?`, `due_to?`, `cursor?`, `limit?`
- Response: список задач + `next_cursor`.
- У каждой записи есть `created_at`, `updated_at`, `deleted` для офлайн-режима.

## POST /v1/tasks
- Body: `{title, description?, goal_id?, due_at?, priority?, estimated_minutes?, energy_level?, request_id}`
- Response: созданная задача.
- При создании можно передать `reminder_at[]` для мгновенной подписки на напоминания.

## PATCH /v1/tasks/{id}
- Body: любые изменяемые поля + `request_id`.
- Конфликты по `updated_at` возвращают `409` с актуальной задачей в `details.current`.

## DELETE /v1/tasks/{id}
- Soft delete. Body: `{request_id}`.
- Удалённые задачи помечаются `deleted=true` и остаются доступными в истории синка.

## Подзадачи
- `POST /v1/tasks/{id}/subtasks` → `{title, request_id}`
- `PATCH /v1/subtasks/{subtask_id}` → `{title?, done?, request_id}`
- Подзадачи наследуют `updated_at` для разрешения конфликтов.

## Напоминания/статусы
- `POST /v1/tasks/{id}/status` → `{status, request_id}` (todo/in_progress/done/deferred)
- `POST /v1/tasks/{id}/reminders` → `{remind_at}`
- Ответы содержат `updated_at` для разрешения конфликтов офлайн-синхронизации.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/Architecture/AI_Architecture.md
========================================

# AI Architecture

## Сервисы
- **AI Planner API:** принимает профиль пользователя, цели, занятость календаря, предпочтения энергии/фокуса, возвращает план недели.
- **Insights:** генерирует текстовые резюме недели/финансов, теги для задач и целей.
- **Safety Layer:** проверка токенов, лимиты на объём текста, фильтрация запрещённого контента.

## Поток планирования
1. Backend собирает контекст (цели, задачи, события, предпочтения) и отправляет в AI сервис.
2. AI сервис вызывает LLM (внешний провайдер), применяет промпт-шаблоны и пост-обработку (нормализация дат, ограничения бюджета времени).
3. Результат сохраняется в БД через backend (`ai_plans` + связанные задачи/события), пользователю показывается diff.

## Технические детали
- Реализация на Python/Node, контейнер; запросы через REST `/v1/plan`, `/v1/summary`.
- Асинхронная обработка через очередь; синхронный ответ только для быстрых подсказок (<3 сек).
- Логирование запросов обезличено (hash user_id), содержимое подсказок хранится в зашифрованном виде.
- Версионирование промптов и моделей (`model_version`, `prompt_version`) для сравнения качества.

## Качество и безопасное использование
- Метрики: время отклика, % успешных планов, % ручных правок пользователем, жалобы на качество.
- A/B: сравнение разных промптов/моделей на когортах stage/prod.
- Fallback: при недоступности LLM — базовый план на шаблонах (распределение задач по приоритету и сроку).


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/Architecture/Backend_Architecture.md
========================================

# Backend Architecture

## Модули
- **Auth:** регистрация, вход, refresh, устройства, роли.
- **Tasks/Goals:** CRUD, подзадачи, напоминания, статусы, прогресс целей.
- **Calendar:** события, повторения, синхронизация с внешними календарями.
- **Finance:** транзакции, категории, бюджеты, отчёты.
- **Inbox:** сбор уведомлений/входящих идей с конвертацией в задачи/события.
- **Notifications:** пуши/почта, расписания триггеров.

## Технологии
- REST API (FastAPI/Express), PostgreSQL, Redis для кеша и сессий, Celery/BullMQ для очередей.
- Авторизация через JWT, rate-limit middleware, OpenAPI спецификация генерируется автоматически.
- Модульная монолитная структура или микросервисы (Auth+Core, AI отдельный) в зависимости от нагрузки.

## Паттерны
- DTO ↔ Domain мапперы, репозитории для БД, сервисы с бизнес-логикой.
- Idempotency для POST/PATCH/DELETE, optimistic locking с `updated_at`.
- Вебхуки для синхронизации календарей, retry с экспоненциальной задержкой.

## Масштабирование
- API горизонтально за балансером; воркеры масштабируются по метрикам очереди.
- Кеширование справочников и публичных настроек; heavy-вычисления в воркерах.
- Фичефлаги для дорогих функций (AI, интеграции) и для миграций данных.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/Architecture/Data_Model/Database_Schema.sql
========================================

-- LifeMerge core schema (PostgreSQL)

CREATE TABLE users (
    id UUID PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    currency CHAR(3) NOT NULL DEFAULT 'USD',
    is_pro BOOLEAN NOT NULL DEFAULT false,
    trial_end TIMESTAMPTZ,
    full_name TEXT,
    timezone TEXT NOT NULL DEFAULT 'UTC',
    role TEXT NOT NULL DEFAULT 'user',
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE goals (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    category TEXT,
    deadline TIMESTAMPTZ,
    progress NUMERIC(5,2) DEFAULT 0,
    status TEXT NOT NULL DEFAULT 'active',
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE tasks (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    goal_id UUID REFERENCES goals(id) ON DELETE SET NULL,
    title TEXT NOT NULL,
    description TEXT,
    context TEXT,
    energy_level TEXT CHECK (energy_level IN ('light','medium','heavy')),
    estimated_minutes INTEGER,
    priority TEXT DEFAULT 'P2' CHECK (priority IN ('P0','P1','P2')),
    deadline TIMESTAMPTZ,
    is_recurring BOOLEAN NOT NULL DEFAULT false,
    recurrence_rule TEXT,
    status TEXT NOT NULL DEFAULT 'open' CHECK (status IN ('open','done','canceled')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted BOOLEAN NOT NULL DEFAULT false
);

CREATE TABLE subtasks (
    id UUID PRIMARY KEY,
    task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    done BOOLEAN NOT NULL DEFAULT false,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE finance_categories (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    type TEXT NOT NULL CHECK (type IN ('income','expense')),
    color TEXT,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE finance_transactions (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    category_id UUID REFERENCES finance_categories(id) ON DELETE SET NULL,
    type TEXT NOT NULL CHECK (type IN ('income','expense')),
    linked_event_id UUID,
    is_recurring BOOLEAN NOT NULL DEFAULT false,
    recurrence_rule TEXT,
    amount NUMERIC(14,2) NOT NULL,
    currency CHAR(3) NOT NULL DEFAULT 'USD',
    happened_at TIMESTAMPTZ NOT NULL,
    transaction_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    note TEXT,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted BOOLEAN NOT NULL DEFAULT false
);

CREATE TABLE calendar_events (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    type TEXT NOT NULL CHECK (type IN ('event','task_block','finance_event')),
    linked_task_id UUID REFERENCES tasks(id) ON DELETE SET NULL,
    linked_finance_id UUID REFERENCES finance_transactions(id) ON DELETE SET NULL,
    title TEXT NOT NULL,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    location TEXT,
    source TEXT DEFAULT 'lifemerge',
    category TEXT,
    recurrence_rule TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted BOOLEAN NOT NULL DEFAULT false
);

CREATE TABLE inbox_items (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    text TEXT,
    type TEXT NOT NULL CHECK (type IN ('idea','task','goal','finance')),
    source TEXT, -- email, widget, integration
    payload JSONB NOT NULL,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active','processed')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE budgets (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    category_id UUID REFERENCES finance_categories(id) ON DELETE SET NULL,
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    limit_amount NUMERIC(14,2) NOT NULL,
    currency CHAR(3) NOT NULL DEFAULT 'USD'
);

CREATE TABLE ai_plans (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    plan_json JSONB NOT NULL,
    prompt_version TEXT,
    model_version TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_tasks_user_deadline ON tasks(user_id, deadline);
CREATE INDEX idx_events_user_start ON calendar_events(user_id, start_time);
CREATE INDEX idx_fin_tx_user_date ON finance_transactions(user_id, happened_at);


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/Architecture/Mobile_Architecture_Flutter.md
========================================

# Mobile Architecture (Flutter)

## Слои
- **Presentation:** `views`, `widgets`, `state` (riverpod/provider), маршруты через `go_router`.
- **Domain:** use-cases (например, `planWeek`, `syncTasks`), модели без зависимостей на Flutter.
- **Data:** репозитории (API + локальное хранилище), мапперы DTO ↔ domain, кеширование.
- **Infrastructure:** HTTP клиент, secure storage, аналитика, пуши.

## Офлайн/онлайн
- Локальная БД `sqflite` содержит задачи, события, транзакции, цели, очереди операций.
- При отсутствии сети операции складываются в `pending_operations` с `request_id`; синк при восстановлении соединения.
- Конфликты: правило «сервер выигрывает», но UI показывает diff и позволяет принять локальную версию.

## Навигация и модули
- Отдельные модули: `auth`, `tasks`, `calendar`, `goals`, `finance`, `inbox`, `settings`.
- Common UI: `lifemerge_theme`, `AppScaffold`, `primary_button`, `sheet_header` из UI Kit.

## Тестирование
- Widget тесты для списков задач, календаря, финансовых графиков.
- Golden тесты для базовых компонентов UI Kit.
- Интеграционные тесты сценариев: онбординг, создание задачи, офлайн-режим.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/Architecture/Offline_Sync_Design.md
========================================

# Offline Sync Design

## Цели
- Позволить создавать/редактировать задачи, события, финоперации без сети.
- Избежать потери данных и дублей при восстановлении соединения.

## Локальные данные
- Храним в `sqflite` таблицы `tasks_local`, `events_local`, `transactions_local`, `pending_operations`.
- Каждая запись содержит `local_id`, `server_id`, `updated_at_local`, `updated_at_server`, `sync_status`.

## Очередь операций
- Формат операции: `{type, entity, payload, request_id, created_at}`.
- Синхронизатор отправляет батчами (до 20 операций) в `/sync/batch` или соответствующие модули.
- В случае конфликта сервер возвращает 409 с актуальной версией; клиент показывает diff.

## Политики конфликта
- **Last Write Wins** по `updated_at`, но если разница >24h, показываем выбор пользователю.
- Удаления помечаются `deleted=true` и синхронизируются как soft delete.

## Дополнительное
- Фоновая синхронизация при смене сети или раз в 15 минут на фоне.
- При logout очищаем локальные таблицы и pending-очередь.
- Журналируем ошибки синка и отправляем в Sentry.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/Architecture/Personalization_ML_Spec.md
========================================

# ML Personalization Module — Input/Output Specification

## Назначение
Модуль персонализации отвечает за подготовку признаков и вызов ML/LLM-модели, которая адаптирует планирование, подсказки и приоритеты под конкретного пользователя. Спецификация фиксирует контракт входных данных и ожидаемых выходов, чтобы бэкенд и AI-сервис были согласованы.

## Общие правила
- Все идентификаторы пользователей и устройств передаются в захешированном виде (`sha256(user_id)`).
- Часовой пояс обязателен, время — в ISO 8601 с таймзоной.
- Денежные суммы указываются в базовой валюте профиля, строки валют — по ISO 4217.
- Пустые поля не отправляются; для необязательных массивов допускается `[]`.

## Входные данные (Input)
JSON-пакет `PersonalizationContext` передается из backend в ML-сервис:

```json
{
  "user_profile": {
    "user_hash": "string",
    "locale": "ru-RU",
    "timezone": "Europe/Moscow",
    "work_pattern": "5/2",
    "focus_hours": [{"start": "09:00", "end": "12:00"}],
    "no_go_periods": [{"weekday": "sun", "reason": "rest"}]
  },
  "behavior": {
    "tasks": [
      {
        "id_hash": "string",
        "title": "string",
        "priority": "P0|P1|P2",
        "context": "home|office|mobile|travel|custom",
        "energy": "light|medium|heavy",
        "estimated_minutes": 45,
        "deadline": "2024-11-20T18:00:00+03:00",
        "status": "open|done|canceled",
        "created_at": "2024-11-10T07:00:00+03:00",
        "completed_at": "2024-11-11T09:20:00+03:00"
      }
    ],
    "events": [
      {
        "id_hash": "string",
        "type": "event|task_block|finance_event",
        "starts_at": "2024-11-14T10:00:00+03:00",
        "ends_at": "2024-11-14T11:00:00+03:00",
        "title": "string",
        "linked_task_id_hash": "string|null"
      }
    ],
    "goals": [
      {
        "id_hash": "string",
        "title": "string",
        "category": "career|health|finance|family|learning|other",
        "deadline": "2025-03-01T00:00:00+03:00",
        "progress": 0.35
      }
    ],
    "finance": {
      "currency": "RUB",
      "regular_cashflow": [{"type": "income|expense", "amount": 75000, "interval": "monthly", "next_date": "2024-12-01"}],
      "last_transactions": [{"amount": -1200, "category": "food", "ts": "2024-11-12T13:00:00+03:00"}]
    },
    "engagement": {
      "session_count_7d": 9,
      "task_completion_rate_7d": 0.62,
      "ai_plan_accept_rate": 0.74,
      "feedback_events": [{"type": "like|dislike", "subject": "ai_plan", "ts": "2024-11-11T10:00:00+03:00"}]
    }
  },
  "constraints": {
    "hard_rules": ["no_heavy_after_20:00", "min_gap_15m"],
    "max_daily_work_minutes": 480
  },
  "request": {
    "request_id": "uuid",
    "model_version": "string",
    "prompt_version": "string",
    "target_horizon": "day|week"
  }
}
```

### Поля и валидация
- `user_profile.work_pattern`: одно из `5/2`, `2/2`, `3/3`, `custom`.
- `behavior.tasks[].priority`: `P0` обязательно имеет `deadline`; `estimated_minutes` > 0.
- `behavior.events[]`: `starts_at < ends_at`; если `type == task_block`, поле `linked_task_id_hash` обязательно.
- `behavior.finance.regular_cashflow[].interval`: `daily|weekly|monthly|yearly`.
- `constraints.hard_rules`: набор строковых токенов, согласованных между backend и AI-сервисом.

## Выходные данные (Output)
Ответ ML-сервиса `PersonalizationResult` возвращается в backend:

```json
{
  "request_id": "uuid",
  "generated_at": "2024-11-13T08:00:00Z",
  "model_version": "string",
  "prompt_version": "string",
  "personalization": {
    "ranked_tasks": [
      {"task_id_hash": "string", "score": 0.87, "reason": "high priority before deadline"}
    ],
    "suggested_slots": [
      {
        "task_id_hash": "string",
        "starts_at": "2024-11-14T09:30:00+03:00",
        "ends_at": "2024-11-14T10:15:00+03:00",
        "confidence": 0.81
      }
    ],
    "nudges": [
      {"type": "habit|focus|finance|energy", "message": "Сделай тяжёлую задачу до 11:00", "priority": "high|medium|low"}
    ],
    "ab_experiment": {"cohort": "B", "features": {"tone": "direct", "slot_length": 45}},
    "profile_updates": {
      "detected_focus_hours": [{"start": "08:30", "end": "11:30"}],
      "preferred_contexts": ["office", "mobile"],
      "anomalies": ["low_completion_3d"]
    }
  },
  "constraints_applied": ["no_heavy_after_20:00", "min_gap_15m"],
  "safety": {"redacted_fields": ["title"], "tokens": 3240}
}
```

### Интерпретация выходов
- `ranked_tasks`: отсортированный список для рекомендаций и авто-планирования; `score` в диапазоне `[0,1]`.
- `suggested_slots`: кандидаты для вставки в календарь; backend валидирует конфликты перед сохранением.
- `nudges`: микро-рекомендации для уведомлений/баннеров; `priority` задаёт канал доставки.
- `ab_experiment`: выбранные параметры для текущего пользователя, чтобы фиксировать в аналитике.
- `profile_updates`: сигналы, которые можно сохранить в `user_settings` после подтверждения бизнес-логикой.
- `constraints_applied`: набор правил, учтённых при генерации, для аудита и дебага.
- `safety`: метаданные о редактировании текста и токенизации.

## Контроль качества
- Обязательные проверки на стороне backend: соответствие `request_id`, допустимость таймслотов, ограничения по рабочему времени и валюте.
- Логирование: сохраняем `request_id`, `model_version`, `prompt_version`, `hashes` сущностей, но не сохраняем исходные тексты задач/заметок.
- Метрики: точность принятия слотов, % выполненных задач из рекомендованных, CTR по `nudges`, доля пользователей с обновлёнными `focus_hours` после 7 дней.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/Architecture/System_Architecture.md
========================================

# System Architecture

## Компоненты
- **Mobile (Flutter):** UI, офлайн-кеш, очередь синхронизации, пуши.
- **Backend API:** Auth, Tasks, Calendar, Goals, Finance, Notifications, Feature Flags.
- **AI Service:** планирование недели, подсказки целей, резюме недели, тональная коррекция писем.
- **Data Layer:** PostgreSQL + Redis (кеш/сессии) + S3-хранилище.
- **Async:** очередь (RabbitMQ/Redis Streams) + воркеры для синхронизаций, AI, интеграций.
- **Monitoring:** Grafana/Prometheus, Sentry, Crashlytics.

## Потоки данных (упрощённо)
1. Пользователь создаёт задачу в приложении → сохраняется локально → синхронизируется на сервер через `/tasks` → фоновые воркеры пушат напоминания.
2. Импорт из Google Calendar: backend-воркер получает вебхук, обновляет события, отправляет пуш об изменениях.
3. AI-планирование: backend формирует контекст (цели, расписание), отправляет в AI сервис, получает расписание и пишет в таблицу `ai_plans` + задачи.

## Нефункциональные аспекты
- Горизонтальное масштабирование API и воркеров, sticky-сессии не требуются (stateless).
- Кеширование справочников и результатов AI на 24 часа.
- Резервное копирование БД ежедневно, тест восстановления еженедельно.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/DevOps/CI_CD_Pipeline.md
========================================

# CI/CD Pipeline

## CI (pull request)
1. Lint/format: `dart format --set-exit-if-changed`, `flutter analyze`, `ruff`/`eslint` для бекенда/AI.
2. Unit/widget tests: `dart test`, `pytest`, `npm test` (если фронт веб).
3. Сборка мобильного клиента в `--debug` для smoke, выгрузка артефактов в CI.
4. Генерация OpenAPI и проверка `scripts/validate_openapi.sh`.

## CD
- **Develop → Dev**: авто-деплой backend/AI через Docker + Helm, прогон миграций, загрузка демоданных.
- **Release candidate → Stage**: ручной триггер, подпись мобильных билдов (internal test), прогон регресса.
- **Prod**: мажорные релизы через change approval, канареечный rollout 10% → 50% → 100% за 24 часа.

## Артефакты
- Контейнеры собираются через BuildKit, публикуются в приватный registry.
- Мобильные `.ipa/.aab` хранятся в артефакт-репозитории с метаданными версии, commit SHA, окружения.

## Качество
- Codecov/coveralls с порогом >70% для ключевых модулей (tasks, calendar, finance).
- SAST/Dependency scan (Trivy/Snyk) обязательны перед stage/prod.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/DevOps/Deployment_Guide.md
========================================

# Deployment Guide

## Подготовка
- Проверить миграции БД и обратную совместимость API.
- Убедиться, что `OpenAPI.yaml` обновлён и прошёл валидацию.
- Настроить переменные окружения (см. Environments.md), обновить secrets в Vault.

## Backend/AI
1. Собрать образы `backend:<tag>` и `ai-service:<tag>`.
2. Применить Helm-чарты: `helm upgrade --install lifemerge-backend charts/backend -f values/<env>.yaml`.
3. Выполнить миграции: `alembic upgrade head` или `prisma migrate deploy` (в зависимости от стека).
4. Проверить readiness/liveness, метрики, отсутствие 5xx в логах.

## Мобильные клиенты
- iOS: `flutter build ipa --flavor <env>`; загрузить в TestFlight/App Store Connect.
- Android: `flutter build appbundle --flavor <env>`; загрузить в Play Console/внешние сторы.
- Проверить совместимость с минимальной поддерживаемой версией, обновить changelog.

## Проверки после релиза
- Smoke-тест: логин, создание задачи/события, синхронизация офлайн → онлайн, операция с финансами.
- Проверить алёрты, дашборды и crash-free; вернуть rollout, если error rate > допустимого порога.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/DevOps/Deployment_Plan.md
========================================

# Deployment Plan — Draft Environment CI/CD

## Цель
Описать, как черновой стенд (Draft) автоматически собирается и разворачивается из CI/CD, чтобы разработчики получали изолированные сборки для раннего тестирования без влияния на Dev/Stage/Prod.

## Триггеры и ветки
- **feature/** и **bugfix/**: авто-сборка и деплой чернового стенда по каждому push в MR/PR.
- **manual re-run**: ручной перезапуск job для восстановления стенда или проверки фиксов.
- **auto-cleanup**: тайм-аут жизни стенда 48 часов; после merge/close MR стенд уничтожается.

## Пайплайн
1. **Lint/Static Analysis**: `flutter analyze`, `dart test --coverage` для клиента; `pytest -q` и `ruff`/`eslint` для backend/AI.
2. **Сборка контейнеров**: BuildKit, теги `draft-<branch>-<sha>` публикуются в приватный registry.
3. **Деплой**: Helm-чарт в namespace `draft-<branch>` с `values/draft.yaml`; включаем mock-провайдеры внешних интеграций.
4. **Миграции**: `alembic upgrade head` / `prisma migrate deploy` против отдельной Draft-БД; обратная совместимость обязательна.
5. **Smoke-тест**: `scripts/smoke_draft.sh` — логин, создание задачи, синхронизация офлайн → онлайн.
6. **Отчёт**: URL стенда и артефакты сборки публикуются в MR/PR комментарии.

## Роллбек и очистка
- Helm rollback на предыдущий релиз (`helm rollback <release> 1`) по детекту 5xx/ошибок readiness.
- После merge/закрытия MR job `cleanup_draft` удаляет namespace, секреты и storage claims.

## Требования к секретам
- Secrets и токены берутся из Vault/KMS по пути `draft/<team>/<service>`; доступ ограничен service account CI.
- В пайплайне используются временные credentials (TTL ≤ 1 час), чтобы уборка не блокировалась утечками ключей.

## Логи и наблюдаемость
- Включен stdout/stackdriver/ELK сбор логов для всех pod в namespace `draft-*`.
- Метрики и алёрты общие с Dev, но с отдельными неймспейс-фильтрами; частота проверок раз в 5 минут.

## Передача в Dev/Stage
- Merge в `develop` переключает пайплайн на Dev по существующим правилам (см. CI_CD_Pipeline.md).
- Принятые фичи получают тег `draft-tested` в release notes, если smoke прошёл на черновом стенде.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/DevOps/Environments.md
========================================

# Environments

| Среда | Назначение | URL/API | Особенности |
|-------|------------|---------|-------------|
| **Dev** | Быстрая разработка | `https://api.dev.lifemerge` | Авто-сборки из `develop`, моковые интеграции, открытые тест-аккаунты |
| **Stage** | Приёмка/QA | `https://api.stage.lifemerge` | Данные приближены к прод, feature flags по умолчанию включены, нагрузочные тесты |
| **Prod** | Пользовательская | `https://api.lifemerge.app` | Полные метрики/алёрты, белые списки IP для админки |

## Управление конфигурацией
- Секреты в Vault/KMS, подключение через переменные окружения.
- Feature flags (Unleash/LaunchDarkly) для AI-функций, офлайна, платёжных интеграций.
- Версии мобильных приложений фиксируются через `min_supported_version` в конфиге backend.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/DevOps/Infrastructure_Spec.md
========================================

# Infrastructure Spec — Draft Environment

## Контур
- **Кластер**: K8s (managed, 3×nodes t3.medium/4vCPU/8GB), отдельный namespace `draft-*` на общем кластере с Dev.
- **Сеть**: ingress с базовой аутентификацией, IP allowlist ограничен офис/VPN; egress через NAT с ограничением к внешним API.
- **БД**: отдельный PostgreSQL instance per-branch (`draft_<branch>`), размер до 10 GB, авто-удаление с retention 2 дня.
- **Файлы**: S3 совместимое хранилище с bucket `lifemerge-draft` и prefix `branches/<branch>/`; lifecycle 7 дней.
- **Кэш/очереди**: Redis c ограничением 256MB per-namespace, RabbitMQ shared vhost `draft`.

## Конфигурация сервисов
- **Backend/AI**: деплой через Helm-чарты `charts/backend` и `charts/ai` с overlays `values/draft.yaml`.
- **Мобильные билд-серверы**: билд-агенты в CI (Linux/macOS runners) с кэшем зависимостей; артефакты в `artifacts/draft/`.
- **Secrets/Config**: `values/secrets-draft.yaml` формируются из Vault; токены интеграций заменяются на моки.

## Наблюдаемость
- Логи: stdout → Loki/ELK с label `env=draft`.
- Метрики: Prometheus scrape `draft-*`; дашборд Grafana “Draft Stand” с SLA: error rate <2%, аптайм 95%.
- Трейсинг: OpenTelemetry с экспортом в Jaeger, сэмплинг 5% для контроля нагрузки.

## Политики безопасности
- RBAC: доступ к namespace только через сервис-аккаунт CI и группу DevOps-readonly.
- Образы проходят проверку Trivy, сигнатуры Notary; pull только из приватного registry через imagePullSecrets.
- NetworkPolicy закрывает межсервисное общение, разрешает только ingress от IngressController и egress к Redis/DB.

## Интеграция с CI/CD
- Pipeline создаёт namespace, секреты и параметры БД динамически, затем применяет `helm upgrade --install`.
- После завершения MR job `cleanup_draft` удаляет namespace, PVC и префикс в S3, освобождая квоты.
- Для экономии ресурсов включена автопауза pod при простое (keda/hpa до 0 реплик) и cron на удаление старых артефактов.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/DevOps/Monitoring_and_Logging.md
========================================

# Monitoring & Logging

## Метрики
- Backend: latency/таймауты по эндпоинтам, ошибки 4xx/5xx, очередь задач, использование БД (CPU, connections, slow queries).
- AI сервис: время ответа, количество токенов, процент fallbacks, очередь job'ов.
- Мобильный клиент: crash-free %, время запуска, FPS на ключевых экранах.

## Логирование
- Формат JSON, обязательные поля: `timestamp`, `level`, `service`, `request_id`, `user_id`, `path`, `latency_ms`.
- PII маскируем; отключаем body для финансовых операций.
- Корреляция через `request_id` между сервисами.

## Алёрты (пример)
- API error rate >5% за 5 минут.
- Latency p95 > 400 мс на `/tasks` или `/calendar`.
- Очередь фоновых задач > 1k сообщений 10 минут.
- Crash-free mobile < 98% за сутки.

## Дашборды
- Grafana/Datadog для сервисных метрик, Sentry для ошибок, Firebase Crashlytics для мобильных.
- Общий продуктовый дашборд: MAU, удержание D1/D7, активность по модулям (календарь, задачи, финансы).


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/Requirements/API_Requirements.md
========================================

# Требования к API

- REST/JSON, префикс `/v1`, консистентные коды ошибок и тело `{error:{code,message,details}}`.
- Авторизация через Bearer JWT, поддержка refresh; все запросы по HTTPS.
- Пагинация cursor-based (`cursor`, `limit`), ответы с `next_cursor`.
- Идемпотентность: `X-Idempotency-Key` или `request_id` для изменяющих операций.
- Все ресурсы содержат `updated_at`, `created_at`, `deleted` (soft delete) для офлайн-синхронизации.
- Локализация через `Accept-Language`, часовой пояс через `X-Timezone`.
- Rate limit по IP и пользователю; отдельные квоты для AI-вызовов.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/Requirements/Functional_Requirements.md
========================================

# Функциональные требования (MVP)

1. **Регистрация/логин/восстановление** по email + пароль; ограничение устройств.
2. **Задачи**: создание/редактирование/удаление, приоритет, дедлайны, подзадачи, напоминания, статусы, офлайн-режим.
3. **Календарь**: события с повторениями, привязка задач к слотам, синхронизация с Google/Apple, просмотр день/неделя/месяц.
4. **Цели**: создание целей, области жизни, прогресс, связь с задачами, краткие отчёты прогресса.
5. **Финансы**: категории доходов/расходов, транзакции, бюджеты, дашборд месяца.
6. **Inbox**: сбор идей/уведомлений, конвертация в задачи/события.
7. **AI**: планирование недели с учётом задач/календаря/предпочтений, текстовые инсайты.
8. **Уведомления**: пуши о задачах/событиях, дневной/недельный дайджест.
9. **Аналитика**: события для Mixpanel/Amplitude (активация, создание задач, удержание).


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/Requirements/NonFunctional_Requirements.md
========================================

# Нефункциональные требования (NFR)

## Производительность
- p95 для основных API (/tasks, /calendar, /finance) ≤ 400 мс на Stage при нагрузке 200 RPS.
- Синхронизация офлайн-очереди < 5 сек для 20 операций.

## Надёжность
- Доступность прод сервисов 99.5% в месяц.
- Автоматические бэкапы БД ежедневно, RPO ≤ 24 часа, RTO ≤ 4 часа.

## Безопасность
- Все соединения по HTTPS, хранение токенов в защищённых хранилищах.
- Шифрование дисков, ротация ключей раз в 90 дней, журнал аудита для действий админов.

## Масштабируемость
- Горизонтальное масштабирование API/воркеров, stateless обработчики.
- Кеширование справочников, очереди для тяжёлых операций (AI, импорт календаря).

## Юзабилити
- Поддержка тёмной темы, шрифты и контраст в соответствии с WCAG AA.
- Время первого запуска приложения < 3 сек на устройствах уровня Pixel 6 / iPhone 12.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/Requirements/Technical_Specification.md
========================================

# Technical Specification (кратко)

- **Платформы:** Flutter iOS/Android, backend REST на FastAPI/Express, AI-сервис отдельный.
- **БД:** PostgreSQL, Redis для кеша и сессий.
- **Фичи MVP:** auth, задачи, календарь, цели, финансы, inbox, AI-планирование недели.
- **Интеграции:** Google/Apple Calendar, FCM/APNs, внешняя LLM API.
- **Офлайн:** локальная БД + очередь операций, конфликты по `updated_at`.
- **Обновления:** OpenAPI.yaml генерируется автоматически, мобильные клиенты через App Store/Play с feature flags.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/Security/Authentication.md
========================================

# Authentication & Authorization

## Флоу входа
1. Пользователь вводит email/пароль → `/auth/login`.
2. Backend возвращает `access_token` (15–30 мин), `refresh_token` (30 дней), `user_profile`.
3. Access хранится в памяти клиента, refresh — в защищённом хранилище (Keychain/Keystore).
4. При истечении access вызываем `/auth/refresh` с `refresh_token`.

## Регистрация и восстановление
- Signup: email + пароль + согласие с политиками; письмо для верификации.
- Восстановление пароля: одноразовый код/ссылка, ограничения по частоте (5 запросов/час).
- Ограничение устройств: по умолчанию до 3 активных refresh-токенов; `logout_all` отзывает остальные.

## Авторизация
- Роли: `user` (по умолчанию), `admin`, `support` (read-only). Проверка ролей в middleware.
- Доступ к объектам проверяем по `user_id` + флагам доступа (для будущего шеринг-модуля).
- Для AI-вызовов добавляем доп. лимиты и контроль объёма входного текста.

## Безопасность токенов
- Формат JWT: `sub`, `role`, `exp`, `iat`, `device_id`.
- Подпись: RS256, приватный ключ в KMS. Ключи ротируются каждые 90 дней, `kid` в заголовке.
- Чёрный список refresh-токенов в Redis/PostgreSQL (`revoked_tokens`).

## Аудит
- Логируем входы/выходы, смену пароля, подозрительные IP/гео, попытки доступа к чужим ресурсам.
- Пользователь может просмотреть последние активные сессии и отозвать их.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/Security/Data_Protection.md
========================================

# Data Protection

## Хранение данных
- **Бэкенд:** PostgreSQL с шифрованием томов (AES-256), резервные копии ежедневно с хранением 30 дней.
- **Файлы:** документы/изображения в S3-совместимом хранилище, шифрование на стороне сервера, приватные bucket.
- **Клиент:** локальная БД шифруется паролем ОС; чувствительные поля (токены, email) — через secure storage.

## Управление персональными данными
- Минимизация: собираем только email, имя, часовой пояс; финданные всегда привязаны к user_id.
- Пользователь может экспортировать JSON/CSV с задачами, целями, транзакциями; удаление аккаунта инициирует очистку в течение 30 дней.
- Логирование PII запрещено; используем маскировку для номеров карт и сумм.

## Передача данных
- Все соединения TLS 1.2+, HSTS, отключены слабые шифры; HTTP → HTTPS редирект.
- WebSockets (позже) только wss:// с проверкой токена на connect/refresh.
- Push-токены передаются только по HTTPS и хранятся отделенно от профилей.

## Соответствие требованиям
- Соответствие GDPR-подобным принципам: согласие, право на удаление, ограничение цели сбора.
- DPIA проводится для AI-функций; данные для обучения анонимизируются.
- Доступ разработчиков к прод-данным только через break-glass процесс с аудитом.


========================================
FILE: ./Backend/LifeMerge_docs/03_Technical/Security/Threat_Model.md
========================================

# Threat Model (LifeMerge)

## Акторы
- **Злоумышленник без учётки:** пытается получить доступ к API, подделать трафик, подменить приложение.
- **Скомпрометированный пользователь:** пытается украсть/подменить данные других пользователей.
- **Внутренний нарушитель:** доступ к логам/базе, попытка извлечь PII и финданные.

## Основные угрозы и меры
1. **Кража токенов доступа**
   - HTTPS везде, `secure`/`HttpOnly` для refresh-cookie в web, для mobile храним в OS Keychain/Keystore.
   - Ротация refresh каждые 30 дней, отзыв токенов при logout/all-devices.
2. **Инъекции и эскалация прав**
   - Parametrized queries/ORM; входные данные валидируются схемами, лимиты длины.
   - RBAC: проверки на уровне handler и сервисов, аудит действий admin/support.
3. **Подмена/утечка данных при синхронизации**
   - Подпись ответов `ETag`, HSTS, защита от downgrade TLS, pinning сертификата в мобильном приложении.
   - Консистентность через `updated_at` и версии записей.
4. **Утечка PII и финансовых данных из логов/бэкапов**
   - Маскирование карт и сумм в логах, шифрование бэкапов и снапшотов, доступ по VPN/KMS.
5. **DDoS и rate abuse**
   - Rate limit per IP/user, капча на signup, отдельные лимиты для дорогих AI-вызовов.
6. **Loss/Corruption данных клиента**
   - Защита локальной БД паролем ОС, шифрование AES-256; периодический бэкап пользовательских настроек в облако (opt-in).

## Остаточные риски
- Социальная инженерия и фишинг вне приложения.
- Утечки на стороне сторонних интеграций (Google/Apple/банки) — минимизируются мониторингом и отзывом токенов.


========================================
FILE: ./Backend/LifeMerge_docs/04_Development/Backlog/Bugs.md
========================================

# Known bugs

| ID | Компонент | Описание | Приоритет | Статус |
|----|-----------|----------|-----------|--------|
| BUG-1 | Calendar sync | Дублируются события при повторном импорте из Google при смене таймзоны | High | In progress |
| BUG-2 | Tasks offline | Изменённые подзадачи не уходят в очередь синхронизации при потере сети | High | To Do |
| BUG-3 | Finance charts | Некорректное округление копеек в диаграмме расходов (на iOS) | Medium | To Do |
| BUG-4 | Notifications | Пуш «Начни день» приходит в 00:00, не учитывается пользовательский часовой пояс | High | In progress |
| BUG-5 | AI Planner | При пустом описании цели возвращается 500 вместо валидационной ошибки | Medium | To Do |


========================================
FILE: ./Backend/LifeMerge_docs/04_Development/Backlog/Features.md
========================================

# Feature backlog

1. **Смарт-планировщик недели (AI Planner v1)**
   - Ввод: цели, приоритеты, доступные слоты календаря.
   - Вывод: предложение расписания + задачи на неделю с учётом энергии/фокуса.
2. **Финансовый дашборд**
   - Визуализации расходов/доходов, бюджеты по категориям, прогноз остатка до конца месяца.
3. **Интеграции с календарями**
   - Импорт событий из Google/Apple, выбор календарей, двусторонняя синхронизация будущих 60 дней.
4. **Виджеты на главный экран**
   - iOS/Android: задачи дня, прогресс цели, баланс бюджета.
5. **Совместная работа (Pro roadmap)**
   - Шеринг задач/проектов с ролями «читатель/редактор», комментарии и упоминания.


========================================
FILE: ./Backend/LifeMerge_docs/04_Development/Backlog/Tech_Debt.md
========================================

# Tech Debt backlog

| ID | Область | Описание | Риск | План фикса |
|----|---------|----------|------|------------|
| TD-1 | Мобильный клиент | Неполное покрытие unit-тестами use-case «планирование недели» | Средний | Добавить тесты на пересчёт расписания и синхронизацию до спринта 3 |
| TD-2 | Backend Tasks | Нет дедубликации idempotency-key для повторных POST задач | Высокий | Ввести уникальный индекс по `request_id` и фоновые задачи для очистки записей | 
| TD-3 | AI сервис | Векторизация описаний целей синхронная, блокирует запрос | Средний | Перевести в очередь Celery/BullMQ, добавить кэш по goal_id |
| TD-4 | DevOps | Отсутствует автоматика ротации ключей JWT/FCM | Высокий | Настроить KMS и cron-ротацию раз в 90 дней |
| TD-5 | Данные | Нет истории изменений задач | Низкий | Добавить audit-таблицу и soft delete в схеме v1.1 |


========================================
FILE: ./Backend/LifeMerge_docs/04_Development/Coding_Standards/API_Usage_Guide.md
========================================

# Руководство по использованию API

## Аутентификация
- Получаем `access_token` и `refresh_token` через `/auth/login` (см. Auth_API.md).
- Добавляем `Authorization: Bearer <token>` к каждому запросу.
- При 401 с причиной `token_expired` вызываем `/auth/refresh`, повторяем оригинальный запрос с тем же `request_id`.

## Общие правила запросов
- **Базовый URL:** определяется окружением (`DEV_API_BASE`, `STAGE_API_BASE`, `PROD_API_BASE`).
- **Версионирование:** используем префикс `/v1/` для всех путей.
- **Идемпотентность:** для POST/PATCH/DELETE передаём `X-Idempotency-Key` или поле `request_id` в body.
- **Пагинация:** `?limit=50&cursor=<ts_or_id>`; получаем `next_cursor` в ответе.
- **Локализация/часовой пояс:** заголовок `X-Timezone` (IANA) и `Accept-Language`.

## Ошибки
- Формат: `{ "error": { "code": "validation_error", "message": "...", "details": {...} } }`.
- Статусы: 400 валидация, 401 auth, 403 permissions, 404 not found, 409 конфликт версии, 429 лимиты, 500/503 сервер.
- Все клиенты логируют `request_id` из ответа или заголовка.

## Практики для мобильного клиента
- Отправлять `app_version`, `platform`, `device_id` в заголовках для аналитики и feature flags.
- Кешировать справочники (категории задач/финансов) с TTL и ETag; при 304 используем локальные данные.
- Объединять небольшие изменения в батчи (например, до 20 событий календаря) для снижения сетевых вызовов.
- Использовать `If-Modified-Since`/`If-None-Match` при загрузке календаря и задач.

## Тестовые данные
- В dev/stage заведены тест-аккаунты `demo_userX@example.com` с предзаполненными задачами, целями и транзакциями.
- Для нагрузочных тестов генерируйте синтетические данные через скрипт `tools/seed_demo_data.py` (backend репозиторий).


========================================
FILE: ./Backend/LifeMerge_docs/04_Development/Coding_Standards/Architecture_Rules.md
========================================

# Архитектурные правила LifeMerge

Документ обобщает договорённости из TECHNICAL SPECIFICATIONS и ТЗ для реализации Flutter-клиента, backend и AI-сервисов.

## Базовые принципы
- **Слойность:** презентация → application/service → domain → infrastructure. Прямых зависимостей от UI к хранилищу нет.
- **Чистые модели:** DTO для сети/БД, domain-модели для логики, мапперы обязательны.
- **Idempotency & retries:** все mutating-эндпоинты backend принимают `request_id` для безопасных повторов.
- **Трассировка:** каждый запрос несёт `X-Request-Id`; логируем путь, пользователя, время, статус.

## Интеграции
- **AI-сервис:** отдельный REST, вызывается backend-воркерами. UI не ходит к AI напрямую.
- **Платёжки/FCM/APNs:** обёрнуты адаптерами; конфиги через переменные окружения.

## Данные и офлайн
- **Единый источник истины:** серверная БД PostgreSQL. Клиент хранит кеш (sqflite) + очередь синхронизации.
- **Версионирование схемы:** миграции через `migration_version`; несовместимые изменения только по фичефлагу.
- **Конфликты:** правило «последний апдейт выигрывает» с сохранением истории изменений для задач/событий.

## Безопасность
- JWT access (15–30 мин) + refresh; все сервисы ходят только по HTTPS.
- Роли: user, admin, support; проверка авторизации на уровне handler + сервис.
- PII и финансовые суммы логируются только в хэшированном/маскированном виде.

## Производительность
- Пагинация по cursor/`updated_at`, лимит 50 записей по умолчанию.
- Индексы по `(user_id, due_date)`, `(user_id, status)` для задач, `(user_id, date)` для транзакций.
- Критичные запросы тестируются на 95‑перцентиль не более 200 мс в stage-среде.


========================================
FILE: ./Backend/LifeMerge_docs/04_Development/Coding_Standards/Dart_Style_Guide.md
========================================

# Dart Style Guide (LifeMerge)

- Следуем официальному `dart style`; используем `dart format` без переопределения ширины строки.
- Именование: классы/enum в `PascalCase`, методы/поля/переменные в `camelCase`, константы в `lowerCamel` с `k` не используем.
- Публичные API должны иметь `///` документацию с примерами использования.
- Избегаем `dynamic` и `!`; используем null-safety, опциональные поля помечаем `?`.
- Коллекции неизменяемые по умолчанию (`UnmodifiableListView`, `const` widgets) когда это безопасно.
- Обработка ошибок через `Either<Result, Failure>` или `Result<T>` вместо выбрасывания исключений в бизнес-логике.
- Импортируем через `package:lifemerge/...`; относительные импорты только внутри модуля.
- Файлы экранов/виджетов именуем по компоненту: `tasks_list_page.dart`, `task_tile.dart`, `goal_progress_chart.dart`.
- Не добавляем `try/catch` вокруг импортов; используется автоматический анализ зависимостей pub.


========================================
FILE: ./Backend/LifeMerge_docs/04_Development/Coding_Standards/Flutter_Best_Practices.md
========================================

# Flutter: лучшие практики

## Архитектура клиента
- Используем **MVVM + Provider/riverpod** для управления состоянием экранов.
- Навигация через `go_router`; маршруты описываем декларативно, учитывая deeplink из пушей.
- Разделяем слой данных (`repositories`), домена (`use_cases`), UI (`views/widgets`).

## Работа с сетью
- HTTP-клиент оборачиваем в `ApiClient` с перехватчиками для токенов и логов.
- Повтор запросов с backoff для сетевых ошибок, но не более 3 попыток.
- Сериализация через `json_serializable`, время передаём в ISO8601 + timezone.

## UI и доступность
- Используем дизайн-токены из `UI_Kit/Design_Tokens.json` и кастомные `ThemeExtension`.
- Минимальный размер тапа 44×44, контраст текста WCAG AA.
- Все иконки и тексты должны поддерживать тёмную тему; тестируем на эмуляторах iOS/Android.

## Офлайн
- Локальное хранилище `sqflite` + `hive` для быстрых настроек.
- Очередь синхронизации хранит pending-операции; при восстановлении сети выполняем батчами.
- Конфликты показываем пользователю (баннер) с выбором варианта или автопринятием сервера.

## Качество
- Unit-тесты для `use_cases` и мапперов, widget-тесты для ключевых экранов (календарь, задачи, финансы).
- Включаем `flutter analyze`, `dart format`, `dart test` в pre-push hook.
- Производительность проверяем `profile`-сборкой: время фрейма < 16 мс на целевых девайсах Pixel 6 / iPhone 12.


========================================
FILE: ./Backend/LifeMerge_docs/04_Development/Sprint_Planning/Template_Sprint_Plan.md
========================================

# Sprint {{номер}} – Planning

## 1. Sprint Goals
- Цель 1  
- Цель 2  

---

## 2. Sprint Backlog
| ID | User Story | Задача | Story Points | Ответственный |
|----|------------|--------|--------------|----------------|

---

## 3. Capacity
| Член команды | Доступные часы | Комментарий |
|--------------|----------------|--------------|

---

## 4. Risks
- Риск 1  
- Риск 2  

---

## 5. Definition of Done (DoD)
| Компонент | Критерий |
|-----------|----------|

---

## 6. Retro Notes (по окончании)
- Что получилось  
- Что не получилось  
- Что улучшить  


========================================
FILE: ./Backend/LifeMerge_docs/05_QA/Automation/CI_Test_Config.md
========================================

# CI Test Config

- Запуск `dart test` и `flutter test --tags=smoke` на каждом PR.
- Backend/AI: `pytest -q`, `npm test` (если Node), покрытие >70% для ядра.
- Lint: `dart format --set-exit-if-changed`, `flutter analyze`, `ruff`, `eslint`.
- Интеграционные тесты (эмуляторы) ночью по расписанию: онбординг, создание задачи, синк офлайн → онлайн.
- Отчёты в CI: JUnit + coverage, отправка в Codecov; уведомления в Slack/Telegram при падениях.


========================================
FILE: ./Backend/LifeMerge_docs/05_QA/Checklists/Regression_Checklist.md
========================================

# Regression Checklist (основные блоки)

## Аутентификация
- [ ] Signup/login/logout/refresh, восстановление пароля.

## Задачи/Цели
- [ ] CRUD задач и подзадач, напоминания, статусы.
- [ ] Фильтры/сортировки, поиск.
- [ ] Связка задач с целями, обновление прогресса целей.

## Календарь
- [ ] Создание/редактирование/удаление событий, повторения.
- [ ] Синхронизация с внешними календарями, обработка вебхуков.

## Финансы
- [ ] CRUD категорий и транзакций, бюджеты.
- [ ] Корректные валюты и округление.

## Inbox/Уведомления
- [ ] Добавление элементов inbox, конвертация в задачи/события.
- [ ] Получение пушей и настройка времени отправки.

## Офлайн/Синхронизация
- [ ] Рабочие сценарии офлайн → онлайн, отсутствие дублей.

## AI
- [ ] План недели создаётся, корректно создаёт задачи/события.
- [ ] Ограничения по лимитам/ошибкам отображаются корректно.


========================================
FILE: ./Backend/LifeMerge_docs/05_QA/Checklists/Release_Checklist.md
========================================

# Release Checklist

- [ ] Все задачи релиза в статусе Done, нет блокеров.
- [ ] Пройдены Smoke и Regression (см. отдельные чеклисты).
- [ ] Билды подписаны и загружены в TestFlight/Play Console.
- [ ] Миграции БД применены на stage и проверены.
- [ ] Алёрты/дашборды сконфигурированы для версии.
- [ ] Обновлены маркетинговые тексты и privacy policy.
- [ ] План отката согласован, проверено восстановление из бэкапа.


========================================
FILE: ./Backend/LifeMerge_docs/05_QA/Checklists/Smoke_Test_Checklist.md
========================================

# Smoke Test Checklist

- [ ] Установка/запуск приложения (iOS/Android).
- [ ] Регистрация нового пользователя и логин существующего.
- [ ] Создание задачи, изменение статуса, удаление.
- [ ] Создание события календаря, привязка задачи, просмотр расписания.
- [ ] Добавление цели, связка задач с целью.
- [ ] Добавление расхода/дохода, просмотр дашборда.
- [ ] Получение пуша-напоминания.


========================================
FILE: ./Backend/LifeMerge_docs/05_QA/QA_Plan.md
========================================

# 🧪 QA PLAN — LifeMerge (MVP, Pro 1.0+ Ready)

## 1. Цели QA

1. Обеспечить стабильную работу **ядра продукта**:

   * календарь,
   * задачи/цели,
   * финансы,
   * GTD Inbox,
   * AI-планировщик,
   * подписки и уведомления.
2. Минимизировать риск **потери/порчи данных** (особенно задач, целей, финансов).
3. Подтвердить, что:

   * UX соответствует дизайну,
   * логика Free/Pro соблюдается,
   * AI **не нарушает** пользовательские правила.
4. Обеспечить предсказуемое качество на каждом релизе (регрессия).

---

## 2. Область охвата (Scope)

### Входит:

* Мобильные приложения: iOS + Android.
* Все ключевые модули:

  * Регистрация/логин.
  * Календарь + рабочие графики.
  * Задачи/цели/проектная структура.
  * Финансы (доходы/расходы/регулярные).
  * Inbox (GTD).
  * AI-планировщик (Pro).
  * Уведомления.
  * Подписки/Trial.
  * Настройки (тема, уведомления, график, язык RU).
* Offline-режим (кэш + отложенная синхронизация).

### Не входит (на этап MVP, но отмечается как future):

* Web-версия.
* Полноценный конфликт-менеджмент при синхронизации.
* Сложная интеграция банков/HealthKit/Google Fit.
* Полностью автономный режим AI.

---

## 3. Типы тестирования

1. **Unit-тесты**

   * Бизнес-логика (use cases).
   * Парсинг/сериализация данных.
   * Локальные валидаторы.

2. **Integration tests**

   * Клиент ↔️ backend (через staging API).
   * Работа offline-очереди.
   * AI-запросы и обработка ответов.

3. **UI/UX (manual + automated)**

   * Отображение экранов.
   * Навигация.
   * Состояния (loading / empty / error).

4. **End-to-End (E2E)**

   * Жизненные сценарии:

     * создание цели → задач → расписание → финансы → AI-план → отчёт.

5. **Регрессионное тестирование**

   * Перед каждым релизом.

6. **Non-functional**

   * Производительность (basic).
   * Устойчивость (long-run).
   * Usability (ручное, по чек-листам).

7. **Security & Privacy (базовый уровень)**

   * Валидация auth-флоу.
   * Нет утечек чувствительных данных в логах.

---

## 4. Стратегия по уровням

### 4.1. Unit-тесты

**Цель:** поймать ошибки логики до UI/интеграции.

Покрыть:

* расчёт прогресса по целям,
* вычисление баланса бюджета,
* генерация временных интервалов в календаре,
* обработку настроек рабочего графика,
* базовую подготовку данных для AI-запроса.

**Критерий:**
для MVP — покрытие ключевых use-case модулей ≥ 70%.

---

### 4.2. Integration tests

Проверяем:

* корректность API-контрактов:

  * Auth,
  * Tasks,
  * Calendar,
  * Finance,
  * AI.
* работу локального кэша + синка:

  * создаём задачу offline → получаем её на другом устройстве после sync.

---

### 4.3. UI/UX тестирование

* Проверяем макеты Figma vs. реализация:

  * сетка,
  * типографика,
  * отступы,
  * состояния.
* Особо:

  * Тёмная тема.
  * Пустые состояния (нет задач, нет операций).
  * Ошибки (нет сети, ошибка AI, backend down).

---

### 4.4. E2E сценарии (основные)

**Сценарий 1: «Новый пользователь Free»**

1. Установка → онбординг.
2. Регистрация аккаунта.
3. Настройка рабочего графика.
4. Создание пары задач и цели.
5. Добавление финансовых записей.
6. Проверка календаря и пушей.

**Сценарий 2: «Pro с AI-планировщиком»**

1. Активация Trial (с тестовой картой).
2. Создание набора задач с приоритетами, дедлайнами, контекстами.
3. Запуск AI-планировщика на неделю.
4. Проверка:

   * AI не залез в запретные зоны (вечер, выходные, non-working).
   * расписание выглядит логично.
5. Принятие плана.
6. Проверка, что план реально применился в календаре.

**Сценарий 3: «Finance + Calendar»**

1. Добавить зарплату (регулярный доход).
2. Добавить несколько расходов (с и без привязки к событиям).
3. Привязать расход к событию в календаре (поход в кафе).
4. Проверить месячный отчёт.

**Сценарий 4: «Inbox → действие»**

1. Набросать 5–10 элементов в Inbox.
2. Превратить часть в задачи, часть в цели, часть в финансовые события.
3. Проверить, что всё корректно отобразилось в соответствующих разделах.

---

## 5. Test Matrix (что тестируется особенно тщательно)

### Модули и приоритет:

| Модуль         | Приоритет         | Уровень тестирования         |
| -------------- | ----------------- | ---------------------------- |
| Auth           | Высокий           | Unit, Integration, E2E       |
| Календарь      | Критический       | Unit, Integration, UI, E2E   |
| Задачи/цели    | Критический       | Unit, Integration, UI, E2E   |
| Финансы        | Высокий           | Unit, Integration, E2E       |
| Inbox          | Средний           | Integration, UI, E2E         |
| AI-планировщик | Критический (Pro) | Integration, E2E, спец-тесты |
| Подписки/Trial | Высокий           | Integration, E2E             |
| Уведомления    | Высокий           | Integration, device tests    |
| Настройки      | Средний           | UI, Integration              |
| Offline/sync   | Высокий           | Integration, E2E             |

---

## 6. Подход к AI-тестированию

### Особенность: AI ≠ детерминированный код.

### Что тестируем:

1. **Формат запроса/ответа**

   * структуру JSON,
   * обработку ошибок,
   * timeout.

2. **Соблюдение жёстких правил**

   * тест-кейсы:

     * Пользователь запрещает вечерние слоты → AI **не ставит** туда задачи.
     * Пользователь указывает выходной день → AI не планирует там работу.
     * Минимальный буфер между задачами → слоты не слепляются.

3. **Граничные кейсы**

   * очень много задач (AI должен часть оставить «unscheduled», а не ломать расписание),
   * очень мало свободного времени.

4. **UX-поведение**

   * если AI вернул пустой/ошибочный ответ:

     * показывается дефолтное сообщение,
     * приложение не крашится,
     * пользователь может продолжать вручную.

---

## 7. Стратегия по платформам и девайсам

### 7.1. iOS

* Минимальная версия: iOS 14
* Тестовые девайсы:

  * iPhone SE (малый экран),
  * iPhone 13/14 (основной),
  * желательно одно «старое» устройство.

### 7.2. Android

* Минимальная версия: Android 8 (API 26)
* Тестовые девайсы:

  * бюджетный (низкая мощность),
  * средний,
  * флагман (высокая частота, разные dpi).

Обязательно проверять:

* акцентные элементы (цвета/тексты) на разных DPI,
* корректность темы,
* пуши при закрытом приложении.

---

## 8. Test Environments

1. **Dev environment**

   * нестабильный,
   * использует dev-ветку,
   * данные могут очищаться.

2. **Staging environment**

   * максимально близок к продакшену:

     * та же схема БД,
     * тот же набор сервисов.
   * используется для:

     * интеграционных и E2E тестов,
     * regression перед релизом.

3. **Production**

   * только мониторинг, hotfix-проверки.

---

## 9. Test Artifacts

1. **Test Cases**

   * подробные шаги и expected results,
   * покрывают все User Stories.

2. **Checklists**

   * быстрые проверки перед релизом (smoke + sanity).

3. **Bug reports**

   * оформляются в системе тикетов (Jira/YouTrack):

     * шаги,
     * фактический результат,
     * ожидаемый результат,
     * severity (Critical/Major/Minor),
     * скриншоты/видео.

4. **Test Summary Reports**

   * после каждого спринта/релиза:

     * что тестировалось,
     * сколько тест-кейсов прошло/провалилось,
     * какие критические баги остались/исправлены.

---

## 10. Критерии начала тестирования (Entry Criteria)

* Feature/branch собран в **staging-билд**.
* Пройдены unit-тесты.
* Есть:

  * актуальные макеты,
  * описание бизнес-логики,
  * настройки тестовых аккаунтов (Free, Pro, Trial).
* Backend для нужного функционала развёрнут и доступен.

---

## 11. Критерии завершения тестирования (Exit Criteria)

* Все **критические** баги исправлены.
* **Major** — либо исправлены, либо согласованы и вынесены в backlog с пометкой.
* Регрессионные тесты пройдены по ключевым флоу:

  * логин,
  * календарь,
  * задачи,
  * финансы,
  * AI-планировщик,
  * подписки.
* Test Summary Report подготовлен и одобрен.

---

## 12. Риски и как их снижать

1. **AI непредсказуем в редких кейсах**

   * Решение:

     * жёсткие hard constraints,
     * fallback, UI-предупреждения.

2. **Разночтения между mobile и backend API**

   * Решение:

     * контрактные тесты,
     * Postman collection / OpenAPI.

3. **Баги в оффлайн-сценариях**

   * Решение:

     * отдельные E2E кейсы для offline → online,
     * тесты с выключением сети во время операций.



========================================
FILE: ./Backend/LifeMerge_docs/06_Release/AppStore/Description.md
========================================

# App Store / Google Play Description (draft)

**LifeMerge — единое приложение для времени, целей и финансов.**

- Планируйте день и неделю в одном календаре.
- Управляйте задачами и целями, отслеживайте прогресс.
- Ведите расходы и бюджеты, получайте финансовые инсайты.
- AI-помощник предложит расписание и подскажет приоритеты.
- Работает офлайн, синхронизируется между устройствами.

**Почему LifeMerge?**
- Всё в одном: календарь, задачи, цели, финансы.
- Лёгкий старт: готовые шаблоны и умные подсказки.
- Для людей из СНГ: локализация, рубли/тенге/гривны, напоминания в нужном часовом поясе.

Поддержка: support@lifemerge.app


========================================
FILE: ./Backend/LifeMerge_docs/06_Release/AppStore/Privacy_Policy.md
========================================

# Privacy Policy (кратко)

- Мы собираем: email, имя, часовой пояс, данные задач/целей/финансов, технические метаданные устройства.
- Используем: для оказания сервиса, персонализации, аналитики (Mixpanel/Amplitude), отправки уведомлений.
- Не продаём данные третьим лицам; передача только обработчикам (хостинг, аналитика) по договорам.
- Данные хранятся на защищённых серверах, резервируются; пользователи могут запросить выгрузку или удаление аккаунта.
- Cookies/токены применяются для аутентификации и сессий; пуш-токены хранятся отдельно.
- Контакты: privacy@lifemerge.app


========================================
FILE: ./Backend/LifeMerge_docs/06_Release/Beta_Testing/Beta_Feedback.md
========================================

# Beta Feedback Process

## Сбор
- Форма Google/Typeform: NPS, удовлетворённость по модулям (календарь, задачи, финансы, AI), багрепорты.
- Встроенная кнопку «Сообщить об ошибке» (отправляет логи + скрин по согласию).
- Телеграм-чат с быстрыми опросами.

## Обработка
- Все фидбеки заносятся в борд: тип (bug/UX/feature), приоритет, модуль, воспроизводимость.
- Критичные баги → горячие фиксы до следующего билда; улучшения — в backlog.
- Еженедельный дайджест по метрикам: activation, crash-free, time to first value.

## Ответ пользователям
- Благодарность и статус: принято/в работе/отклонено.
- Релиз-ноты тестовых сборок с закрытыми пунктами.


========================================
FILE: ./Backend/LifeMerge_docs/06_Release/Beta_Testing/Invitations.md
========================================

# Beta Testing Invitations

## Кого зовём
- Ранние пользователи из целевой аудитории (25–40, СНГ), существующие клиенты productivity-сообщества.
- Команда/партнёры, сотрудники компании.

## Каналы
- Email-рассылка по списку ожидания.
- Телеграм-канал/чат с инструкциями и обратной связью.
- App Store TestFlight и закрытый трек Google Play.

## Сообщение-приглашение (шаблон)
```
Привет! Запускаем бету LifeMerge — планировщик времени, целей и финансов.
1) Установи приложение по ссылке <TestFlight/Google Play>.
2) Пройди онбординг и создай минимум 3 задачи и 1 цель.
3) Поделись фидбеком в форме: <ссылка>.
Спасибо! Команда LifeMerge
```


========================================
FILE: ./Backend/LifeMerge_docs/06_Release/Release_Plan.md
========================================

# Release Plan

## Milestones
1. **Beta (Internal)** — сбор фидбека, crash-free >95%, основные баги закрыты.
2. **Release Candidate (Stage)** — подключены платёжные/календари, регрессия пройдена.
3. **Prod Launch** — rollout 10→50→100%, мониторинг метрик, поддержка 24/7 первые 72 часа.

## Чеклист перед выкладкой
- Пройдены Smoke/Regression чек-листы (см. QA/Checklists).
- Миграции БД применены и протестированы на stage.
- Обновлены маркетинговые материалы (App Store/Google Play), privacy policy.
- Настроены алёрты и дашборды.

## Пост-релиз
- Мониторинг error rate, p95, crash-free; план обратного отката.
- Сбор фидбека от первых пользователей, быстрые фиксы.


========================================
FILE: ./Backend/README.md
========================================

# LifeMerge Backend Skeleton (Sprint 01)

Skeleton backend for MVP Sprint 01: Auth + Tasks.

## What is included
- FastAPI + autogenerated OpenAPI (Swagger)
- PostgreSQL (Docker)
- JWT auth (access + refresh) with refresh token rotation and device binding
- Middleware:
  - `X-Request-Id` propagation (generated if absent)
  - `X-Timezone` validation (IANA, falls back to UTC)
- Idempotency guard for write endpoints: require `request_id` in body OR `X-Idempotency-Key` header
- Soft delete + `updated_at` optimistic locking (409 on conflicts)

## Run (staging-like, locally)
Prerequisites: Docker + Docker Compose.

```bash
cd lifemerge-backend-skeleton
cp .env.example .env
# set a strong JWT_SECRET_KEY in .env
docker compose up --build
```

### Swagger
- Swagger UI: `http://localhost:8000/v1/docs`
- OpenAPI JSON: `http://localhost:8000/v1/openapi.json`

## Implemented endpoints
### Auth
- `POST /v1/auth/signup`
- `POST /v1/auth/login`
- `POST /v1/auth/refresh`
- `POST /v1/auth/forgot` (stub)
- `POST /v1/auth/reset` (stub)
- `POST /v1/auth/logout`

### Tasks
- `GET /v1/tasks` (cursor-based pagination)
- `POST /v1/tasks`
- `PATCH /v1/tasks/{id}`
- `DELETE /v1/tasks/{id}`

## Notes
- Tables are auto-created on startup for skeleton usage. Production should use Alembic migrations.
- Forgot/Reset are stubs by design in Sprint 01.


========================================
FILE: ./Backend/requirements.txt
========================================

fastapi==0.115.6
uvicorn[standard]==0.34.0
SQLAlchemy[asyncio]==2.0.36
asyncpg==0.30.0
alembic==1.14.0
pydantic==2.10.4
pydantic-settings==2.7.0
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.20
email-validator==2.2.0
structlog==24.4.0


========================================
FILE: ./debug_skipped_files.log
========================================

=== DEBUG: SKIPPED FILES ===
Started: 2025-12-15T22:42:21+04:00



========================================
FILE: ./Docs/Detailed Project Plan.md
========================================

# 📆 **DETAILED PROJECT PLAN — LifeMerge**

## Формат:

**Этапы → Подэтапы → Задачи → Команда → Артефакты → Критерии завершения.**

---

# 🟦 **0. Подготовительный этап (Pre-Production)**

**Длительность: 2–3 недели**

## 0.1. Формирование команды

**Задачи:**

* Найм/подтверждение:

  * Product Manager
  * Tech Lead (Flutter)
  * Backend Lead
  * 1–2 Flutter dev
  * 1 Backend dev
  * 1 UI/UX дизайнер
  * 1 QA инженер

**Артефакты:** Team roster

---

## 0.2. Финализация концепции

**Задачи:**

* Завершить Product Vision
* Финализировать MVP Scope
* Утвердить Roadmap
* Уточнить ограничения платформ (App Store, RuStore)

**Артефакты:**

* Product Vision
* ТЗ
* User Stories
* Roadmap (этапы)

---

## 0.3. Дизайн-система (UI Kit v1.0)

**Задачи:**

* Создание UI-kit (цвета, типографика, кнопки, карточки, списки, чипы)
* Подготовка компонентов в Figma
* Согласование тёмной темы

**Артефакты:**

* Figma UI-kit
* Компонентная библиотека

**Критерий завершения:**
UI-kit покрывает 80% типов элементов MVP.

---

---

# 🟩 **1. Архитектура и инфраструктура (Foundations)**

**Длительность: 3 недели**

---

## 1.1. Архитектура Flutter-приложения

**Задачи:**

* Проектирование структуры папок
* Выбор и настройка state management (Riverpod)
* Настройка локального хранилища (Hive / sqflite)
* Настройка запросов (Dio + interceptors)
* Интеграция темной/светлой темы

**Артефакты:**

* Архитектурная схема
* Skeleton-проект flutter

**Критерий:**
Приложение запускается, навигация базовая, темы переключаются.

---

## 1.2. Архитектура backend

**Задачи:**

* Создание проекта (FastAPI / NestJS)
* Настройка JWT-авторизации
* Подключение PostgreSQL + миграции
* Стандартизация ошибок API
* Подготовка Swagger/OpenAPI

**Артефакты:**

* Backend skeleton
* Swagger v1

---

## 1.3. DevOps / CI/CD

**Задачи:**

* Настройка репозиториев GitHub/GitLab
* Настройка сборки Flutter (Dev/Staging)
* Автотесты + линтеры
* Настройка Docker для API
* Развёртывание Staging Env (VPS/Kubernetes)

**Критерий:**
Каждый пуш в main → сборка и деплой staging backend + staging mobile build.

---

---

# 🟧 **2. Дизайн MVP (UX → UI → Prototype)**

**Длительность: 4–5 недель**

---

## 2.1. UX Wireframes

Экраны:

* Онбординг
* Регистрация / логин
* Главный календарь (день / неделя)
* Список задач
* Карточка задачи
* Цели
* Финансы
* Inbox
* AI-планировщик (прототип)
* Настройки

**Критерий:**
все пользовательские пути описаны в Figma.

---

## 2.2. High-fidelity UI + темная тема

**Задачи:**

* Отработка всех экранов в high-fidelity
* Обработка edge-case состояний:

  * ошибки,
  * пустые экраны,
  * offline,
  * loading.

**Критерий:**
UI покрывает 100% экранов MVP.

---

## 2.3. Интерактивный прототип (Figma Prototype)

**Задачи:**

* Связать экраны
* Настроить переходы/микроанимации
* Провести быстрые UX-тесты (5–10 пользователей)

---

---

# 🟨 **3. Реализация MVP (Development Sprint Cycle)**

**Длительность: 12–16 недель**
Развитие параллельное: backend + mobile.

---

# 🔹 3.1 Модуль AUTH (1–2 недели)

**Flutter:**

* Регистрация
* Логин
* Восстановление пароля
* Хранение токена
* Переключение тем

**Backend:**

* /auth/register
* /auth/login
* /auth/reset-password

**QA:**

* Happy path + негативные кейсы
* Тестирование в offline

---

# 🔹 3.2. Календарь (4–5 недель)

**Flutter:**

* Режимы: День, Неделя, Месяц (обзор)
* Создание событий
* Перемещение (drag & drop)
* Параллельные события
* Сменные графики (2/2, 3/3, пользовательские)
* Учёт дороги

**Backend:**

* /calendar (CRUD)
* Логика графиков

**QA:**

* Проверка визуализации в разных часовых поясах
* Сценарии переноса
* Смена темы
* Stress-test: много событий

---

# 🔹 3.3. Задачи + Цели (3–4 недели)

**Flutter:**

* Иерархия цель → проект → задача
* Атрибуты: дедлайн, приоритет, контекст, энергия
* Привязка задачи к календарю
* Повторяющиеся задачи
* Дробимые задачи

**Backend:**

* /tasks
* /goals
* Привязка задачи к цели
* Прогресс целей

**QA:**

* фильтры задач
* дедлайны
* корректность прогресса целей

---

# 🔹 3.4. Финансы (3 недели)

**Flutter:**

* Доходы/расходы
* Категории
* Регулярные операции
* Привязка к событиям календаря
* Месячный отчёт

**Backend:**

* /finance (CRUD)
* Расчёты регулярных операций

**QA:**

* валюты и округления
* пересечение дат
* edge-case: расходы в будущем

---

# 🔹 3.5. Inbox (GTD) (1–2 недели)

* Добавление элементов
* Превращение в задачу/цель/финансовое событие
* Экран обработки

---

# 🔹 3.6. Подписки / Trial (2–3 недели)

**Flutter:**

* Paywalls (Free vs Pro)
* Экран Pro-сравнения
* Активация Trial
* Статус подписки

**Backend:**

* /billing
* Логика Trial
* Webhooks от App Store / Google Play

**QA:**

* edge-cases с платежами
* отмена Trial
* симуляция подписок

---

# 🔹 3.7. AI-планировщик (3–4 недели)

**Flutter:**

* Экран выбора периода
* Формирование input для AI
* Отображение предложенного плана
* Принятие/отклонение

**AI Backend:**

* Модель Planner v1
* Ограничения:

  * рабочие часы,
  * запретные зоны,
  * буферы,
  * дедлайны,
  * контексты.

**QA:**

* тестирование правил:

  * AI не ставит задачи ночью
  * соблюдает буфер
  * уважает дедлайн
* тестирование пустого ответа и ошибок

---

# 🔹 3.8. Offline Sync (2 недели)

**Flutter:**

* Локальный кэш
* Очередь запросов
* Баннер “Синхронизация отложена”

**Backend:**

* поддержка Last Write Wins

**QA:**

* сценарии:

  * оффлайн → онлайп
  * 10+ операций подряд
  * конфликтные обновления

---

# 🔹 3.9. Уведомления (1–2 недели)

**Flutter:**

* Локальные уведомления
* Push через FCM/APNs
* Категории: события, дедлайны, финансы

**Backend:**

* планировщик уведомлений (Cron/queue)

---

---

# 🟫 **4. Финальное тестирование и полировка**

**Длительность: 3–4 недели**

## 4.1. Full Regression

* проверка всех User Stories
* проверка критичных путей
* тестирование Free vs Pro различий

## 4.2. Performance Testing

* загрузка 300+ задач/200 событий
* стабильность рендеринга календаря

## 4.3. UX Polish

* исправление micro-interactions
* улучшение анимаций

## 4.4. Security & Safety

* проверка токенов
* очищение кэша
* перезапуск после убийства приложения

---

# 🟪 **5. Beta-тестирование (Closed Beta)**

**Длительность: 2–3 недели**

## 5.1. Каналы

* TestFlight (iOS)
* Google Play Internal / Closed
* Возможно, ранние пользователи в СНГ (40–100 человек)

## 5.2. Что проверяем:

* Retention D1–D3
* AI-планировщик → accuracy
* Баги по реальным графикам (2/2, 3/3)
* Ошибки синхронизации
* UX болевые точки

## 5.3. Метрики:

* % пользователей, использующих календарь ежедневно
* % пользователей, использующих задачи
* % пользователей, пробующих AI
* Crash-free sessions ≥ 99.5%

---

# 🟩 **6. Релиз MVP**

**Длительность: 1 неделя**

## Артефакты:

* Сборки для App Store / RuStore / Google Play
* Скриншоты
* Описание приложения
* Политика конфиденциальности
* Подготовленный маркетинг-текст

## Цели релиза:

* Собрать данные ретенции
* Оценить интерес к Pro Trial
* Измерить ежедневные сценарии: календарь vs задачи vs финансы

---

# 🟦 **7. Этап Pro 1.0 (Automation & Insights)**

**Длительность: 6–8 недель после MVP**

## Основные задачи:

* Расширенная аналитика
* Planner v2
* Правила планирования (ограничения, буферы, energy)
* Улучшения календаря (просмотр месяца)
* Улучшения GTD (подсказки)

## Цели:

* повышение Pro-конверсии
* рост привычки недельного планирования

---

# 🟧 **8. Этап Pro 2.0 (Intelligence Layer)**

**Длительность: 8–12 недель**

## Основные задачи:

* Межсферная аналитика
* Smart Context Awareness
* Web-версия
* Финансовые прогнозы
* Мультивалютность, счета

---

# 🟥 **9. Autonomy Mode (AI Life OS)**

**Длительность: 3–6 месяцев**

## 9.1. Управление режимом и безопасность

**Задачи:**

* Экран активации Autonomy Mode с описанием полномочий AI и чекбоксом согласия.
* Тумблер включения/паузы режима + уведомление о состоянии.
* Журнал AI-решений (кто/когда/какие изменения) и кнопка отката изменений.
* Guardrails: лимит массовых изменений, подтверждение пакетных действий, контроль прав доступа к данным.

**Артефакты:**

* UX-спеки на поток активации и журнал.
* Политика безопасности/приватности Autonomy Mode.

**Критерий завершения:**
Режим включается только с явным согласием, виден статус, все AI-правки логируются и откатываются.

---

## 9.2. Autonomy Planner (автопланирование с подтверждением)

**Задачи:**

* Алгоритм пакетных предложений: переносы, вставка буферов, отмена конфликтующих событий.
* UI «Review & Apply» с деталями изменений и возможностью принять/отклонить частично.
* Метрики качества: % принятых предложений, среднее число правок в пакетах.

**Артефакты:**

* Набор правил приоритизации и симуляционные отчёты.
* Прототип экрана предложения изменений.

**Критерий завершения:**
Пользователь может принять пакет за ≤2 клика; >70% предложений не требуют ручной доработки в тестах.

---

## 9.3. Self-Adjusting Policy Engine

**Задачи:**

* Сбор паттернов: время переносов, пики энергии, соблюдение бюджета по сферам.
* Автообновление буферов/слотов/ограничений на основе наблюдений.
* Прозрачные объяснения «почему правило изменено» и журнал версий правил.

**Артефакты:**

* Конфигурации правил и changelog обновлений.
* Дашборд показателей устойчивости планирования.

**Критерий завершения:**
Правила обновляются минимум раз в неделю; доступен откат последней версии; видны объяснения для пользователя.

---

## 9.4. Интеграции для автономности

**Задачи:**

* Подключение HealthKit / Google Fit (сон, активность) через явные разрешения.
* Синхронизация внешних календарей и выделение событий источников в UI.
* Настройки источников: временное отключение, выбор типов данных, уведомления об ошибках синка.

**Артефакты:**

* Технические схемы интеграций и список scopes.
* Экран управления источниками данных.

**Критерий завершения:**
Данные из внешних источников учитываются в предложениях AI и отображаются с источником/лейблом.

---

## 9.5. Персональная AI-модель (LifeMerge Genome)

**Задачи:**

* Обучение пользовательской профилированной модели на событиях/задачах/финансах (где разрешено).
* Метрики персонализации: точность предсказаний нагрузки, NPS по качеству советов.
* Контроль приватности: локальное хранение эмбеддингов, анонимизация при облачных расчётах.

**Артефакты:**

* Карта данных и политика хранения.
* Отчёт A/B-тестов персонализированных подсказок.

**Критерий завершения:**
Модель выдаёт рекомендации, учитывающие индивидуальные паттерны; приватность соблюдена согласно политике.

---

# 📌 Вехи (Milestones Summary)

| Этап           | Длительность | Результат                |
| -------------- | ------------ | ------------------------ |
| Pre-production | 2–3 недели   | UI-kit, финальный scope  |
| Архитектура    | 3 недели     | каркас проектов          |
| Дизайн         | 4–5 недель   | полный UI/UX             |
| MVP dev        | 12–16 недель | готовое приложение       |
| Polishing      | 3–4 недели   | стабильность             |
| Closed Beta    | 2–3 недели   | данные и фиксы           |
| MVP Release    | 1 неделя     | публикация               |
| Pro 1.0        | 6–8 недель   | улучшенная автоматизация |
| Pro 2.0        | 8–12 недель  | интеллектуальный слой    |
| Autonomy Mode  | 3–6 месяцев  | частичная автономность   |


========================================
FILE: ./Docs/Dor_DoD.md
========================================

# ✅ **Definition of Ready (DoR)**

*Задача считается «Готовой к разработке», только если соблюдены все условия ниже.*

---

# 1. Общие критерии

1. **Есть формулировка User Story** в формате:
   *Как <роль>, я хочу <действие>, чтобы <ценность>.*
2. **Есть чёткий scope задачи** — явно указано, что входит и что НЕ входит.
3. **Понимание зависимости**:

   * указано, какие задачи должны быть выполнены заранее;
   * какие команды/разработчики задействованы.
4. **Оценка по Story Points может быть выполнена командой**
   (нет неопределённостей, делающих оценку невозможной).

---

# 2. UI/UX критерии

5. **Утверждённый дизайн**:

   * экран(ы) находятся в Figma,
   * дизайнер пометил их как "final" или "ready for dev".
6. **Есть макеты для тёмной темы**, если элемент UI там отличается.
7. **UI-kit компоненты определены** (кнопки, карточки, формы, поля, списки).
8. Если элемент новый → **в UI-kit добавлена спецификация:**

   * размеры,
   * состояния (default/hover/pressed/disabled),
   * отступы,
   * тени,
   * цветовые стили.

---

# 3. Product-критерии

9. **Подтверждена бизнес-логика** (PM/аналитиком):

   * что именно функция должна делать;
   * какие параметры обязательны;
   * какие ограничения применяются.
10. **Определены правила Free / Pro**, в т.ч. поведение при ограничениях.
11. **Определены метрики**, которые будут отслеживаться:

* события аналитики (например, `task_created`, `ai_plan_accept`);
* KPI (retention, usage rate).

---

# 4. Требования к backend

12. **Схемы API готовы** или создан stub:

* эндпоинты,
* метод,
* тело запроса/ответа,
* параметры валидации.

13. **Согласована модель данных** (таблицы, поля).
14. **Уточнена поддержка offline-сценариев**:

* что должно кэшироваться локально,
* что должно ставиться в очередь на синхронизацию.

---

# 5. Требования к AI (если задача включает AI)

15. **Формально определён input/output** модели:

* какие параметры входят,
* что должно вернуться от AI.

16. **Понятны ограничения и правила пользователя**, которые AI обязан соблюдать.
17. **Есть fallback-логика**, если AI вернул пустой/ошибочный результат.

---

# 6. Технические критерии

18. **Определён state-management сценарий** (например, Riverpod/Bloc).
19. **Назначено ответственное лицо** (разработчик + ревьюер).
20. **Нет критических блокирующих вопросов**.

---

# 🎯 Итог DoR

**Если хоть один пункт не выполнен — переносим задачу обратно в Refinement.**

---

---

# 🟢 **Definition of Done (DoD)**

*Задача считается завершённой только если все критерии выполнены.*

---

# 1. Реализация и код

1. **Код написан в соответствии с архитектурой проекта.**
2. **Нет хардкода строк** — всё локализовано через intl/ARB.
3. **Отображается корректно в светлой и тёмной теме.**
4. **State-management реализован согласно принятому паттерну.**
5. **Есть обработка ошибок**:

   * сетевых,
   * AI,
   * валидации.
6. **Реализована offline-очередь**, если задача подразумевает запросы.

---

# 2. UI/UX соответствие

7. **Функциональность полностью соответствует макетам Figma.**
8. Все состояния UI реализованы:

   * загрузка,
   * пустое состояние,
   * ошибки,
   * нет сети,
   * idle.
9. **Анимации/микроинтеракции добавлены**, если указано в спецификации.

---

# 3. Логика и бизнес-правила

10. **Все правила Free/Pro реализованы корректно.**
11. **Граничные случаи обработаны**:

    * пустые списки,
    * нулевые значения,
    * отсутствие даты/дедлайна,
    * пересекающиеся события,
    * сменные графики.
12. Если задача включала AI →
    **AI не нарушает пользовательские правила**, и fallback работает.

---

# 4. Тестирование

13. **Unit-тесты покрывают ключевую бизнес-логику** (минимум 70%).
14. **Интеграционные тесты выполнены** (если затрагивается сетевое API).
15. **Проведены UI-тесты** для основных пользовательских путей.
16. **QA прошёл сценарии Acceptance Criteria** и поставил отметку "Passed".
17. **Нет критических/major багов**, minor — только если согласовано.

---

# 5. Аналитика

18. Все **события аналитики залогированы и отправляются** в систему аналитики.
19. Проверено через debug-tools, что события действительно приходят.

---

# 6. Документация

20. Обновлены:

* README модуля,
* соответствующие страницы Confluence/Notion,
* схемы API (если изменялись),
* changelog.

21. Добавлены скриншоты для QA (если это новый экран).

---

# 7. Релизная готовность

22. Задача интегрирована в dev/main ветку.
23. Пройдён code review минимум двумя разработчиками.
24. Build приложения успешно собран без ошибок.
25. Всё работает на реальных устройствах iOS и Android.

---

# 🎯 Итог DoD

**Задача считается полностью готовой только если может быть передана пользователю/в продакшен без рисков, без доделок и без скрытых требований.**


========================================
FILE: ./Docs/LifeMerge/00_Administration/Decisions_Log.md
========================================

# Template for new decisions

## DEC-XXX — Название решения
**Дата:**  
**Категория:**  
**Статус:** Proposed / Accepted / Rejected / Deprecated  
**Ответственный:**  

### Контекст

### Решение

### Причины

### Влияние


### Альтернативы

### Риски


### Миграции / технические действия

### Ссылки



========================================
FILE: ./Docs/LifeMerge/00_Administration/Glossary.md
========================================

# Glossary – LifeMerge

Документ содержит список терминов, используемых в проекте LifeMerge, их определения и контекст применения.

Структура:
1. Основные термины продукта
2. Планирование и задачи
3. Финансы
4. AI и машинное обучение
5. Архитектура и backend
6. Мобильная разработка (Flutter)
7. Метрики и аналитика
8. Подписки и монетизация
9. Процессы разработки
10. Специфические термины LifeMerge

---

## 1. Основные термины продукта

**LifeMerge**  
Приложение «операционная система жизни», объединяющее цели, задачи, календарь, финансы и AI.

**Сфера жизни (Life Sphere)**  
Категории: работа, здоровье, личное, финансы, учёба и т.д.

**Event (Событие)**  
Любая запись в календаре: встреча, смена, сон, поезка, спорт, финансовое событие.

**Task (Задача)**  
Единица работы, которую пользователь должен выполнить. Может быть привязана к цели или календарю.

**Goal (Цель)**  
Стратегическая задача, состоящая из подзадач.

**Inbox (GTD)**  
Входящие идеи, мысли, задачи без структуры.

---

## 2. Планирование и задачи

**Time Blocking (Блоки времени)**  
Метод планирования, при котором задачи размещаются на временной шкале.

**Working Schedule (Рабочий график)**  
Шаблон рабочей нагрузки (5/2, 2/2, 3/3, ночные смены и т.д.).

**Recurring Task (Регулярная задача)**  
Автоматически повторяющаяся задача по правилу.

**Splittable Task (Дробимая задача)**  
Задача, разбиваемая на несколько временных слотов.

**Context (Контекст)**  
Условие выполнения задачи (например, «@компьютер», «@дом», «@дорога»).

**Energy Level (Энергозатратность)**  
Оценка сложности задачи — лёгкая, средняя, тяжёлая.

---

## 3. Финансы

**Finance Record (Финансовая запись)**  
Доход или расход.

**Recurring Finance Record (Регулярный платёж)**  
Платёж, повторяющийся по расписанию.

**Budget Forecast (Прогноз бюджета)**  
Прогноз финансовой активности на будущее.

**Linked Finance Event (Финансовое событие календаря)**  
Финансовая запись, привязанная к событию календаря.

**Account (Счёт)**  
Источник средств: карточка, наличные, депозит.

---

## 4. AI и машинное обучение

**AI Planner**  
Модуль, предлагающий оптимальные слоты для задач.

**Rule Compliance (Соблюдение правил)**  
AI должен соблюдать правила пользователя (например, «не ставить задачи вечером»).

**AI Suggestion (AI-рекомендация)**  
Предложение AI (изменить слоты, перенести задачу, убрать перегрузку).

**Fallback**  
Поведение системы, когда AI не может дать валидный результат.

**AI Model Versioning**  
Система управления версиями моделей AI.

---

## 5. Архитектура и backend

**API (Application Programming Interface)**  
Взаимодействие между клиентом и сервером.

**Endpoint**  
Конкретный адрес API (например, POST /tasks).

**Entity**  
Основная сущность в системе (user, task, event, finance_record).

**Migration (Миграция)**  
Изменение структуры базы данных.

**Queue (Очередь синхронизации)**  
Механизм отправки событий офлайн-режима после восстановления сети.

---

## 6. Мобильная разработка

**Flutter**  
Фреймворк кроссплатформенной разработки.

**State Management**  
Архитектурный подход для управления состоянием (в LifeMerge — Riverpod).

**Offline Cache (Оффлайн-кэш)**  
Хранение данных локально на устройстве.

**Sync Entry**  
Единица данных, ожидающая синхронизации.

---

## 7. Метрики и аналитика

**NSM (North Star Metric)**  
Ключевая метрика успеха продукта — Weekly Productive Engagement.

**DAU/WAU/MAU**  
Daily / Weekly / Monthly Active Users.

**Activation Rate**  
Процент пользователей, достигших первой ценности продукта.

**Retention D1/D7/D30**  
Удержание пользователей в динамике.

**AI Adoption Rate**  
Доля пользователей, использующих AI.

**Plan Acceptance Rate**  
Процент принятых планов AI.

---

## 8. Подписки и монетизация

**Free Tier**  
Бесплатный тариф с базовыми возможностями.

**Pro Tier**  
Платный тариф с AI, расширенной аналитикой, автоматизацией.

**Trial Period**  
Пробный период использования Pro.

**LTV (Lifetime Value)**  
Ценность пользователя за всё время.

**Churn**  
Отток пользователей.

---

## 9. Процессы разработки

**DoR (Definition of Ready)**  
Критерии готовности задачи к разработке.

**DoD (Definition of Done)**  
Критерии завершённости задачи.

**Release Candidate (RC)**  
Потенциальная сборка для продакшена.

**Hotfix**  
Срочное исправление критического бага на проде.

**CCB (Change Control Board)**  
Группа, утверждающая крупные изменения.

---

## 10. Специфические термины LifeMerge

**Life Intelligence Layer**  
Аналитический уровень Pro 2.0, анализирующий влияние времени, целей и финансов друг на друга.

**Autonomy Mode**  
Режим полуавтономного AI — управляется только по согласию пользователя.

**Planning Consistency Index**  
Метрика устойчивости планирования: насколько фактические действия совпадают с планом.

**Sphere Cross-Impact Analytics**  
Отчёт взаимного влияния сфер жизни.

---

## История изменений
| Дата | Автор | Изменения |
|------|--------|------------|
| 2025-01-XX | … | Первая версия |
| 2025-01-XX | … | Добавлены термины AI и Analytics |



========================================
FILE: ./Docs/LifeMerge/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning /Mobile Sprint 01 — Technical Breakdown (Jira-ready).md
========================================

# 📱 Mobile — Sprint 01 (Foundation + A1)

## EPIC M0 — Core App Skeleton & Infrastructure

### M0.1 Finalize App Skeleton

**Type:** Story
**Priority:** P0

**Scope:**

* Зафиксировать структуру слоёв: `presentation / application / domain / data / core`.
* Финализировать DI-контейнер (scope per feature).
* App bootstrap (env, flavors, error handling root).
* AppRouter + Shell (Auth / Calendar / Tasks / Inbox / Settings / Pro).

**DoD:**

* Проект собирается.
* Можно подключать фичи без правок core.
* Нет feature-to-feature зависимостей.

---

### M0.2 Core Storage (Secure + KV)

**Type:** Story
**Priority:** P0

**Scope:**

* `SecureStorage` (tokens, sensitive data).
* `KeyValueStorage` (flags, onboarding state, prefs).
* Чистые интерфейсы + реализации.

**Tech notes:**

* Без прямых зависимостей в features.
* Async-safe, ready для offline-first.

**DoD:**

* Используется в Auth и Onboarding.
* Покрыт базовыми unit-тестами.

---

## EPIC M1 — Theme & Design System

### M1.1 AppTheme & Tokens

**Type:** Story
**Priority:** P0

**Scope:**

* Light/Dark theme.
* Color tokens (semantic).
* Typography (H1–Caption).
* Spacing, radii.

**Tech notes:**

* Naming = UI Kit v1.0.
* Ни одного “raw color” в UI.

**DoD:**

* Theme используется по всему приложению.
* Токены — единственный источник правды.

---

### M1.2 Base UI Components

**Type:** Story
**Priority:** P0

**Scope:**

* Button (Primary / Secondary / Tertiary + loading/disabled).
* TextField (all states).
* AppBar.
* BottomNavigation.
* ModalSheet / Dialog.
* Loader / Skeleton.

**DoD:**

* Компоненты используются в Auth/Tasks/Calendar.
* Нет дублирующихся UI-реализаций.

---

## EPIC M2 — Navigation

### M2.1 App Navigation Shell

**Type:** Story
**Priority:** P0

**Scope:**

* Auth flow routes.
* Main shell (tabs).
* Guarded routes по AuthState.
* Placeholder routes для Sprint 02.

**DoD:**

* Навигация соответствует wireframes.
* После онбординга → Calendar Day.

---

## EPIC M3 — Auth & Onboarding (A1 critical)

### M3.1 Auth Domain

**Type:** Story
**Priority:** P0

**Scope:**

* Entities: User, AuthState.
* UseCases: signIn, signUp, refresh, logout, restoreSession.
* Repository interfaces.

**DoD:**

* Domain не зависит от Flutter/UI.
* Готово к mock/real data source.

---

### M3.2 Auth UI & State

**Type:** Story
**Priority:** P0

**Scope:**

* Login / Register / Recovery.
* Form validation.
* Error states.
* Loading states.

**Tech notes:**

* Riverpod.
* Single source of truth для AuthState.

**DoD:**

* Happy path A1 проходит ≤5 минут.
* Ошибки API корректно отображаются.

---

### M3.3 Onboarding Flow

**Type:** Story
**Priority:** P0

**Scope:**

* Onboarding screens.
* Persist onboarding completion.
* Transition → Main Shell.

**Analytics:**

* `Onboarding_Complete`.

**DoD:**

* Логируется один раз.
* Повторный запуск → onboarding не показывается.

---

## EPIC M4 — Tasks Core (CRUD)

### M4.1 Tasks Domain

**Type:** Story
**Priority:** P0

**Scope:**

* Task entity.
* Status lifecycle.
* CRUD use-cases.

**Constraints:**

* Без goals.
* Без recurrence.

---

### M4.2 Tasks UI

**Type:** Story
**Priority:** P0

**Scope:**

* Task List.
* Task Create/Edit.
* Complete task.

**Analytics:**

* `Task_Created`
* `Task_Completed`.

**DoD:**

* Работает offline (через queue).
* UI соответствует design states.

---

## EPIC M5 — Calendar Day (Basic)

### M5.1 Calendar Day View

**Type:** Story
**Priority:** P0

**Scope:**

* Day timeline.
* Event list.
* Empty/loading/offline states.

**Constraints:**

* No drag&drop.
* No recurrence.

---

### M5.2 Event Create (Basic)

**Type:** Story
**Priority:** P0

**Scope:**

* Create event.
* Simple start/end.
* Save to backend / queue.

**Analytics:**

* `Reached_Calendar`.

---

## EPIC M6 — Offline Queue v1

### M6.1 Offline Operations Queue

**Type:** Story
**Priority:** P0

**Scope:**

* Queue for Tasks + Events.
* request_id + updated_at.
* Retry & conflict-safe.

**Tech notes:**

* Единая реализация.
* Прозрачна для features.

**DoD:**

* Можно создавать задачи/ивенты offline.
* Синк без дублей.

---

## EPIC M7 — Analytics (A1)

### M7.1 Analytics Infrastructure

**Type:** Story
**Priority:** P0

**Scope:**

* AnalyticsService abstraction.
* Firebase + Amplitude.
* Debug logging.

---

### M7.2 A1 Events

**Type:** Story
**Priority:** P0

**Events:**

* User_SignUp
* Onboarding_Complete
* Task_Created
* Reached_Calendar

**DoD:**

* События не дублируются.
* Проверены на QA-стенде.

---

# ⏱️ Ownership

* **Даниил:** архитектура, M0, M1, M6, аналитика, ревью.
* **Дмитрий:** реализация M2–M5 под контролем.


========================================
FILE: ./Docs/LifeMerge/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning / Sprint 01–02.md
========================================

**MEETING NOTE — Strategic MVP Planning / Sprint 01–02**

**Проект:** LifeMerge
**Дата:** 12.12.2025
**Тип встречи:** Стратегическое планирование MVP (CEO-level)
**Модератор:** Олег (CEO / Founder)

**Участники:**

* Олег — CEO / Founder
* Антон — Product Manager
* Виктор — Product Analyst
* Борис — Lead UI/UX Designer
* Григорий — Interaction Designer
* Даниил — Tech Lead Mobile (Flutter)
* Дмитрий — Mobile Developer
* Егор — Backend Lead
* Евгений — Backend Developer
* Игорь — AI Lead
* Константин — AI Engineer
* Леонид — QA Lead
* Марк — QA Engineer

---

### 1. Цель встречи

1. Зафиксировать P1-ядро MVP согласно Vision / Roadmap / Charter.
2. Уточнить разделение функционала по Sprint 01 и Sprint 02.
3. Определить технические ограничения и риск-области (TZ, offline, AI Planner).
4. Раздать конкретные Action Items командам с ответственными.

---

### 2. Краткий итог обсуждения

* Подтвержден P1-scope MVP: Auth/Onboarding, Calendar Core (Day), Tasks Core, Goals (базово), Inbox, AI Planner v1 (Pro-only), Notifications, Offline Sync, Core Architecture.
* Уточнено разделение спринтов:

  * Sprint 01 — фундамент + A1 (Auth/Onboarding, Tasks CRUD без целей, Calendar Day без drag&drop, Inbox MVP, Notifications infra, аналитика для A1).
  * Sprint 02 — A2 + связки + AI Planner v1 skeleton (Goals, Task→Calendar, Calendar drag&drop, AI Planner v1, Goal Progress, Calendar Conflicts basic, Digest push).
* Зафиксированы ограничения MVP: 1 задача = 1 слот в календаре; простой рабочий график; AI Planner v1 без продвинутой персонализации.
* Подтверждена готовность Design (UI Kit v1.0, P1 wireframes, страница Ready for Dev).
* Подтверждена готовность Mobile skeleton к старту фич (слои, DI, навигация shell, storage-контракты).
* Backend подтвердил стабильность Auth/Tasks/Calendar API и требует жёсткой дисциплины по TZ/updated_at/request_id.
* AI определил минимальный контракт Planner v1 (Tasks, Calendar, Preferences, Goals, Metadata).
* QA сформулировал требования к качеству базовых модулей и базовый набор smoke-тестов для Sprint 01.

---

## 3. Decisions (Решения)

| #   | Решение                                                                                                                                                       | Обоснование                                                                                                   | Owner внедрения                |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------ |
| D1  | Утверждено P1-ядро MVP: Auth/Onboarding, Calendar Day, Tasks, Goals (базово), Inbox, AI Planner v1 (Pro-only), Notifications, Offline Sync, Core Architecture | Соответствие Product Vision, Roadmap и Metrics Plan; ядро, на котором строится A1/A2 и дальнейшая монетизация | Олег / Антон                   |
| D2  | Разделение спринтов: Sprint 01 = фундамент + A1, Sprint 02 = A2 + AI Planner skeleton                                                                         | Снижение риска расползания скопа, фокус на быстрой активации и устойчивом фундаменте                          | Олег / Антон                   |
| D3  | В Sprint 01 реализуем Calendar Day без drag&drop и сложных recurrence                                                                                         | Ускорение time-to-value, уменьшение технической сложности и рисков миграций на старте                         | Антон / Даниил / Егор          |
| D4  | Вводим MVP-ограничение: 1 задача = 1 слот в календаре (no many-to-many)                                                                                       | Снижение сложности Calendar/Tasks/AI, уменьшение риска сложных миграций по связям                             | Антон / Егор                   |
| D5  | Рабочие графики в MVP реализуются в простом формате (без сложных паттернов и истории смен)                                                                    | Избежать высокой сложности в Calendar и Data Model на MVP-этапе                                               | Антон / Егор                   |
| D6  | AI Planner v1 на MVP работает как rule-based+LLM skeleton с минимальным контрактом (Tasks, Calendar, Preferences, Goals)                                      | Быстрый запуск Pro-ценности, минимизация рисков ML и сложности персонализации на старте                       | Олег / Игорь                   |
| D7  | Все времена храним в UTC, клиент передает TZ в заголовке; единый middleware для idempotency/updated_at/request_id                                             | Устойчивость Offline Sync, консистентность данных, снижение риска критических багов в проде                   | Егор / Даниил                  |
| D8  | Crash-free цель для MVP: ≥99% (цель после стабилизации — 99.5%+)                                                                                              | Поддержка премиального позиционирования продукта и Pro-монетизации                                            | Олег / Леонид                  |
| D9  | Обязательная аналитика для событий A1/A2 с первого релиза (User_SignUp, Onboarding_Complete, Task_Created, Calendar_Connected и др.)                          | Необходимо для измерения активации, конверсии в Pro и продуктовых решений                                     | Антон / Виктор / Даниил / Егор |
| D10 | Design-файлы P1 (UI Kit v1.0, Ready for Dev) считаются единственным источником правды для визуала и взаимодействий                                            | Устранение разночтений, ускорение разработки и QA, снижение design-debt                                       | Борис                          |
| D11 | AI Planner API и JSON-схемы фиксируются как отдельный контракт, backend агрегирует данные, клиент передает только период и request_id                         | Разделение ответственности, упрощение клиента, соблюдение AI Architecture                                     | Игорь / Егор                   |
| D12 | QA Definition of Ready/Done становится обязательной для задач Sprint 01, влияющих на A1/A2                                                                    | Защита от недоделанных задач в критичных сценариях, контроль качества с первого инкремента                    | Леонид / Антон                 |

---

## 4. Action Items

### 4.1 Product

| #  | Action Item                                                                                                                                                                    | Owner          | Deadline (относительно встречи) | Статус |
| -- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------- | ------------------------------- | ------ |
| P1 | Зафиксировать Sprint 01 Scope в формате Sprint Plan (Auth/Onboarding, Tasks CRUD без целей, Calendar Day basic, Inbox MVP, Notifications infra, аналитика A1) и завести в Jira | Антон          | 3 рабочих дня                   | Open   |
| P2 | Подготовить сводную таблицу DoR/DoD по модулям Sprint 01 (Auth, Onboarding, Tasks, Calendar Day, Inbox, Notifications, Analytics)                                              | Антон          | 3 рабочих дня                   | Open   |
| P3 | Формально описать A1/A2 сценарии и добавить их в Metrics Plan                                                                                                                  | Антон / Виктор | 5 рабочих дней                  | Open   |
| P4 | Синхронизировать Event Spec c фактическим scope Sprint 01 (A1-события)                                                                                                         | Виктор         | 5 рабочих дней                  | Open   |

### 4.2 Design

| #    | Action Item                                                                                                                                    | Owner    | Deadline       | Статус |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------- | -------- | -------------- | ------ |
| Dsg1 | Подтвердить и заморозить список P1-экранов для Sprint 01; убедиться, что все состояния (empty/error/loading/offline) находятся в Ready for Dev | Борис    | 3 рабочих дня  | Open   |
| Dsg2 | Обновить Interaction Guidelines для A1-flow и Calendar Day без drag&drop                                                                       | Григорий | 5 рабочих дней | Open   |
| Dsg3 | Зафиксировать дизайн-токены (цвета, типографика, spacing, corner radius, состояния) и согласовать naming c mobile-командой                     | Борис    | 3 рабочих дня  | Open   |

### 4.3 Mobile

| #  | Action Item                                                                                                                          | Owner                              | Deadline                           | Статус |
| -- | ------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------- | ---------------------------------- | ------ |
| M1 | Завершить и зафиксировать skeleton архитектуры (слои, DI, навигация shell, storage-контракты)                                        | Даниил                             | до конца 1-й недели Sprint 01      | Open   |
| M2 | Реализовать Theme / Design System (AppTheme, типографика, colors, базовые компоненты) согласно токенам Figma                         | Даниил / Дмитрий                   | до середины Sprint 01              | Open   |
| M3 | Реализовать Auth/Onboarding (домен, состояние экранов, навигация, валидация, обработка ошибок) с интеграцией с Auth API по контракту | Дмитрий (под руководством Даниила) | до конца Sprint 01                 | Open   |
| M4 | Реализовать базовый Tasks CRUD (список, создание, редактирование, завершение) без целей                                              | Дмитрий                            | до конца Sprint 01                 | Open   |
| M5 | Реализовать Calendar Day: отображение событий + создание простого события, без drag&drop и сложных recurrence                        | Дмитрий                            | конец Sprint 01 / начало Sprint 02 | Open   |
| M6 | Реализовать offline-queue v1 для задач и событий (updated_at + request_id)                                                           | Даниил                             | до конца Sprint 01                 | Open   |
| M7 | Интегрировать аналитические события A1 (User_SignUp, Onboarding_Complete, Task_Created, Reached_Calendar)                            | Даниил / Дмитрий                   | до конца Sprint 01                 | Open   |

### 4.4 Backend

| #  | Action Item                                                                                                                        | Owner          | Deadline                                 | Статус  |
| -- | ---------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------------------------------- | ------- |
| B1 | Реализовать Auth API (/signup, /login, /refresh, /forgot, /reset, /logout) согласно спецификации                                   | Егор / Евгений | до середины Sprint 01                    | Open    |
| B2 | Реализовать Tasks API (CRUD без подзадач/recurrence на MVP-этапе) с полями priority, estimated_minutes, due_at, status, goal_id    | Егор / Евгений | до конца Sprint 01                       | Open    |
| B3 | Реализовать Calendar Events API для Day View (CRUD + базовая логика без сложных recurrence)                                        | Егор / Евгений | конец Sprint 01 / начало Sprint 02       | Open    |
| B4 | Реализовать единый middleware для TZ/idempotency (UTC storage, TZ header, updated_at, request_id) и прокинуть во все критичные API | Егор           | до конца Sprint 01                       | Open    |
| B5 | Реализовать backend-агрегацию данных для AI Planner (tasks_min, calendar_min, preferences, goals_min)                              | Егор / Евгений | Sprint 02 (подготовка в конце Sprint 01) | Planned |

### 4.5 AI

| #   | Action Item                                                                                                                          | Owner                               | Deadline                                 | Статус  |
| --- | ------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------- | ---------------------------------------- | ------- |
| AI1 | Зафиксировать JSON-схемы минимального контракта Planner v1 (tasks_min, calendar_min, preferences, goals_min) и согласовать с backend | Игорь                               | 3 рабочих дня                            | Open    |
| AI2 | Реализовать stub-реализацию /v1/ai/plan_week (детерминированный шаблонный план)                                                      | Константин (под руководством Игоря) | Sprint 02 (подготовка в конце Sprint 01) | Planned |
| AI3 | Добавить audit-поля (request_id, user_hash, model_version, prompt_version) в AI сервис                                               | Игорь / Константин                  | Sprint 02                                | Planned |
| AI4 | Подготовить sample payloads (простая неделя, перегруженная неделя, выходные) для мобайла и QA                                        | Константин                          | до начала Sprint 02                      | Planned |

### 4.6 QA

| #   | Action Item                                                                                                  | Owner         | Deadline              | Статус |
| --- | ------------------------------------------------------------------------------------------------------------ | ------------- | --------------------- | ------ |
| QA1 | Сформировать Smoke Test Checklist для Sprint 01 (Auth, Navigation, Calendar Day basic, Tasks, Offline-queue) | Леонид / Марк | 5 рабочих дней        | Open   |
| QA2 | Оформить QA Definition of Ready/Done для задач Sprint 01, влияющих на A1/A2                                  | Леонид        | 5 рабочих дней        | Open   |
| QA3 | Настроить QA-стенд и debug-режим аналитики (видимость ключевых событий A1/A2)                                | Марк          | до середины Sprint 01 | Open   |
| QA4 | Подготовить e2e-сценарии для проверки TZ и offline-синхронизации (Tasks + Calendar)                          | Леонид / Марк | до конца Sprint 01    | Open   |


========================================
FILE: ./Docs/LifeMerge/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning /Sprint Do R Do D.md
========================================

## DoR / DoD Таблица — Sprint 01 (LifeMerge MVP)

| Модуль            | DoR                                                                          | DoD                                                                                                           | Блокирующие зависимости                           |
| ----------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------- |
| Auth              | UI в Ready for Dev, Auth API спецификация финализирована                     | Форма работает, ошибки валидируются, токены обрабатываются, debug-логика событий есть                         | Auth API (B1)                                     |
| Onboarding        | Экраны + flow в Figma, Interaction описан, данные профиля уточнены           | Онбординг сохраняет график, фиксируется `Onboarding_Complete`, навигация завершает на Calendar Day            | Schedule Settings, Event Spec                     |
| Tasks             | Список + форма + состояния экрана готовы, API финализирован                  | CRUD работает, `Task_Created` логируется, offline-queue интегрирован                                          | Tasks API (B2), Storage Layer                     |
| Calendar Day      | Экраны и таймлайн в Ready for Dev, API по /events подтверждён                | События отображаются и создаются, `Reached_Calendar` логируется, поддержка offline                            | Calendar API (B3), Timezone Middleware (B4)       |
| Inbox MVP         | UX поток описан, UI в Ready, структура хранения известна                     | Записи создаются, отображаются, конвертация в задачу работает                                                 | Tasks (M4), Storage                               |
| Notifications     | Push-структура определена, системные разрешения проработаны                  | Приложение может прислать локальный push, инфра не падает, покрыто smoke                                      | Firebase, Permissions                             |
| Analytics Events  | Event Spec готов, события A1 определены                                      | Все ключевые события A1 (`User_SignUp`, `Onboarding_Complete`, `Task_Created`, `Reached_Calendar`) логируются | Event Spec, Analytics SDK                         |
| Core Architecture | Навигация, DI, AppTheme, offline-queue API описаны                           | Навигация работает, UI подключён к теме, offline-операции синкаются                                           | Mobile skeleton (M1), Storage, Backend Middleware |
| AI Planner (stub) | JSON-схемы (tasks_min и др.) согласованы, структура /plan_week зафиксирована | Заглушка API доступна, schema-валидатор встроен, sample payloads готовы                                       | AI1, B5, Tasks, Calendar, Preferences onboarding  |


========================================
FILE: ./Docs/LifeMerge/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning /Sprint Planning.md
========================================

## Sprint Planning — Sprint 01 (LifeMerge MVP)

**Даты спринта:** 15.12.2025 — 29.12.2025
**Product Owner:** Антон (PM)
**Scrum Master:** Олег (CEO, в роли фассилитатора)
**Команда:** Mobile (Даниил, Дмитрий), Backend (Егор, Евгений), AI (Игорь, Константин), QA (Леонид, Марк), Product (Антон, Виктор), Design (Борис, Григорий)

---

### 🎯 Цель Sprint 01

Закладка технического и продуктового фундамента MVP, реализация сценария A1:
**Install → Registration → Onboarding → First Task or Event Created ≤ 5 минут.**

---

### 🧱 Состав фич и модулей

| Модуль            | Описание                                                                 |
| ----------------- | ------------------------------------------------------------------------ |
| Auth              | Регистрация, логин, восстановление, logout                               |
| Onboarding        | Онбординг-мастер, выбор графика, завершение flow                         |
| Tasks             | Список, создание, редактирование, завершение задач                       |
| Calendar Day      | Просмотр событий на день, создание события                               |
| Inbox MVP         | Быстрая запись, отображение входящих                                     |
| Notifications     | Push-инфраструктура, напоминания о событиях и задачах                    |
| Analytics Events  | Интеграция событий: User_SignUp, Onboarding_Complete, Task_Created и др. |
| Core Architecture | DI, навигация, offline-queue, дизайн-система, storage                    |
| AI Planner (stub) | JSON-схемы, /plan_week заглушка, sample payloads, audit metadata         |

---

### 🔗 Связь с метриками и сценариями

* **A1 (Activation):** покрывается полностью.
* **A2 (Goal/Calendar):** подготовка foundation для Sprint 02.
* **WPAR:** подготавливаются элементы (задача, слот, цель) для расчёта.

---

### 📌 Зависимости

* Backend API (Auth, Tasks, Calendar) должны быть готовы в рамках спринта.
* AI контракты JSON (tasks_min и др.) входят в DoR.
* QA стенд и debug-аналитика — обязательны к середине спринта.

---

### ✅ Definition of Ready (DoR)

* Дизайн в статусе "Ready for Dev".
* API/JSON-схемы зафиксированы.
* UI Kit и Interaction Guidelines синхронизированы.
* Сценарии аналитики определены и внесены в Event Spec.

### ✅ Definition of Done (DoD)

* Все критичные баги устранены.
* Интеграционные события шлются в debug.
* Покрытие smoke QA сценариев.
* Модули работают офлайн и проходят sync.
* Визуально соответствуют UI Kit и Interaction Guidelines.

---

### 📁 Подзадачи (см. в Jira)

* [M1] Завершение skeleton архитектуры (Mobile)
* [M3] Auth/Onboarding UI + логика + API интеграция
* [M4] Tasks CRUD MVP
* [M5] Calendar Day View MVP
* [M6] Offline queue для задач/событий
* [B1] Auth API
* [B2] Tasks API
* [B3] Calendar Day API
* [B4] Middleware TZ/idempotency
* [AI1] JSON-схемы Planner v1
* [AI4] Sample payloads
* [QA1] Smoke checklist
* [QA3] Debug-аналитика A1


========================================
FILE: ./Docs/LifeMerge/00_Administration/Meeting_Notes/Template_Meeting_Note.md
========================================

# Meeting Note — {{Название встречи}}
**Дата:**  
**Участники:**  
**Тип:** Product / Design / Tech / AI / Sprint / Planning  

---

## 1. Agenda
- Пункт 1  
- Пункт 2  

---

## 2. Discussion Summary
- Основные решения  
- Открытые вопросы  

---

## 3. Decisions
| Решение | Ответственный | Дедлайн |
|---------|---------------|---------|

---

## 4. Action Items
| Задача | Ответственный | Дата |
|--------|---------------|-------|

---

## 5. Materials & Links
- Figma  
- Jira  
- Документы  



========================================
FILE: ./Docs/LifeMerge/00_Administration/Project_Charter.md
========================================

# Project Charter – LifeMerge

Официальный документ, определяющий цели, границы, принципы, ресурсы, риски и общий контекст проекта LifeMerge.

---

## 1. Project Overview (Обзор проекта)

**Название:** LifeMerge  
**Тип проекта:** Мобильное приложение + AI-платформа  
**Цель:** Создать операционную систему жизни, объединяющую календарь, задачи, цели и финансы в единую систему с AI-планировщиком.  
**Продуктовое обещание:** «Живи осознанно. Управляй всем. Достигай большего.»

---

## 2. Background & Problem Statement (Контекст и проблемы)

Современные профессионалы сталкиваются с:
- фрагментацией инструментов (календарь, задачи, заметки, финансы — отдельно),
- перегруженностью контекстами (работа, семья, здоровье, деньги),
- отсутствием связи между краткосрочными задачами и долгосрочными целями,
- финансовой неопределённостью (нет прогноза, анализа, привязки доходов/расходов к действиям),
- отсутствием персонализированного помощника, учитывающего расписание и правила пользователя.

LifeMerge решает эти проблемы комплексно.

---

## 3. Mission (Миссия проекта)

Помочь людям системно управлять своей жизнью — временем, целями, энергией и деньгами — создавая ясность, контроль и устойчивый прогресс.

---

## 4. Vision (Видение продукта)

LifeMerge станет:
- единым интерфейсом управления жизнью,
- личным помощником по продуктивности и финансам,
- системой, связывающей календарь, задачи, цели и финансы в один поток,
- платформой, адаптирующейся к личности пользователя,
- центральным элементом его ежедневной операционной среды.

---

## 5. Scope (Область проекта)

### В рамках проекта (In Scope)
- Мобильные приложения (iOS, Android) на Flutter.
- Backend-сервис (Auth, Calendar, Tasks, Finance, Inbox, AI).
- AI-планировщик задач: анализ расписания, дедлайнов, приоритетов.
- Финансовый модуль: доходы/расходы, регулярные операции, прогноз.
- GTD Inbox.
- Подписки и Pro-тариф.
- Базовая аналитика.
- Offline-кэш и отложенная синхронизация.
- Push-уведомления.

### Не входит в проект (Out of Scope)
- Полностью автономный AI (только в будущем).
- Полная web-версия (будет в Pro 2.0).
- Интеграция банков по Open Banking (этап Pro).
- Интеграции HealthKit/Google Fit (этап Autonomy).
- ML-модель, обучающаяся на данных пользователя (будущее).

---

## 6. Objectives & Success Criteria (Цели и критерии успеха)

### Основные цели проекта:
1. Создать MVP, соединяющий календарь, задачи, цели и финансы.
2. Реализовать AI-планировщик задач уровня Pro.
3. Обеспечить высокое удержание и ежедневную полезность.
4. Построить технический фундамент для дальнейшей автономности AI.

### Ключевые критерии успеха:
- **Retention D7 ≥ 25%** (целевое).
- **Trial → Pro Conversion ≥ 12–18%**.
- **AI Adoption ≥ 60% среди Pro пользователей.**
- **Crash-free ≥ 99.5%**.
- **Monthly Active Planners ≥ 40% от MAU.**

---

## 7. Deliverables (Основные артефакты)

### MVP Deliverables:
- Мобильные приложения iOS/Android.
- Календарь (день/неделя), задачи, цели.
- Финансовый модуль (доходы/расходы).
- GTD Inbox.
- Backend API + БД.
- Pro Trial + подписки.
- AI Planner v1.
- Система аналитики.
- UI-kit и дизайн систем.

### Документация:
- Product Vision, Roadmap, User Stories.
- Technical Specifications.
- Architecture documents.
- QA Plan.
- Release Plan.
- Change Management Process.
- Metrics Plan.

### MVP Functional Requirements (детализация):
- **Auth & Онбординг:** email+пароль, восстановление через письмо, онбординг 3–5 шагов с выбором рабочего графика, предложение Trial без привязки карты.
- **Календарь & Расписание:** режимы «День/Неделя», создание/редактирование/перетаскивание событий, параллельные слоты, отображение смен, время на дорогу, напоминания, привязка задач.
- **Задачи/Цели/Проекты:** задачи с приоритетами/контекстами/дедлайнами, цели/проекты, связь задач с целями, прогресс по целям, базовая фильтрация, дробление и повторяемость задач.
- **Финансы:** доходы/расходы с категориями и регулярными операциями, привязка к календарю, месячная сводка.
- **Inbox (GTD):** быстрый ввод, конвертация в задачу/цель, пошаговая обработка входящих.
- **AI Planner (Pro/Trial):** генерация плана с учётом занятости и пользовательских правил, ручное подтверждение перед записью в календарь.
- **Подписки и доступ:** просмотр тарифов, запуск Trial без списания, экран статуса подписки, видимые ограничения Free.
- **Уведомления:** запрос разрешений, настраиваемые напоминания по событиям/задачам/финансам, отдельные переключатели категорий.
- **Offline & Синхронизация:** работа с кэшем, очередь действий офлайн, автоматическая отправка и баннер статуса.
- **Настройки:** сменный график, часовой пояс, уведомления, переключение темы (опционально).

---

## 8. Constraints (Ограничения)

### Технические
- Flutter как основной фреймворк.
- PostgreSQL как основная БД.
- Строгая поддержка Offline-first архитектуры в будущем.

### Продуктовые
- Регион СНГ → важны инфляция, валюты, рабочие графики.
- Упрощённый UI — без перегрузки иллюстрациями.
- Прозрачность Pro Trial.

### Временные
- MVP за 4–5 месяцев от старта разработки.  

### Финансовые
- Ограниченные ресурсы → фокус на быстром создании ценности, а не «идеальности».

---

## 9. Assumptions (Предположения)

1. Пользователи готовы использовать приложение ежедневно или несколько раз в неделю.
2. AI-помощник увеличит ценность Pro-тарифа.
3. Финансовый модуль станет важным преимуществом на рынке СНГ.
4. Пользователи предпочтут честный Pro Trial перед paywall-first.
5. Интерфейс «Notion + Apple» хорошо воспринимается целевой аудиторией.

---

## 10. Risks (Риски)

### Технические
- Сложность интеграции AI в планировщик.
- Offline-конфликты и надёжность синхронизации.
- Потенциальные проблемы с производительностью календаря.

### Бизнес-риски
- Низкая конверсия в Pro.
- Сильная конкуренция (Notion, Todoist, TickTick, Google Calendar, local apps).
- Недостаточная привычка пользователей вести финансы.

### Продуктовые риски
- Перегруз функционалом.
- Недостаточно прозрачная ценность AI.

### Риски платформ
- Ограничения App Store/Google Play при работе с подписками.
- Региональные ограничения по платежам.

---

## 11. Stakeholders (Стейкхолдеры)

| Роль | Имя | Интересы |
|------|------|-----------|
| CEO / Founder | … | Успешный продукт, рост подписок |
| Product Manager | … | Ценность продукта, выполнение roadmap |
| Tech Lead | … | Качество архитектуры и скорость разработки |
| Backend Lead | … | Надёжность API и БД |
| AI Lead | … | Качество AI-планировщика |
| Design Lead | … | Высокий UX/UI |
| QA Lead | … | Стабильность и качество релизов |

---

## 12. Governance (Управление проектом)

- Scrum или Kanban (в зависимости от размера команды).  
- Еженедельные синки лидов.  
- Спецификация задач → refinement → DoR.  
- DoD для фич.  
- Release cadence: каждые 2 недели (patch → minor).  

---

## 13. Project Timeline (Ключевые сроки)

| Этап | Длительность | Результат |
|------|--------------|-----------|
| Pre-production | 2–3 недели | Vision, дизайн-концепт, архитектура |
| Design Sprint | 4–5 недель | UI, UX, прототипы |
| Разработка MVP | 12–16 недель | Первый рабочий продукт |
| Полировка & QA | 3–4 недели | Release Candidate |
| Closed Beta | 2–3 недели | Feedback, улучшения |
| Релиз MVP | — | Версия 1.0 |
| Pro 1.0 / Pro 2.0 | — | Дальнейшее развитие |
| Autonomy Mode | — | Дальний горизонт |

---

## 14. Approval (Утверждение)

| Имя | Роль | Статус | Дата |
|------|--------|---------|---------|
| … | CEO | ✔ | … |
| … | Product Manager | ✔ | … |
| … | Tech Lead | ✔ | … |

---

## 15. История изменений

| Дата | Версия | Автор | Изменения |
|------|---------|---------|------------|
| 2025-01-XX | 1.0 | … | Первая версия |
| … | … | … | … |



========================================
FILE: ./Docs/LifeMerge/00_Administration/Team_Roles_and_Contacts.md
========================================

# Team Roles & Contacts — LifeMerge

Документ описывает роли команды, зоны ответственности, контакты и правила коммуникации между участниками.

---

## 1. Состав команды

### Product Team
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| Product Manager |Антон| Визион, roadmap, требования, приоритизация, сценарии | @username, email |
| Product Analyst |Виктор| Метрики, аналитика, дешборды, A/B | @username, email |

### Design Team
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| Lead UI/UX Designer |Борис| Дизайн-система, макеты, прототипы, user flow | @username, email |
| Interaction Designer |Григорий| Анимации, UX-паттерны | @username, email |

### Engineering Team
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| Tech Lead (Mobile) |Даниил| Архитектура Flutter, код-ревью, технические решения | @username, email |
| Flutter Developer |Дмитрий| Реализация экранов, логики, интеграций | @username, email |
| Backend Lead |Егор| Архитектура API, БД, интеграции, DevOps | @username, email |
| Backend Developer |Евгений| Реализация API, миграции БД, очереди задач | @username, email |
| AI Lead |Игорь| Архитектура AI, модели, качество AI Planner | @username, email |
| AI Engineer |Константин| Разработка моделей, тестирование, фичи AI | @username, email |

### QA Team
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| QA Lead |Леонид| QA стратегия, регрессия, e2e | @username, email |
| QA Engineer |Марк| Тестирование фич, тест-кейсы | @username, email |
| Automation QA |Николай| Автотесты, CI/CD интеграция | @username, email |

### Business & Operations
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| CEO / Founder |Олег| Vision, инвестиции, стратегические решения | @username, email |
| Support Lead (после MVP) |Пётр| Поддержка пользователей, база знаний | @username, email |

---

## 2. Карта ответственности (RACI)

### Пример (MVP функции)
| Задача | R (ответственный) | A (утверждающий) | C (консультируемый) | I (информируемый) |
|--------|-------------------|------------------|----------------------|-------------------|
| Product Vision | PM | CEO | Design, Tech Lead | команда |
| Архитектура приложения | Tech Lead | CTO | BE Lead, AI Lead | PM |
| AI Planner MVP | AI Lead | PM | Tech Lead | QA |
| Дизайн календаря | Designer | PM | Tech Lead | QA |
| Финансовый модуль (MVP) | BE Lead | PM | Designer | QA |
| Подписки и Trial | PM | CEO | BE Lead, Tech Lead | QA |
| Offline-синк | Tech Lead | PM | BE Lead | QA |
| Release | PM | CEO | QA Lead | вся команда |

---

## 3. Правила коммуникации

### Каналы
- Slack / Telegram — ежедневная коммуникация  
- Notion / Confluence — документация  
- Jira / Linear — постановка задач  
- Figma — дизайн  
- GitHub / GitLab — код  

### Важные принципы
1. **Асинхронность предпочтительнее**, если вопрос не срочный.  
2. **Встречи только по необходимости**, с чёткой повесткой.  
3. **Решения фиксируются письменно** в Decision Log.  
4. **Общие стендапы** — 10–15 минут.  
5. **Кросс-ревью**: Mobile ↔ Backend, AI ↔ Product.

---

## 4. SLA по коммуникациям

| Тип вопроса | SLA | Канал |
|-------------|------|--------|
| Критический баг (приложение падает, данные теряются) | 15 минут | Tech чат |
| Баг высокой важности | 2 часа | QA чат |
| Запросы по дизайну | 24 часа | Design чат |
| Требования и уточнения | 24 часа | Product чат |
| Код-ревью | 12–24 часа | GitHub/GitLab |
| AI-доработки | 24–48 часов | AI чат |

---

## 5. График встреч
- **Weekly Sync** — PM + Leads  
- **Design Review** — 1–2 раза в неделю  
- **Tech Review / Architecture** — раз в неделю  
- **Sprint Planning** — каждые 2 недели  
- **Sprint Retro** — каждые 2 недели  
- **AI Quality Review** — раз в неделю  

---

## 6. Доступы и владение аккаунтами
- App Store Connect: владелец — …  
- Google Play Console: владелец — …  
- RuStore Developer: владелец — …  
- Firebase: владелец — …  
- Production Database: доступ только Backend Lead + CTO  
- Monitoring/Sentry: Tech Lead + BE Lead  

---

## 7. Экстренные контакты (для hotfix)
- Tech Lead — @…  
- Backend Lead — @…  
- AI Lead — @…  
- QA Lead — @…  
- PM — @…  

---

## 8. История изменений документа
| Дата | Автор | Изменение |
|------|--------|------------|
| 2025-01-XX | … | Создан первый вариант |
| — | — | — |




========================================
FILE: ./Docs/LifeMerge/01_Product/Change_Management/Change_Management_Process.md
========================================

# 🔄 **CHANGE MANAGEMENT PROCESS — LifeMerge**

## Цель процесса

Обеспечить контролируемое, прозрачное, безопасное и предсказуемое внесение изменений в продукт LifeMerge:

* минимизировать риски багов и регрессий,
* защищать стабильность AI-логики,
* не ломать данные пользователей (календарь, задачи, финансы),
* избегать хаоса в Roadmap,
* сохранять предсказуемость релизов.

---

# 1. Типы изменений

Все изменения делятся на 5 категорий:

### **1) Feature Change**

* любые фичи (новые или улучшения)
* пример: AI Planner v2, межсферная аналитика, новый отчёт.

### **2) UX/UI Change**

* изменение внешнего вида и поведения интерфейса
* пример: переработка календаря недели.

### **3) Technical Change**

* архитектурные улучшения, рефакторинг, оптимизация производительности
* пример: переход на новый state-менеджер или новый механизм кэша.

### **4) Data Model Change**

* изменение структуры таблиц, индексов, связей, миграций
* пример: добавление таблицы "accounts" в финансы.

⚠️ **Наиболее критичная для рисков категория.**
Ё
### **5) Hotfix Change**

* быстрые исправления продакшн-багов
* пример: падение при генерации AI-плана.

---

# 2. Change Request Workflow (полный цикл)

Каждое изменение проходит строгий **7-шаговый путь**:

```
Proposal → Analysis → Approval → Implementation → Testing → Release → Monitoring
```

Разберём каждый шаг.

---

# 3. Шаг 1. Change Proposal (инициация)

Инициатор: PM / Tech Lead / Designer / Support / Analytics

Форма Change Request (CR) должна содержать:

1. Заголовок
2. Описание проблемы или потребности
3. Цель изменения
4. Категория change’а
5. Пользовательская ценность
6. Технический impact
7. Зависимости
8. Риски
9. Требования к аналитике
10. Требуемая дата (если есть SLA)

CR создаётся в системе управления задачами (Jira/YouTrack/Linear).

---

# 4. Шаг 2. Analysis (оценка влияния)

Ответственные:

* PM
* Tech Lead
* Backend Lead
* QA Lead
* AI Lead (если затрагивает AI)

Проводится:

### 4.1. Impact Analysis

* затрагиваемые модули: календарь, задачи, финансы, AI, оффлайн-синк
* риски данных: миграции, изменения моделей
* влияние на Free/Pro
* UX-влияние
* зависимость между платформами iOS/Android/Web
* влияние на метрики (Retention / AI Adoption / Conversion)

### 4.2. Estimation

Оценка стоимости:

* FE (Flutter)
* BE
* AI
* QA
* Дизайн

### 4.3. Solution Draft

Черновое решение: схемы, макеты, API-контракт, архитектурная записка.

**Результат:** CR переходит в статус **Ready for Approval**.

---

# 5. Шаг 3. Approval (утверждение изменений)

Решение принимают: PM + Tech Lead
Для изменения Data Model или AI-логики — также AI Lead + Backend Lead.

### Критерий одобрения:

* Решение соответствует Roadmap
* Не ломает пользовательские данные
* Не нарушает принципы UX
* Технически возможно в заданные сроки
* Соответствует бизнес-целям

### Возможные исходы:

* Approved
* Approved with changes
* Rejected
* Deferred (перенос в будущее)

---

# 6. Шаг 4. Implementation (разработка)

Команда создаёт отдельную ветку feature/xxx в репозитории.

### Требования:

1. Следовать архитектурным правилам (Riverpod, Clean Architecture, Dio, offline queue и т.д.)
2. Для Data Model → миграции согласуются заранее с backend.
3. Для AI → используется feature flag.
4. Для UX → никто не отклоняется от Figma-схем.
5. Для сложности оценки → разбить на несколько задач (epic → stories → tasks).

---

# 7. Шаг 5. Testing (QA + авто-тесты)

QA должна протестировать 4 слоя:

1. **Unit tests:** бизнес-логика
2. **Integration tests:** API, offline-sync
3. **UI tests:** корректность отображения и поведения
4. **E2E tests:** пользовательские сценарии

Для AI:

* строгая проверка **hard rule compliance**
* проверка fallback и ошибок
* проверка глубины предложенного плана

После тестирования — отчёт QA → фиксы.

---

# 8. Шаг 6. Release (выкатка)

Варианты релизов:

### Release channels:

* **Internal** (только команда)
* **Closed Beta** (TestFlight / Google Internal)
* **Staged Rollout** (1% → 10% → 50% → 100%)

### Требования перед релизом:

1. Все критерии DoD выполнены
2. Пройдена регрессия по основным модулям
3. Crash-free rate ≥ 99.5% на staging
4. API backward-compatible
5. Чек-лист релиза заполнен PM

---

# 9. Шаг 7. Monitoring (наблюдение после релиза)

Особенно критично для:

* изменений данных (миграции),
* AI-поведения,
* планировщика задач,
* подключения подписок.

### Мониторим:

* Crash-free %
* Ошибки API
* AI rule violation rate
* Drop-offs в новых фичах
* Метрики активации
* Метрики монетизации
* Баг-репорты от пользователей

Если критические ошибки → включаем **Emergency Hotfix Process**.

---

# 10. Emergency Hotfix Process

1. QA подтверждает баг как **Critical**
2. PM/Tech Lead принимают решение → "hotfix required"
3. Создаётся ветка hotfix/xxx
4. Быстрая реализация (≤ 24 часов)
5. Минимальный набор тестов + smoke
6. Выкатка в прод аккуратно (100% или staged)
7. Постморем до 48 часов после фикса

Когда используется:

* приложение не открывается
* AI генерирует опасные/ошибочные планы
* потеря данных задач/финансов
* краши > 1% в проде
* сломанные подписки

---

# 11. Управление версиями продукта

Mobile semantic versioning:

```
MAJOR.MINOR.PATCH (пример: 1.3.2)
```

* MAJOR = крупные изменения (например, Planner v2, новые модули)
* MINOR = новые фичи MVP уровня
* PATCH = багфиксы

Backend versioning:

```
/api/v1/*
/api/v2/* (когда ломаем контракты)
```

AI versioning:

* каждая модель имеет **версию**, хранящуюся в конфиге backend:

  ```
  planner_model_version: "1.2.0"
  ```

---

# 12. Change Control Board (CCB)

Мини-группа, которая принимает решения по крупным изменениям:

### Участники:

* CEO / Founder
* PM
* CTO / Tech Lead
* AI Lead
* Design Lead

Обрабатываемые вопросы:

* крупные фичи roadmap
* изменения бизнес-модели
* рискованные изменения структуры данных
* внедрение Autonomy Mode

---

# 13. Change Risk Matrix

| Тип изменения       | Риск          | Действия                                |
| ------------------- | ------------- | --------------------------------------- |
| UI/UX change        | низкий        | обычный CR процесс                      |
| Feature change      | средний       | CR + тестирование                       |
| Data model change   | высокий       | CCB approval + миграции + staging тесты |
| AI logic change     | очень высокий | feature flag + A/B тест + rollback      |
| Offline sync change | критический   | нагрузочные тесты + E2E + fallback      |

---

# 14. Templates

## 14.1. Change Request Template

```
Title: 
Category: Feature / UI / Tech / Data / Hotfix
Summary:
Problem:
Goal:
User Value:
Technical Impact:
Affected Modules:
Risks:
API Changes:
Migration Needed: Yes/No
Estimated Effort:
Dependencies:
Metrics Affected:
Design Link:
Attachments:
```

## 14.2. Release Checklist Template

```
☐ Все DoD выполнены
☐ Пройдена регрессия
☐ Crash-free ≥ 99.5% на staging
☐ API backwards-compatible
☐ Подписки проверены (Trial, Pro)
☐ AI Planner протестирован
☐ Offline-сценарии проверены
☐ В changelog добавлены изменения
☐ Мониторинг настроен
```

---

# 15. Главные принципы управления изменениями в LifeMerge

1. **Ни одно изменение не должно ухудшать качество планирования.**
2. **AI всегда должен быть под контролем пользователя.**
3. **Структура данных — священная часть системы; менять её — только думая о миграциях.**
4. **Изменения должны улучшать метрики, а не только функциональность.**
5. **Любое изменение может быть отменено (roll back).**
6. **Feature flags — обязательны для AI и крупных модулей.**
7. **Документация обновляется всегда.**

========================================
FILE: ./Docs/LifeMerge/01_Product/Metrics/Alerts_And_Thresholds.md
========================================

# Alerts & Thresholds

- **Crash-free mobile < 98%** за 24 часа → блокируем выкаты, приоритетный фикс.
- **Error rate API > 5%** на ключевых эндпоинтах (/tasks,/calendar,/finance) за 5 минут → page on-call.
- **Активация A1 < 60%** за неделю → проверка онбординга и аналитики.
- **D7 retention < 30%** → анализ когорт и причин оттока.
- **AI planner failure rate > 10%** или время ответа > 5 сек → переключение на fallback/ограничение трафика.
- **Скорость синхронизации > 5 сек** для 90 перцентиля → расследование очередей/сети.


========================================
FILE: ./Docs/LifeMerge/01_Product/Metrics/Dashboards_Structure.md
========================================

# Структура дашбордов

1. **Product Health**
   - MAU/WAU/DAU, активация A1/A2, D1/D7/D30 retention.
   - Функциональное использование: % пользователей с задачами, событиями, финансами.
2. **Acquisition & Funnel**
   - Источники трафика, конверсии онбординга, время до первого value.
3. **Module Dashboards**
   - Tasks/Goals: создано/выполнено, активные цели, прогресс целей.
   - Calendar: события по источникам, конфликтные синхронизации.
   - Finance: транзакции по типам, бюджеты, ARPU (для Pro, если появится).
4. **AI Quality**
   - Успех планов, время ответа, ручные правки, жалобы.
5. **Reliability**
   - Crash-free, error rate, latency p95, нагрузка на очереди.


========================================
FILE: ./Docs/LifeMerge/01_Product/Metrics/Events_Specification.md
========================================

North Star Metric – WPAR (Weekly Planning Activity Rate): доля активных пользователей за неделю, которые составили интегрированный план – связали задачу с событием календаря и целью.
Формула: WPAR = (число пользователей с ≥1 связкой «задача+событие+цель» за неделю) / (общее число Weekly Active Users) × 100%.
Обоснование: этот показатель отражает основную ценность продукта – активное еженедельное планирование. Чем выше WPAR, тем больше пользователей полноценно используют приложение для планирования времени, задач и целей, что коррелирует с долгосрочным удержанием.

Удержание на 7-й день (Retention D7): процент новых пользователей, которые возвращаются в приложение через 7 дней после регистрации. Используется для оценки удержания аудитории; целевой уровень – >30% возвращений на 7-й день. <br/>События: отслеживается по повторным визитам пользователя (например, событие App_Open на 7-й день после Signup).

Task-to-Calendar Attachment Rate: доля задач, которые были привязаны к событиям календаря. Формула: (задачи, добавленные в календарь) / (все созданные задачи) × 100%. Показатель демонстрирует, насколько активно пользователи планируют задачи во времени (в календаре). Стремимся повышать этот процент, так как привязка задач к расписанию свидетельствует о глубоком использовании продукта. <br/>События: отслеживается по событиям Task_Created и Task_Scheduled (сколько задач создано и сколько из них размещено на календаре).

Конверсия онбординга и настройки календаря: доля новых пользователей, которые завершили онбординг и создали первую задачу/событие (A1), а также подключили календарь (настроили расписание, этап A2) после регистрации. Важный показатель активации новых пользователей; целевой уровень A1-конверсии – >70%, при времени до достижения A1 < 5 минут. <br/>События: фиксируется событиями Onboarding_Complete (успешное прохождение onboarding) и Calendar_Connected (подключение внешнего календаря) у каждого нового пользователя.

Events_Specification.md
Ключевые продуктовые события (MVP)
event_name	category	trigger_point (когда фиксируется)	parameters (основные)	used_in_dashboards	notes
User_SignUp	Регистрация	Пользователь успешно зарегистрировался (создан аккаунт)	method (тип регистрации),
source (источник трафика)	Воронка активации (Amplitude)	Логируется один раз на пользователя.
Onboarding_Complete	Онбординг	Завершение всех шагов onboarding-процесса	duration (время прохождения, сек)	Воронка онбординга (Amplitude)	Соответствует достижению A1 (частично).
Task_Created	Задачи	Создание новой задачи пользователем	task_id, via (manual/AI)	Product usage (Amplitude, задачи)	Первое создание задачи используется для метрики A1.
Task_Completed	Задачи	Отметка задачи как выполненной	task_id, completion_time	Engagement (Amplitude, активность)	Используется для расчета активных пользователей (≥3 выполненных задач/неделя).
Calendar_Connected	Интеграция календаря	Подключение внешнего календаря (Google/Exchange и т.д.)	calendar_type (например, Google)	Активация A2 (Amplitude), использование	Пользователь настроил синхронизацию расписания.
Task_Scheduled	Задачи/Календарь	Привязка задачи к слоту в календаре (планирование задачи)	task_id, event_id	Feature usage (Amplitude, связь задач-календарь)	Отслеживается для метрики привязки задач к календарю.
Goal_Created	Цели	Создание новой цели пользователем	goal_type (категория/область)	Активация A2 (Amplitude), использование	Логируется при добавлении цели (альтернатива A2, если не подключён календарь).
AI_Planner_Used	AI Planner	Запуск пользователем AI-планировщика задач	tasks_scheduled (число задач в плане)	Feature usage (Amplitude, AI)	Повторное использование показывает ценность AI-планирования.
Finance_Transaction_Added	Финансы	Добавление новой финансовой транзакции	amount, category	Finance module usage (Amplitude)	Показывает вовлечённость в модуль финансов.
Finance_Initialized	Финансы	Завершение начальной настройки финансов (категории/бюджет)	categories_count	Product usage (Amplitude, Finance)	Пользователь начал использовать финансы (заполнил категории расходов).

Формат именования событий: [object]_[action] в UpperCamelCase через underscore. Например: User_SignUp (регистрация пользователя), Task_Completed (выполнение задачи), Calendar_Connected (интеграция календаря). Имена отражают сущность и совершенное действие.

Общие требования к логированию:

Каждое продуктовое событие должно логироваться одновременно в Firebase и Amplitude (дублировать события в обе системы для консистентности данных).

Логируются только значимые действия пользователя: необходимо минимизировать технический шум (не отправлять события о внутренних вызовах, рендерах UI и т.п.).

Вся логика отправки событий должна быть тщательно протестирована: проверяем, что события срабатывают единожды в нужный момент, содержат корректные параметры, и не дублируются. Желательно использовать sandbox/тестовые окружения и debug-режимы аналитики для проверки.

Структура дашбордов MVP на старте

Amplitude (продуктовая аналитика):
– Воронки по ключевым сценариям (регистрация → онбординг → A1/A2) для анализа конверсий.
– Retention: показатели удержания D1, D7, D30 (когортный анализ возвращаемости пользователей).
– North Star Metric: трекинг динамики WPAR по неделям.
– Использование функций: доля пользователей, использующих задачи, календарь, цели, финансы (активность по модулям).
– Отток на онбординге: выявление шагов онбординга с наибольшим отсевом (падение конверсии между этапами).

Firebase (качество и технические метрики):
– Crash-free sessions: процент сессий без сбоев (стабильность приложения).
– Статистика устройств: версия приложения, ОС, модель устройства (для отслеживания технических характеристик аудитории).
– Error rate: уровень ошибок (HTTP 5xx, сбои) на бэкенде и в приложении.
– Доставка push-уведомлений: метрики отправки и открытия push (сколько push доставлено и сколько из них открыто пользователями).

Metabase (бизнес-показатели, при необходимости):
– ARPU (Average Revenue Per User) – средний доход на пользователя (если в MVP предусмотрены платные функции).
– Trial‑to‑Pro конверсия – процент пользователей, перешедших с пробной версии на платную (при наличии подписки).
– LTV (Lifetime Value) – пожизненная ценность пользователя, на основе данных о доходах и удержании.
– Дополнительные аналитические запросы (SQL) для глубокой сегментации и анализа использования, которые не покрываются стандартными дашбордами.

========================================
FILE: ./Docs/LifeMerge/01_Product/Metrics/Metrics_Plan.md
========================================

# Metrics Plan (MVP)

## North Star
- «Планирование, выполняемое пользователями»: доля активных, у которых есть связка задачи+событие+цель за неделю.

## Активация
- A1: завершён онбординг и создана первая задача/событие.
- A2: подключён календарь или создана цель.
- Время до A1 < 5 минут, конверсия онбординга >70%.

## Удержание
- D1/D7/D30 retention.
- Weekly Active with ≥3 выполненными задачами.
- Повторное использование AI-планировщика.

## Модульные метрики
- Календарь: % пользователей с ≥1 событием в неделю, синхронизация без конфликтов.
- Задачи/цели: среднее количество задач в день, прогресс целей.
- Финансы: MAU модуля, доля пользователей с заполненными категориями и ≥5 транзакциями/месяц.

## Качество
- Crash-free mobile >98%.
- Ошибки API (5xx) <1%.
- SLA синхронизации офлайн очереди <5 сек.

## North Star Metric – WPAR (Weekly Planning Activity Rate):
доля активных пользователей за неделю, которые составили интегрированный план – связали задачу с событием календаря и целью.
Формула: WPAR = (число пользователей с ≥1 связкой «задача+событие+цель» за неделю) / (общее число Weekly Active Users) × 100%.
Обоснование: этот показатель отражает основную ценность продукта – активное еженедельное планирование. Чем выше WPAR, тем больше пользователей полноценно используют приложение для планирования времени, задач и целей, что коррелирует с долгосрочным удержанием.

## Удержание на 7-й день (Retention D7): процент новых пользователей, которые возвращаются в приложение через 7 дней после регистрации. 
Используется для оценки удержания аудитории; целевой уровень – >30% возвращений на 7-й день. <br/>События: отслеживается по повторным визитам пользователя (например, событие App_Open на 7-й день после Signup).

## Task-to-Calendar Attachment Rate:
доля задач, которые были привязаны к событиям календаря. Формула: (задачи, добавленные в календарь) / (все созданные задачи) × 100%. Показатель демонстрирует, насколько активно пользователи планируют задачи во времени (в календаре). Стремимся повышать этот процент, так как привязка задач к расписанию свидетельствует о глубоком использовании продукта. <br/>События: отслеживается по событиям Task_Created и Task_Scheduled (сколько задач создано и сколько из них размещено на календаре).

## Конверсия онбординга и настройки календаря: 
доля новых пользователей, которые завершили онбординг и создали первую задачу/событие (A1), а также подключили календарь (настроили расписание, этап A2) после регистрации. Важный показатель активации новых пользователей; целевой уровень A1-конверсии – >70%, при времени до достижения A1 < 5 минут. <br/>События: фиксируется событиями Onboarding_Complete (успешное прохождение onboarding) и Calendar_Connected (подключение внешнего календаря) у каждого нового пользователя.


========================================
FILE: ./Docs/LifeMerge/01_Product/MVP_Scope_v1.md
========================================

Регистрация и онбординг

Входящие модули и фичи: Регистрация нового аккаунта по email + паролю, вход и восстановление пароля, а также первичный онбординг пользователя. Онбординг реализован в виде мастера из ~3–5 экранов: краткое представление ценности продукта, настройка параметров (например, выбор рабочего графика 5/2, 2/2, 3/3 или кастомного расписания) и предложение активировать бесплатный Trial Pro-подписки.

Статус реализации: Входит в MVP. Все перечисленные возможности (создание учётной записи, авторизация, сброс пароля, онбординг и базовая пробная подписка) реализованы в мобильном приложении.

Пользовательская ценность: Обеспечивает быстрый старт работы с приложением. Пользователь получает защищённый доступ к своим данным и синхронизацию между устройствами, знакомится с основными возможностями LifeMerge и настраивает приложение под свой образ жизни (например, график работы) для персонализированного опыта.

Зависимости: Модуль аутентификации (для управления аккаунтами и токенами), модуль профиля/настроек (сохранение рабочего графика, часового пояса и предпочтений), интеграция с системой подписок (для активации Trial). Онбординг взаимодействует с календарём (применяет выбранный рабочий график к расписанию пользователя).

Сценарии использования: 1) Новый пользователь устанавливает приложение, регистрируется через email и пароль, после чего проходит серию экранов онбординга – узнаёт о возможностях приложения, выбирает свой рабочий график, и на финальном шаге при желании активирует Trial Pro-функций. 2) Возвращающийся пользователь входит в аккаунт и видит синхронизированные данные (ранее созданные задачи, события, цели) сразу после авторизации.

Планирование задач и целей

Входящие модули и фичи: Модуль задач (Task Manager) и модуль целей/проектов. Пользователь может создавать, редактировать и удалять задачи; указывать для них приоритет, дедлайн, контекст и статус выполнения. Поддерживаются подзадачи и повторяющиеся задачи. Задачи можно связывать с целями/проектами – для этого реализован модуль целей, позволяющий создавать цели в разных сферах жизни и отслеживать прогресс их достижения. Отображается процент выполнения цели на основе выполненных связанных задач. Также реализована базовая фильтрация и организация задач по проектам.

Статус реализации: Входит в MVP. Базовый функционал задач и целей реализован полностью в мобильном приложении. (Продвинутые возможности управления проектами, такие как совместная работа или подробная аналитика по целям, в MVP не входят.)

Пользовательская ценность: Позволяет пользователю управлять своими делами и долгосрочными целями в одном месте. Задачи привязаны к конкретным целям, что даёт понимание, как ежедневные действия приближают пользователя к его целям. Пользователь получает инструмент планирования по методологии GTD: можно разгружать голову, фиксируя задачи, и быть уверенным, что ничего не потеряется.

Зависимости: Связка с модулем календаря (задачи могут отображаться в расписании, если назначены на слот времени), с модулем уведомлений (напоминания о дедлайнах задач), с модулем аналитики (отображение прогресса по целям), а также с inbox/входящими (идея из инбокса может быть преобразована в задачу или цель). Работает в связке с офлайн-системой (создание и изменение задач/целей офлайн с последующей синхронизацией).

Сценарии использования: 1) Создание задачи и цели: пользователь добавляет новую цель (например, “Подготовиться к сертификации”), затем создаёт несколько задач внутри этой цели. Он указывает дедлайны и приоритеты, после чего видит прогресс выполнения цели (например, 0% выполнено, позже процент растёт по мере закрытия задач). 2) Управление задачами: пользователь просматривает список задач на день, отмечает некоторые из них выполненными, изменяет приоритет других. Если задача становится нерелевантной – удаляет или переносит дедлайн. Все изменения синхронизируются и при необходимости будут отражены в календаре и общей статистике целей.

Управление календарём

Входящие модули и фичи: Календарный модуль – центральный элемент приложения. Реализованы основные представления календаря: режим “День” и “Неделя” (интерактивный таймлайн) для обзора расписания. Пользователь может создавать события в календаре (с указанием названия, времени начала, длительности/конца, а также опционально места и типа события) и редактировать их. Поддерживаются повторяющиеся события (например, еженедельные встречи) и параллельные события на одно время (учёт случаев многозадачности). Предусмотрен Drag & Drop – возможность перетаскивать события и задачи по календарю для быстрого изменения времени. В календаре автоматически отображается выбранный при онбординге рабочий график (смены) – рабочие дни и выходные визуально различаются. Также учитывается время на дорогу между событиями (заложены промежутки) и конфликты по времени (приложение предупредит, если события пересекаются). Задачи из списка задач можно привязывать к временны́м слотам календаря, превращая их в запланированные активности на день.

Статус реализации: Входит в MVP. Основные функции (день/неделя, события, повторения, перемещение, отображение сменного графика) реализованы. Просмотр месяца как целого календарного сетка не реализован полноценно в MVP (может быть добавлен в будущих версиях). Синхронизация с внешними календарями (Google/Apple) не выполняется в рамках MVP, фокус сделан на собственном календаре приложения.

Пользовательская ценность: Позволяет пользователю видеть полную картину своего времени и планировать дни и недели с учётом всех активностей. Календарь интегрирован с задачами и финансами, поэтому в одном месте отображаются и события (встречи, тренировки, рабочие смены) и запланированные задачи, и даже важные финансовые транзакции (например, день зарплаты). Это обеспечивает целостное управление временем. Гибкость календаря (поддержка нестандартных графиков, параллельных задач) помогает адаптировать планировщик под реальную жизнь пользователя.

Зависимости: Интеграция с модулем задач/целей (задачи добавляются в календарь), с модулем финансов (календарь может отображать финансовые события, привязанные к датам, такие как регулярные платежи или поступления), с уведомлениями (напоминания о наступлении событий). Зависит от настроек пользователя (рабочий график, часовой пояс) и от модуля офлайн-синхронизации, чтобы изменения в расписании не терялись без сети.

Сценарии использования: 1) Планирование недели: пользователь открывает вид “Неделя” и видит рабочие дни и выходные. Он перетаскивает 3 задачи из списка на свободные окна во вторник и четверг, создаёт событие “Встреча с клиентом” в среду 15:00, дублирует его на каждую неделю (повторение), и убеждается, что в календаре не осталось конфликтов. 2) Ежедневный просмотр: утром пользователь переключается в режим “День” и просматривает текущий день – отмечены рабочие часы согласно графику, запланированы две задачи (например, с 10:00 до 11:00 и с 17:00 до 18:00) и одно событие в обед. Приложение напомнит уведомлением за выбранное время до начала каждой активности.

Финансы

Входящие модули и фичи: Финансовый модуль для базового учёта личных финансов. Пользователь может добавлять транзакции доходов и расходов с указанием суммы, категории и даты. Поддерживаются регулярные операции (например, ежемесячная зарплата или аренда) для автоматического добавления в бюджет. Имеется справочник категорий расходов и доходов, адаптированных под СНГ. Реализован дашборд “Месяц” – агрегированная сводка финансов за текущий месяц: общая сумма доходов, расходов и расчёт баланса; прогресс исполнения бюджета. Пользователь может устанавливать простые бюджетные ограничения (например, лимит расходов на месяц) и видеть прогноз до конца месяца с учётом регулярных транзакций.

Статус реализации: Входит в MVP (базовая версия). Основной функционал учёта финансов реализован: ручной ввод транзакций, категории, повторяющиеся платежи, просмотр статистики за месяц. Расширенные возможности (например, несколько счетов, детальная аналитика по категориям за период, интеграции с банковскими API для авто-импорта) – не включены в MVP.

Пользовательская ценность: Позволяет пользователю отслеживать свои финансы в том же приложении, где он планирует время и задачи. Благодаря этому он видит целостную картину ресурсов: куда уходит не только время, но и деньги. Это повышает осознанность расходов и помогает планировать бюджеты. Связка с календарём даёт понимание, когда ожидаются крупные траты или поступления (например, приложение может отобразить день зарплаты в календаре). В результате пользователь лучше контролирует финансовые цели (накопления, сокращение долгов и т.п.).

Зависимости: Модуль категорий (для классификации транзакций), модуль календаря (отображение финансовых событий – для регулярных платежей, дат зарплаты и т.д.), модуль уведомлений (напоминания о предстоящих платежах). Зависит от системы синхронизации (чтобы данные о транзакциях были доступны офлайн и синкались при восстановлении сети). Также связан с аналитикой приложения – финансовые данные могут влиять на AI-аналитику и подсказки в будущем.

Сценарии использования: 1) Учёт расходов: пользователь после каждой покупки открывает раздел “Финансы” и добавляет расход – например, 500₽ в категории “Продукты” сегодня. В течение месяца он вносит доход (зарплата) и десятки расходов. На экране дашборда он видит, что, например, за текущий месяц потрачено 20,000₽ из бюджета 30,000₽ (оставшийся лимит 10,000₽). 2) Регулярные платежи: пользователь задаёт регулярный расход “Абонемент в спортзал 1000₽ каждый месяц 1-го числа”. Приложение автоматически добавляет такую транзакцию в начале нового месяца и может отобразить событие в календаре 1-го числа с пометкой, что будет списание. Пользователь получает уведомление в этот день и не забывает заложить нужную сумму.

GTD Inbox (Входящие)

Входящие модули и фичи: Модуль Inbox для сбора входящей информации и идей по принципу GTD. Пользователь в любой момент может быстро зафиксировать новую мысль, задачу или напоминание в виде элемента “Inbox” (минимум полей – например, только текст заметки). Далее предусмотрена обработка входящих: элемент из Inbox можно преобразовать в задачу, событие календаря или цель одним нажатием, когда пользователь разбирает накопившиеся записи. Inbox поддерживает базовый список уведомлений из разных модулей (например, непрочитанные напоминания также могут попадать во входящие для обзора). Присутствует функционал последовательной обработки: пользователю предлагается просмотреть каждый элемент inbox и решить, во что его конвертировать или удалить, что соответствует GTD-практикам “разбора входящих”.

Статус реализации: Входит в MVP. Реализованы создание элементов Inbox, их хранение локально и на сервере, а также конвертация входящего элемента в запись другого модуля (задачу, событие календаря или цель). Дополнительные AI-подсказки для автоматической категоризации или рекомендации действий (заявленные в Pro-версии) – не входят в функционал MVP.

Пользовательская ценность: Позволяет оперативно фиксировать любые мысли или задачи, не заботясь сразу о их месте в структуре. Пользователь освобождает голову, зная, что ничего не потеряется: всё незакреплённое временно складируется во входящих. Затем, в удобное время, он обрабатывает Inbox и раскладывает элементы “по своим местам” – планирует как задачу, добавляет в календарь или относит к какой-то цели. Это повышает продуктивность и снижает стресс от необходимости держать всё в памяти.

Зависимости: Тесно интегрирован с модулями задач, календаря и целей (так как преобразование создаёт объекты в этих модулях). Связан с уведомлениями (например, пропущенное уведомление может сохраниться во входящих для внимания пользователя) и с AI-модулем (в будущем – для умных подсказок классификации, которые в MVP отключены). Зависит от офлайн-режима: записи Inbox можно делать без сети, они синхронизируются позже.

Сценарии использования: 1) Быстрая запись идеи: пользователь по пути на работу открывает Inbox и быстро печатает заметку “Купить подарок на др\n рождения мамы”. Пока он занят, эта запись просто хранится во входящих. Вечером он открывает приложение, заходит в Inbox и конвертирует эту заметку в задачу с дедлайном на нужную дату. 2) Обработка входящих: пользователь раз в день открывает Inbox, где накопилось, скажем, 5 элементов (заметки, идеи). Он последовательно проходит по каждому: какие-то сразу удаляет как неактуальные, какие-то превращает в задачи, назначая им дату, а один элемент преобразует в событие календаря. В итоге Inbox очищается, все дела разнесены по своим категориям.

AI-планировщик

Входящие модули и фичи: Модуль AI Planner – интеллектуальный помощник для планирования расписания. На этапе MVP доступен ограниченно и только для Pro-пользователей (либо на период Trial). Функциональность: пользователь может запросить у AI-сервиса сформировать оптимальное недельное расписание на основе текущих задач, событий календаря и предпочтений. Первая версия AI-планировщика учитывает базовые правила: не планировать задачи на позднюю ночь, соблюдение выходных дней, добавление буферов между событиями. AI анализирует список невыполненных задач пользователя, их приоритеты, длительности, а также занятость календаря, после чего предлагает расписание – распределяет задачи по свободным слотам недели с учётом указанных ограничений. Результат планирования показывается пользователю в виде черновика расписания, пользователь может внести правки и подтвердить план, после чего задачи расставляются в календаре. Также AI может предоставить текстовые инсайты – например, краткое объяснение, почему выбрано такое расписание, или советы по продуктивности.

Статус реализации: Частично входит в MVP. Первая версия AI-планировщика реализована и работает через внешний AI-сервис (LLM API). Однако функциональность доступна только в платной версии (ограничение тарифа Free). Бесплатные пользователи увидят заглушку с предложением попробовать Trial. Продвинутые функции AI (учёт энергии пользователя, голосовые команды, полностью автономное планирование и т.д.) находятся за рамками MVP.

Пользовательская ценность: Предоставляет уникальное преимущество приложения – экономит время пользователя на ручное планирование. AI выступает как “умный ассистент”, который на основе данных о задачах и расписании генерирует оптимальный план недели. Пользователь получает персональные рекомендации – когда лучше выполнить ту или иную задачу, как сбалансировать работу и отдых. В итоге повышается продуктивность: меньше прокрастинации и забытых дел, более равномерная нагрузка в течение недели. Даже в первой ограниченной версии AIPlanner помогает пользователю увидеть возможный план и снять с него часть когнитивной нагрузки по распределению задач.

Зависимости: Глубоко интегрирован с модулями задач, календаря и целей – AI берёт входные данные из них. Зависит от backend AI-сервиса (вычисления плана происходят на стороне сервера/модели). Требует актуальной информации о предпочтениях пользователя (рабочие часы, выходные, личные запретные временные окна – эти настройки берутся из профиля). После составления плана создаёт события в календаре (через backend API). Также связан с модулем уведомлений (например, может присылать уведомление “Новый AI-план готов”) и с модулем подписки (чтобы проверять доступность функции для данного пользователя).

Сценарии использования: 1) Запуск недельного планирования: в воскресенье вечером пользователь нажимает “Спланировать неделю (AI)”. Приложение показывает индикатор, затем отображает предварительное расписание: все несделанные задачи распределены по дням предстоящей недели с учётом его уже запланированных встреч. Пользователь видит, что, например, в понедельник AI поставил 3 задачи высокой приоритетности утром, а вечер оставил свободным для отдыха. Он принимает план, и задачи автоматически занимают слоты в календаре. 2) Частичный ре-план: в середине недели пользователь выполнил не все задачи за понедельник. Он удаляет пропущенные задачи из календаря и снова обращается к AI с запросом перепланировать оставшиеся на оставшиеся дни. AI пересчитывает и предлагает скорректированный план, который пользователь редактирует (например, убирает задачу с четверга) и сохраняет.

Уведомления

Входящие модули и фичи: Модуль уведомлений отвечает за отправку push-уведомлений пользователю о важных событиях и задачах. Реализованы напоминания о событиях календаря и дедлайнах задач – с настраиваемым временем упреждения (например, за 10 минут до события, за 1 день до дедлайна задачи). Также предусмотрены уведомления о финансовых событиях (например, напоминание “сегодня день оплаты счета” на основе регулярной транзакции). Пользователь может управлять категориями уведомлений – например, отключить пуши о финансах, но оставить о задачах. Помимо точечных напоминаний, реализован ежедневный и еженедельный дайджест: утром приложение может прислать краткий обзор дня (сколько дел запланировано, ближайшие события, прогноз погоды – при интеграции, и т.п.), а в конце недели – сводку выполненных задач, прогресса по целям и финансового баланса. (Дайджесты настраиваемые, их можно выключить.)

Статус реализации: Входит в MVP. Базовые пуш-уведомления реализованы через сервисы FCM/APNs. Настройка времени и типа напоминаний доступна в приложении. Отправка дайджест-уведомлений реализована ограниченно (например, только текстом, без сложной инфографики). Внешние интеграции (например, погодные уведомления или email-рассылки) не используются в MVP.

Пользовательская ценность: Помогает пользователю ничего не пропустить – приложение своевременно напоминает о запланированных событиях и дедлайнах, тем самым повышая надёжность ведения дел в LifeMerge. Дайджесты позволяют оглянуться на прогресс: сколько всего сделано за день/неделю, что потрачено, чего достигли – это мотивирует продолжать использование и улучшает осознанность пользователя о своих достижениях и планах. Уведомления делают приложение более “живым” и полезным в ежедневной рутине без необходимости постоянно его открывать.

Зависимости: Интеграция с модулями задач, календаря и финансов – эти модули предоставляют события, по которым нужно отправлять уведомления (время начала события, срок задачи или дата платежа). Зависит от системных сервисов уведомлений (Firebase Cloud Messaging для Android, Apple Push Notification service для iOS). Связан с настройками профиля (пользовательские предпочтения по уведомлениям, временные окна “Do not Disturb”). Также зависит от точности данных календаря/задач: если задача не имеет дедлайна, уведомление не сформируется.

Сценарии использования: 1) Напоминание о событии: за 15 минут до начала встречи, добавленной в календарь, пользователь получает push на телефон: “⚡️ Встреча с клиентом в 14:00 (через 15 мин)”. Благодаря этому он успевает подготовиться и не пропускает событие. 2) Еженедельный отчёт: в воскресенье вечером приложение присылает уведомление: “Ваш прогресс за неделю: выполнено 12 задач, достигнут прогресс в 2 целях, баланс финансов +5% от плана. На следующей неделе – 3 задачи запланированы. Отличная работа! ✨”. Пользователь открывает приложение, чтобы подробнее посмотреть аналитику, вдохновлён результатами.

Оффлайн-режим и синхронизация

Входящие модули и фичи: Поддержка полнофункциональной работы приложения офлайн. Реализована локальная база данных (SQLite через пакет sqflite) для хранения всех основных сущностей: задачи, события календаря, цели, финансовые транзакции, а также специальная очередь операций для синхронизации. При отсутствии интернет-соединения все изменения, вносимые пользователем (создание или редактирование задач, событий, целей, финансовых записей), сохраняются локально и ставятся в очередь. Как только связь восстановится, приложение автоматически отправит накопленные операции на сервер. Реализован механизм разрешения конфликтов: у каждой записи есть метка updated_at, при синхронизации возможен детект конфликтов (например, запись была изменена на другом устройстве) – тогда сервер вернёт ошибку, и клиент покажет пользователю уведомление или выполнит стратегию слияния изменений. В UI приложения предусмотрен индикатор состояния синхронизации (например, значок офлайн-режима или баннер “Соединение потеряно/восстановлено”). Также все просмотренные данные кэшируются, чтобы были доступны без сети в режиме Read-Only.

Статус реализации: Входит в MVP. Офлайн-режим поддерживается для всех основных сценариев: создание/редактирование задач, событий, целей и финансовых записей без интернета – с последующим автоматическим sync. Покрыт базовый случай конфликтов (последний updated_at побеждает). Ограничения: в MVP синхронизация происходит сразу при появлении сети или вручную по открытию приложения; более тонкая настройка (например, выбор только Wi-Fi для sync) не реализована.

Пользовательская ценность: Даёт уверенность, что приложение доступно в любое время и в любом месте, даже без подключения к интернету. Пользователь может, к примеру, в самолёте или в метро продолжать работать: добавлять задачи, отмечать выполненное, смотреть календарь. Все изменения надёжно сохраняются локально и не будут потеряны. Это особенно важно для планировщика, претендующего на роль “операционной системы жизни” – он должен быть надёжным и автономным. Офлайн-синхронизация повышает доверие: пользователь знает, что данные синхронизируются корректно, даже если связь прерывалась.

Зависимости: Зависит от модулей хранения данных на устройстве (локальная БД, шифрование хранилища для чувствительных данных). Тесно связан с backend API – все операции повторяются на сервере, когда появляется связь. Требует поддержки в каждом функциональном модуле: задачи, календарь, финансы и т.д. должны правильно ставить операции в очередь. Также интегрирован с модулем уведомлений: при длительном офлайне может быть показан баннер о режиме офлайн. Безопасность: учитывается ограничение на количество офлайн-сессий (до 3 активных устройств на аккаунт).

Сценарии использования: 1) Создание задачи без сети: пользователь находится под землёй без интернета и добавляет новую задачу в приложении. Приложение моментально сохраняет её локально и помечает значком синхронизации. Когда пользователь выйдет в сеть, задача автоматически отправится на сервер, и значок пропадёт. 2) Редактирование календаря офлайн: пользователь в отпуске, Интернет дорогой. Он вносит несколько изменений в календарь (двигает события, добавляет задачи на дни). Приложение сохраняет всё локально. Позже, подключившись к Wi-Fi, пользователь открывает приложение – оно синхронизирует все изменения за несколько секунд (батчем). Все устройства пользователя теперь обновлены с учётом этих правок.

Free vs Pro Rules (MVP)

В рамках MVP реализовано разграничение функциональности между бесплатной версией (Free) и платной подпиской (Pro). Ниже перечислены ограничения для бесплатных пользователей и соответствующие преимущества Pro:

AI-планировщик задач: Доступен только пользователям Pro-тарифа (включая Trial-период); у бесплатных аккаунтов эта функция отключена. То есть Free-пользователь не может запустить автоматическое расписание недели – в приложении ему будет предложено оформить Trial или подписку для использования AI.

Продвинутые аналитические отчёты: В бесплатной версии доступны только базовые метрики и отчёты (например, количество выполненных задач, общий прогресс целей, суммарные доходы/расходы за месяц). Расширенная аналитика и прогнозы доступны в Pro. Например, детальная статистика по времени (помесячные тренды, разбивка дня по сферам), по финансам (анализ категорий, уведомления о превышении бюджета) и по целям (вклад каждой задачи в прогресс цели) будут эксклюзивом Pro-подписки.

Финансовые счета и бюджеты: Бесплатный пользователь может вести только один счёт (кошелёк) для учёта финансов; функция добавления нескольких счетов открывается на Pro-тарифе. Также в Free доступен лишь простой месячный бюджет (общий лимит расходов на месяц). Настройка нескольких бюджетов (например, отдельные лимиты по категориям) и продвинутые финансовые функции планирования доступны в Pro.

Количество целей и задач: В бесплатном плане предусмотрены ограничения на масштаб использования. Например, можно активно вести не более 5 целей одновременно; создание большего числа целей требует перехода на Pro. По задачам ограничение может составлять 100 активных задач (попытка добавить свыше покажет уведомление о необходимой подписке). В Pro-версии ограничения на количество целей и задач сняты (можно вести неограниченно проектов и задач). Примечание: сами базовые функции создания/редактирования задач и целей есть в обеих версиях – речь идёт лишь об ограничении объёма данных.

Дополнительные функции и сервисы: Некоторые возможности, не критичные для ядра, зарезервированы за Pro. Например, шаблоны расписаний и повторяющихся задач, а также расширенные правила планирования (тонкая настройка условий, когда планировщик может назначать задачи) отнесены к Pro-тарифу. Приоритетная поддержка (более быстрый ответ службы поддержки) также доступна только Pro-подписчикам. Мультиязычность и веб-версия планируются как часть развития Pro-предложения в будущем. На этапе MVP приложение доступно на русском языке, веб-интерфейс отсутствует для всех пользователей.

Trial-период: Новый пользователь может активировать бесплатный Trial (пробный период) продолжительностью 7–14 дней. На время Trial доступны все Pro-функции (AI, расширенные отчёты и др.) в полном объёме, что позволяет оценить преимущества платного тарифа. После окончания Trial функциональность откатывается до Free, если пользователь не оформит платную подписку.

========================================
FILE: ./Docs/LifeMerge/01_Product/Product_Vision/Competitors_Comparison.md
========================================

# Сравнение с конкурентами

| Продукт | Сильные стороны | Ограничения | Что делаем иначе |
|---------|-----------------|-------------|------------------|
| Todoist | Простота задач, кроссплатформенность | Нет финансов и календаря, AI ограничен | Единая связка задачи+календарь+финансы, локализация СНГ |
| Notion | Гибкость, базы данных | Высокий порог входа, нет готовых шаблонов календаря/финансов | Готовые сценарии, мобильный UX, автоматизация AI |
| Google Calendar | Стабильная синхронизация событий | Нет целей/задач/финансов | Добавляем управление задачами и целями поверх календаря |
| YNAB/Дзен-мани | Глубокий финучёт | Нет задач/целей/AI | Объединяем финансы с планированием времени и целей |


========================================
FILE: ./Docs/LifeMerge/01_Product/Product_Vision/Personas/Persona_1.md
========================================

# Персона 1: Мария, 32, продакт-менеджер

- Живёт в Москве, работает в ИТ, совмещает работу, спорт, личные проекты.
- Боли: много встреч, задачи разлетаются по почте/мессенджерам, нет связки с личными финансами.
- Цели: успевать тренироваться 3 раза в неделю, закрывать квартальные OKR, копить на отпуск.
- Как помогает LifeMerge: планирует неделю с учётом встреч, видит нагрузку по дням, отслеживает расходы и бюджет, AI предлагает фокус-задачи.


========================================
FILE: ./Docs/LifeMerge/01_Product/Product_Vision/Personas/Persona_2.md
========================================

# Персона 2: Алексей, 28, врач-ординатор

- Работает по сменам, часто меняется график, нужно планировать экзамены и личные дела.
- Боли: отсутствие единого календаря смен, забывает оплачивать счета, нет времени распределять учебные задачи.
- Цели: пройти курс повышения, сдать экзамен, контролировать расходы.
- Как помогает LifeMerge: синхронизирует смены в календаре, напоминает о платежах, предлагает слоты для учёбы и отдыха.


========================================
FILE: ./Docs/LifeMerge/01_Product/Product_Vision/Personas/Persona_3.md
========================================

# Персона 3: Ирина, 35, предприниматель

- Управляет небольшим интернет-магазином, много задач по команде, финансам и маркетингу.
- Боли: хаос в задачах, сложность видеть кассовые разрывы, нет времени на стратегические цели.
- Цели: увеличить выручку, запустить новые продукты, держать личный баланс работы и семьи.
- Как помогает LifeMerge: объединяет задачи по проектам, показывает бюджет и прогноз расходов, AI помогает распределить время между бизнесом и семьёй.


========================================
FILE: ./Docs/LifeMerge/01_Product/Product_Vision/Product_Vision.md
========================================

# ✅ **PRODUCT VISION — версия 1.0 для LifeMerge (рабочее название)**

*Кроссплатформенное приложение для интегрированного управления временем, целями и финансами.*

# **1. Назначение продукта (Purpose)**

LifeMerge создаётся как **операционная система жизни для молодых профессионалов 25–40 лет**, совмещающих работу, саморазвитие, личные проекты, здоровье и финансовые цели.
Основная ценность продукта:

### **«Живи осознанно. Управляй всем. Достигай большего.»**

Это не просто планировщик задач — это интегрированная среда, объединяющая:

* **время**,
* **цели**,
* **деньги**,
* **энергию**,
* **приоритеты**,
* **и прогресс пользователя в разных сферах жизни**.

---

# **2. Видение (Vision Statement)**

LifeMerge создаёт единое пространство, где человек понимает:

* что он делает,
* почему он это делает,
* сколько это стоит (во времени, энергии и деньгах),
* и как это приближает его к личным и профессиональным целям.

Приложение помогает превратить жизнь из хаотичного списка задач в **систему, работающую на долгосрочный рост**.

---

# **3. Проблема, которую решает продукт**

Пользователи 25–40 из СНГ часто сталкиваются с:

1. **Фрагментацией информации**

   * расписание в одном приложении,
   * финансы — в другом,
   * цели — в третьем,
   * заметки/идеи — в четвёртом.

Это создаёт перегрузку контекстом и отсутствие общей картины.

2. **Перегрузкой обязанностями**
   Работа, семья, здоровье, саморазвитие — всё требует внимания одновременно.

3. **Нестабильностью среды**
   Непредсказуемый график, переработки, финансовые колебания, инфляция, валютные риски.

4. **Прокрастинацией и слабой связью задач с реальными целями**
   Большинство приложений не показывают: *как ежедневные действия влияют на долгосрочные цели*.

5. **Отсутствием персонализированных рекомендаций**
   Классические планировщики не анализируют:

* энергию,
* контексты,
* сменные графики,
* финансовую нагрузку,
* временные ограничения.

LifeMerge решает всё это в единой системе.

---

# **4. Уникальное ценностное предложение (UVP)**

### **LifeMerge — первый в СНГ интегрированный планировщик, который объединяет цели, время и деньги в одном месте и использует AI как продвинутого ассистента.**

**Ключевые отличия:**

* Календарь — **центр продукта**, а не дополнение к задачам.
* Задачи автоматически связаны с целями, временем и финансовыми последствиями.
* Поддержка сложных графиков (2/2, 3/3, ночные смены).
* Финансовый слой встроен в ежедневное планирование.
* Аналитика показывает реальную взаимосвязь сфер жизни.
* AI строго следует пользовательским правилам (этика контроля).

---

# **5. Целевая аудитория**

### **Основная:**

* Возраст: **25–40**
* Регионы: страны СНГ
* Профиль:

  * молодые специалисты,
  * менеджеры,
  * IT-специалисты,
  * медики,
  * специалисты сменных профессий,
  * фрилансеры,
  * предприниматели.

### **Психографика:**

* амбициозные,
* ценят самосовершенствование,
* живут в многозадачном мире,
* стремятся к порядку, но не хотят тратить много сил на рутину,
* ищут систему, которая *понимает их жизнь*, а не просто хранит данные.

---

# **6. Ключевые функции продукта**

### **1) Календарь нового поколения**

* Гибкие рабочие графики: **5/2, 2/2, 3/3, ночные смены, пользовательские циклы**
* Учёт дороги
* Параллельные активности
* Временные блоки, связанные с целями и финансами
* Drag&drop, умная раскладка, шаблоны расписаний

### **2) Интегрированные задачи и цели**

* Задачи привязаны к целям
* Поддержка разовых, регулярных и дробимых задач
* Приоритеты, контексты, энергозатраты
* Цели → проекты → задачи → календарь → аналитика

### **3) Финансовый модуль**

* Доходы/расходы
* Регулярные платежи
* «Финансовые события» в календаре
* Прогноз бюджета
* Несколько счетов (Pro)
* Категории расходов СНГ
* Учет валют и инфляции

### **4) GTD-фреймворк**

* Входящие (Inbox)
* Обработка и превращение элементов в задачи/цели/события
* AI-подсказки в Pro-версии

### **5) AI Pro-функции**

* Умный планировщик задач
* Рекомендации по продуктивности
* Финансовая аналитика и предупреждения
* Предложения по структуре целей
* Будущий режим полуавтономного планирования

---

# **7. Продуктовая стратегия (High-level)**

### **Free — ядро системы**

* Календарь
* Базовые задачи
* Цели
* Простая финансовая учётка
* GTD и Inbox
* Базовые отчёты

### **Pro — автоматизация жизни**

* AI
* Расширенная аналитика
* Прогнозы
* Счета и бюджеты
* Шаблоны
* Расширенные правила планирования
* Приоритетная поддержка
* Мультиязычность + Web

### **Trial**

* 7–14 дней
* Активируется после привязки карты
* Демонстрация полной мощности экосистемы

---

# **8. Дизайн-принципы**

### **1) Осознанность > визуальный шум**

Минимализм, пространство, структурность.

### **2) 70% Notion + 30% Apple**

* строгая сетка, простота, модульность
* плавность, микроанимации, depth, слабые градиенты

### **3) Прозрачность логики**

Пользователь всегда понимает, *почему* AI сделал предложение.

### **4) Контроль остаётся у пользователя**

AI — помощник, а не оператор.

### **5) Данные — главный контент**

Минимум иллюстраций, максимум аналитики и смысла.

---

# **9. Ключевые метрики успеха**

### **North Star Metric (NSM):**

**Weekly Productive Engagement (WPE)**
= количество пользователей, которые в течение недели **создают задачи + планируют время + взаимодействуют с аналитикой**.

То есть не просто открывают приложение, а реально *живут в нём*.

### **Сопутствующие метрики:**

* 7- / 30-day Retention
* Количество запланированных задач в календаре
* Количество целей с привязанными задачами
* Частота использования AI-планировщика
* LTV / CAC Ratio
* Конверсия Free → Trial → Pro
* Доля пользователей, использующих 3+ сферы (время + цели + финансы)

---

# **10. Долгосрочное видение (3–5 лет)**

### **Life OS уровня СНГ**

Платформа, которая объединяет всё:

* время
* цели
* финансы
* здоровье
* energy management
* AI-планировщик
* автоматизация рутин

### **AI-агент уровня персонального помощника**

Понимает контексты, даёт советы, анализирует состояние дел, прогнозирует будущее.
Автономность — опциональна, под контролем пользователя.

### **Экосистема из мобильного, веба и десктопа**

Единый Pro-доступ на всех устройствах.


========================================
FILE: ./Docs/LifeMerge/01_Product/Product_Vision/Value_Proposition.md
========================================

# Ценностное предложение

LifeMerge экономит время и деньги, объединяя планирование задач, целей и финансов в одном приложении. Пользователь видит, куда уходит время и бюджет, и получает AI-подсказки, как двигаться к целям.

**Ключевые выгоды:**
- Единый поток: из inbox → задачи → календарь → цели.
- Контроль ресурсов: время, энергия, деньги в одном месте.
- Умные рекомендации: AI предлагает расписание недели и советы по приоритетам.
- Офлайн и локализация под СНГ, привычные валюты.


========================================
FILE: ./Docs/LifeMerge/01_Product/Roadmap/Roadmap_Pro_Stages.md
========================================

# Roadmap Pro (beyond MVP)

1. **Collaboration**
   - Шеринг задач/проектов, комментарии, упоминания, история изменений.
2. **Automation & Integrations**
   - Интеграции с таск-трекерами (Jira/Trello), банковскими сервисами (для автоимпорта расходов).
   - Правила: если задача просрочена → предложить слот, если бюджет превышен → уведомление.
3. **Advanced AI**
   - Голосовые команды, чат-помощник, прогноз достижимости целей, персональные эксперименты A/B.
4. **Web/Desktop**
   - Веб-версия и десктоп-клиенты, синхронизация с мобильным приложением.
5. **Монетизация**
   - Pro-подписка: расширенные отчёты, совместная работа, дополнительные интеграции.


========================================
FILE: ./Docs/LifeMerge/01_Product/Roadmap/Roadmap_Stages.md
========================================

# 🚀 **ROADMAP (Этапы развития LifeMerge)**

**MVP → Pro 1.0 → Pro 2.0 → Autonomy Mode**

---

# 🟩 **Этап 1 — MVP (Product Foundations & Validation)**

Главная цель: **проверить ядро продукта и ценность интеграции времени, целей и финансов**.

---

## 🎯 1. Основные модули

* Календарь (день/неделя)
* Сменные графики (5/2, 2/2, 3/3)
* Inbox (GTD)
* Задачи + цели (базово)
* Финансы (базовый доход/расход + регулярные операции)
* Привязка задач/финансов к календарю

---

## 🤖 2. AI — ограниченный

* Умный планировщик задач (первая версия)
* Соблюдение базовых правил:

  * не планировать в поздние часы,
  * запретные дни,
  * буфер между задачами.

---

## 💳 3. Подписки и Trial

* Trial при привязке карты
* Тарифы Free / Pro
* Ограниченные Pro-функции: AI, выделенная аналитика

---

## 🔔 4. Уведомления

* Напоминания о событиях
* Дедлайны задач
* Финансовые события (зарплата, платежи)

---

## 📊 5. Аналитика (базовая)

* Часы задач по категориям
* Доход/расход за месяц
* Прогноз бюджета (простая модель)

---

## 🧱 6. Архитектура

* Локальный кэш + отложенная синхронизация
* Инфраструктура мультиязычности (только RU)
* Готовность к Web (responsive-компоненты)

---

## 🧪 7. Цели этапа

* Проверка product-market fit
* Измерение retention 7/30
* Оценка использования AI-планировщика
* Выявление лидирующих сценариев (календарь vs цели vs финансы)

---

---

# 🟦 **Этап 2 — Pro 1.0 (Automation & Insights Layer)**

Главная цель: **повысить ценность Pro-тарифа, усилить аналитику и автоматизацию**.

---

## 🔥 1. Расширенная аналитика

### Время:

* Разбивка дня по сферам (работа/спорт/личное)
* Почасовая продуктивность
* Недельные и месячные отчёты

### Цели:

* Динамика прогресса
* «Вклад задач» в цели
* velocity (скорость выполнения задач)

### Финансы:

* Анализ категорий
* Week-over-week spending
* Зоны риска (категории, превышающие план)

---

## ⚙️ 2. Расширенные правила планирования (Pro)

* Мягкие и жёсткие запреты (например, «после 20:00 — только лёгкие задачи»)
* Лимиты по контексту день/неделя
* Распределение задач по приоритету
* Система weighting (весовые коэффициенты для AI)

---

## 🤖 3. AI Planner 2.0

* Учет энергии (лёгкие/тяжёлые задачи)
* Учет road time (переезды)
* Улучшенные алгоритмы распределения
* Гибкое редактирование предложенного плана

---

## 🧭 4. Улучшения календаря

* Режим «Месяц» в полной версии
* Быстрые шаблоны расписания
* История изменений (undo для сессий AI)

---

## 🛠 5. Улучшения GTD

* Интеллектуальные подсказки при обработке Inbox (не авто-категоризация, а рекомендации)
* Связка Inbox ↔ Проекты

---

## 🧪 6. Цели этапа

* Рост конверсии Free → Pro
* Формирование привычки «недельного планирования»
* Увеличение времени взаимодействия с задачами/целями

---

---

# 🟧 **Этап 3 — Pro 2.0 (Life Intelligence Layer)**

Главная цель: **создать интеллектуальный слой, который соединяет цели, время и деньги в единую картину жизни**.

---

## 🔗 1. Межсферная аналитика (ключевое отличие LifeMerge)

* «Как переработки влияют на здоровье/цели/бюджет»
* «Как часто финансовые стрессоры нарушают выполнение задач»
* «Как изменения в графике влияют на выполнение проектов»

---

## 🧠 2. AI-советник (Pro)

### Продуктивность:

* рекомендации по распределению задач,
* советы по концентрации,
* анализ паттернов работы.

### Финансы:

* предупреждения о превышении бюджета,
* рекомендации по перераспределению средств,
* поиск аномалий.

### Цели:

* рекомендация структуры целей,
* выявление «мертвых зон» (цели без задач),
* автоматическое создание подключаемых «дорожных карт».

---

## 🤖 3. Smart Context Awareness

* AI учитывает контекст:

  * где находится пользователь,
  * свободные временные окна,
  * привычки дня недели.
* Пример: «У тебя окно 45 минут, доступные задачи из контекста @телефон — хочешь выбрать одну?»

---

## 📲 4. Web-версия (Pro)

* Полноценный интерфейс
* Двухпанельный режим (список + календарь)
* Отчёты + работа с AI

---

## 📊 5. Финансовые улучшения

* Поддержка нескольких счетов
* Простая интеграция с банками (ручная загрузка CSV/экспорт)
* Планирование бюджета на квартал/год
* Мультивалютность + модели инфляции

---

## 🧪 6. Цели этапа

* Повышение LTV
* Перевод Pro в категорию «незаменимого ассистента»
* Повышение accuracy AI

---

---

# 🟥 **Этап 4 — Autonomy Mode (SuperPro / AI Life OS)**

Главная цель: **частичная автономность планирования жизни под контролем пользователя**.

---

## 🤖 1. Автономный режим планирования (опциональный)

AI может автоматически:

* распределять рутинные задачи,
* оптимизировать слотирование задач под цели,
* учитывать нагрузку и баланс сфер,
* корректировать план на основе новых событий.

### Контроль:

* Пользователь всегда подтверждает авто-изменения.
* Есть «история решений» AI.

---

## 🔄 2. Self-Adjusting Policy Engine

Алгоритмы, автоматически адаптирующиеся под паттерны пользователя:

* когда он наиболее продуктивен,
* когда он чаще переносит задачи,
* когда он тратит больше денег,
* как меняется энергия в течение недели.

AI подстраивает:

* буферы,
* время для тяжёлых задач,
* бюджеты,
* нагрузки по сферам.

---

## 🌐 3. Полная интеграция с экосистемами Apple/Google

* HealthKit / Google Fit для энергии и сна
* Calendar API для внешних событий
* Shortcuts / Automations
* Умные виджеты на iOS/Android

---

## 💸 4. Финансовая автономность

* автоматическая категоризация транзакций (где разрешено)
* прогнозы на основе ML
* предупреждения о рисках по целям («не уложитесь в бюджет проекта»)

---

## 🧠 5. LifeMerge Genome (личная модель пользователя)

LLM-ориентированная модель, которая знает:

* поведение,
* ритмы,
* предпочтения,
* цели,
* стиль работы,
* финансовые привычки.

Это даёт:

* гиперперсонализированные рекомендации,
* стратегическое планирование («через 6 месяцев вы достигнете X, если продолжите темп Y»).

---

## 🎯 6. Цели этапа

* Создать продукт, который работает *не вместо человека*, а *за человека*, под его контролем.
* Стать лучшим AI-Life-OS в СНГ.

---

# 📌 Сводная таблица Roadmap

| Этап              | Основные улучшения                                           | AI-уровень    | Ценность                      |
| ----------------- | ------------------------------------------------------------ | ------------- | ----------------------------- |
| **MVP**           | Календарь, задачи, финансы, базовый AI                       | Planner v1    | Проверка ядра                 |
| **Pro 1.0**       | Расширенная аналитика, правила, Planner v2                   | Context rules | Monetization power            |
| **Pro 2.0**       | Межсферная аналитика, Smart Context, Web                     | Advisor       | Жизненная система             |
| **Autonomy Mode** | Частичное авто-планирование, интеграции, персональная модель | Autonomous AI | AI-операционная система жизни |



========================================
FILE: ./Docs/LifeMerge/01_Product/User_Stories/User_Stories_All.md
========================================

# 📘 **USER STORIES — LifeMerge MVP**

---

## 🎯 Обязательные функциональные требования MVP

- **Регистрация и онбординг:** US-REG-001…003, US-ONB-001…003. Обязательны email + пароль, восстановление через письмо, онбординг-мастер из 3–5 шагов с выбором рабочего графика и предложением Trial без привязки карты.
- **Календарь и расписание:** US-CAL-001…009. Поддержка режимов «День/Неделя», создание/редактирование/перетаскивание событий, параллельные слоты, отображение сменного графика, учёт дороги, напоминания и привязка задач.
- **Задачи, цели, проекты:** US-TASK-001…007. Создание задач с приоритетом/контекстом/дедлайном, цели/проекты, привязка задач к целям, отображение прогресса, базовая фильтрация, дробление и повторяемость задач.
- **Финансы:** US-FIN-001…005. Добавление доходов/расходов с категориями, регулярные операции, календарные связи и месячная сводка.
- **Inbox (GTD):** US-INB-001…004. Быстрый ввод, преобразование в задачу или цель, последовательная обработка.
- **AI (Pro):** US-AI-001…003. Планировщик доступен только в Pro/Trial, учитывает рабочий график и уже забронированные события, финальное расписание подтверждается пользователем.
- **Подписки и Trial:** US-SUB-001…004. Прозрачный просмотр тарифов, запуск Trial без списания, отображение статуса, понятные ограничения Free.
- **Уведомления:** US-NOT-001…003. Получение системного разрешения, напоминания о событиях/финансах/задачах с настраиваемым упреждением, возможность отключать категории.
- **Offline & синхронизация:** US-OFF-001…003. Просмотр кэша и создание/редактирование сущностей офлайн с отложенной синхронизацией и индикацией статуса.
- **Настройки и профиль:** US-SET-001…004. Изменение рабочего графика, часового пояса, уведомлений; переключение темы как пользовательская опция.

---

# 1. Регистрация, логин, онбординг

## 1.1. Регистрация аккаунта

**US-REG-001**
**Как** новый пользователь,
**я хочу** зарегистрироваться по email и паролю,
**чтобы** получить доступ к своим данным и синхронизации на всех устройствах.

**Acceptance Criteria:**

* Поля email и пароль обязательные.
* Ошибка при некорректном email.
* Ошибка при слишком коротком пароле.
* После регистрации пользователь автоматически авторизуется.

---

## 1.2. Вход в аккаунт

**US-REG-002**
Как пользователь,
я хочу войти по email и паролю,
чтобы получить доступ к своему профилю и данным.

**Acceptance Criteria:**

* Валидация формата email и минимальной длины пароля.
* Ошибка при неверных учётных данных.
* После успешного входа данные профиля и календаря синхронизируются.
* Сессия сохраняется до выхода или истечения токена.

---

## 1.3. Восстановление пароля

**US-REG-003**
Как пользователь,
я хочу восстановить пароль через email,
чтобы вернуть доступ в аккаунт.

**Acceptance Criteria:**

* Ввод email с валидацией формата.
* Отправка письма с одноразовой ссылкой или кодом.
* Установка нового пароля после перехода по ссылке.
* Сообщение об успехе или ошибке (не раскрывающее наличие аккаунта).

---

## 1.4. Первичный онбординг

**US-ONB-001**
Как новый пользователь,
я хочу пройти онбординг с кратким объяснением ценности приложения,
чтобы понять, чем LifeMerge может мне помочь.

**Acceptance Criteria:**

* Серия из 3–5 экранов с навигацией «вперёд/назад» и прогресс-баром.
* Возможность пропустить онбординг и вернуться к нему через настройки.
* Последний шаг ведёт к настройке графика и предложению Trial.

---

## 1.5. Настройка рабочего графика при онбординге

**US-ONB-002**
Как пользователь,
я хочу выбрать свой рабочий график (5/2, 2/2, 3/3, пользовательский),
чтобы календарь корректно отражал моё расписание.

**Acceptance Criteria:**

* Пресеты смен 5/2, 2/2, 3/3 + кастом со временем начала/длительностью смены.
* Предпросмотр того, как график отобразится в календаре.
* Сохранённый график влияет на все будущие дни календаря.

---

## 1.6. Предложение активировать Pro Trial

**US-ONB-003**
Как новый пользователь,
я хочу увидеть предложение активировать Pro Trial,
чтобы попробовать продвинутые функции перед покупкой.

**Acceptance Criteria:**

* Trial доступен без привязки карты (достаточно подтвердить email/аккаунт магазина).
* Есть понятное описание того, что включено в Pro.
* Пользователь может отложить активацию и вернуться через настройки/профиль.

---

# 2. Календарь и расписание

## 2.1. Просмотр календаря в режиме «День»

**US-CAL-001**
Как пользователь,
я хочу видеть свой день в виде таймлайна,
чтобы понимать, какие события меня ждут.

**Acceptance Criteria:**

* Интервалы не мельче 15 минут, доступна прокрутка по времени.
* Отображаются пересекающиеся события и время на дорогу между ними.
* Быстрый переход к текущему времени.

---

## 2.2. Просмотр календаря в режиме «Неделя»

**US-CAL-002**
Как пользователь,
я хочу видеть неделю целиком,
чтобы планировать распределение задач.

**Acceptance Criteria:**

* Неделя начинается с выбранного в настройках дня.
* События отображаются с укрупнёнными слотами и поддержкой зума.
* Есть переключение между «День» ↔ «Неделя» без потери контекста даты.

---

## 2.3. Создание события

**US-CAL-003**
Как пользователь,
я хочу создавать события в календаре,
чтобы фиксировать обязательные активности (работа, тренировки, встречи).

**Acceptance Criteria:**

* Обязательные поля: название, дата, время начала и длительность/конец.
* Можно указать локацию и категорию/тип события.
* Событие создаётся как из пустого слота, так и через кнопку «+».

---

## 2.4. Перемещение события (drag & drop)

**US-CAL-004**
Как пользователь,
я хочу перетаскивать события в календаре,
чтобы быстро изменять расписание.

**Acceptance Criteria:**

* Поддержка drag & drop в режимах «День» и «Неделя».
* При перемещении учитывается время на дорогу и предупреждение о конфликте.
* После подтверждения событие пересохраняется с новой датой/временем.

---

## 2.5. Параллельные события

**US-CAL-005**
Как пользователь,
я хочу иметь возможность создания нескольких событий в одно и то же время,
чтобы учитывать многозадачные процессы (например, аудиокурс во время уборки).

---

## 2.6. Отображение рабочего графика (смены)

**US-CAL-006**
Как пользователь,
я хочу, чтобы мой сменный график отображался в календаре автоматически,
чтобы всегда видеть рабочие и выходные дни.

**Acceptance Criteria:**

* Шаблон смены из настроек наносится на календарь на ближайшие 90 дней.
* Рабочие дни визуально отличаются от выходных.
* При обновлении графика расписание пересчитывается.

---

## 2.7. Учёт времени на дорогу

**US-CAL-007**
Как пользователь,
я хочу добавлять время дороги между событиями,
чтобы планирование было реалистичным.

**Acceptance Criteria:**

* Время на дорогу задаётся вручную или из пресетов (15/30/45/60 минут).
* В расписании отображается как отдельный слот между событиями.
* При перемещении исходных событий дорожные слоты сдвигаются.

---

## 2.8. Привязка задачи к календарю

**US-CAL-008**
Как пользователь,
я хочу привязывать задачу к конкретному времени,
чтобы планировать выполнение задач в контексте расписания.

**Acceptance Criteria:**

* Задачу можно назначить на свободный слот или на существующее событие.
* Ссылка на задачу видна в карточке события и на таймлайне.
* Из календаря можно открыть карточку задачи.

---

## 2.9. Напоминания о событиях

**US-CAL-009**
Как пользователь,
я хочу получать уведомления о начале событий,
чтобы не забывать о встречах и обязательствах.

**Acceptance Criteria:**

* По умолчанию уведомление за 15 минут, пользователь может выбрать другие опции.
* Push приходит даже при закрытом приложении (если разрешение выдано).
* Уведомление ведёт к экрану события.

---

# 3. Задачи, цели, проекты

## 3.1. Создание задачи

**US-TASK-001**
Как пользователь,
я хочу создавать задачи с приоритетами, контекстами и дедлайнами,
чтобы эффективно организовать свою деятельность.

---

## 3.2. Создание проекта / цели

**US-TASK-002**
Как пользователь,
я хочу создавать цели и проекты,
чтобы структурировать долгосрочные намерения.

---

## 3.3. Привязка задачи к цели

**US-TASK-003**
Как пользователь,
я хочу связывать задачи с целями,
чтобы видеть вклад действий в итоговый результат.

---

## 3.4. Отображение прогресса цели

**US-TASK-004**
Как пользователь,
я хочу видеть процент выполнения цели,
чтобы отслеживать продвижение.

---

## 3.5. Фильтрация задач

**US-TASK-005**
Как пользователь,
я хочу фильтровать задачи по приоритету, контексту и проекту,
чтобы быстро находить нужные элементы.

---

## 3.6. Дробимые задачи

**US-TASK-006**
Как пользователь,
я хочу разбивать большую задачу на несколько временных слотов,
чтобы гибко распределять нагрузку.

---

## 3.7. Регулярные задачи

**US-TASK-007**
Как пользователь,
я хочу создавать повторяющиеся задачи,
чтобы автоматизировать рутину.

---

# 4. Финансы

## 4.1. Создание расхода

**US-FIN-001**
Как пользователь,
я хочу добавлять расходы с категорией и суммой,
чтобы вести учёт финансов.

---

## 4.2. Создание дохода

**US-FIN-002**
Как пользователь,
я хочу фиксировать доходы,
чтобы видеть баланс месяца.

---

## 4.3. Привязка финансового события к календарю

**US-FIN-003**
Как пользователь,
я хочу привязывать финансовые операции к календарным событиям,
чтобы видеть, как деньги связаны со временем.

---

## 4.4. Регулярные операции

**US-FIN-004**
Как пользователь,
я хочу создавать регулярные доходы/расходы,
чтобы не вводить их вручную каждый месяц.

---

## 4.5. Просмотр месячного финансового отчёта

**US-FIN-005**
Как пользователь,
я хочу видеть сводку (доходы, расходы, баланс),
чтобы понимать финансовое состояние.

---

## 4.6. Уведомления о предстоящих финансовых событиях

**US-FIN-006**
Как пользователь,
я хочу получать пуш-уведомления о важной финансовой активности,
чтобы ничего не пропускать.

---

# 5. GTD: Inbox

## 5.1. Добавление элемента во входящие

**US-INB-001**
Как пользователь,
я хочу быстро добавлять идеи/заметки в Inbox,
чтобы не держать их в голове.

---

## 5.2. Превращение элемента Inbox в задачу

**US-INB-002**
Как пользователь,
я хочу превращать элемент Inbox в задачу,
чтобы он становился частью моего рабочего процесса.

---

## 5.3. Превращение элемента Inbox в цель

**US-INB-003**
Как пользователь,
я хочу создавать цели на основе элементов Inbox,
чтобы быстро оформлять долгосрочные планы.

---

## 5.4. Обработка Inbox

**US-INB-004**
Как пользователь,
я хочу просматривать элементы Inbox по одному,
чтобы принимать решения о дальнейших действиях.

---

# 6. AI (Pro)

## 6.1. Запуск AI-планировщика

**US-AI-001**
Как Pro-пользователь,
я хочу запустить умный планировщик задач,
чтобы получить оптимальное распределение нагрузки.

---

## 6.2. Получение предложенного плана

**US-AI-002**
Как Pro-пользователь,
я хочу увидеть предложенный AI-план,
чтобы сравнить его со своим расписанием.

---

## 6.3. Принятие/Частичное принятие/Отмена плана

**US-AI-003**
Как Pro-пользователь,
я хочу принимать или отклонять предложения AI,
чтобы сохранять контроль над своим временем.

---

## 6.4. Пользовательские правила для AI

**US-AI-004**
Как Pro-пользователь,
я хочу задавать правила (не планировать поздно, перерывы, запреты по дням),
чтобы AI подстраивался под мои предпочтения.

---

# 7. Подписки и Trial

## 7.1. Просмотр тарифов

**US-SUB-001**
Как пользователь,
я хочу видеть различия между Free и Pro,
чтобы понять смысл апгрейда.

---

## 7.2. Активация Trial

**US-SUB-002**
Как новый пользователь,
я хочу активировать Trial без привязки карты,
чтобы протестировать все Pro-функции.

**Acceptance Criteria:**

* Trial запускается по кнопке из онбординга или экрана тарифов.
* На экране указаны длительность Trial и дата автоотмены/окончания.
* В течение Trial доступны все Pro-функции, после — откат к Free без списания.

---

## 7.3. Просмотр статуса подписки

**US-SUB-003**
Как пользователь,
я хочу видеть мой текущий тариф и дату списания,
чтобы управлять подпиской.

**Acceptance Criteria:**

* На экране статуса отображаются тариф, срок действия, дата следующего списания/окончания Trial.
* Есть кнопки продления/отмены (по платформенным правилам).
* Для Free — подсказки, какие функции недоступны.

---

## 7.4. Ограничения Free (UX)

**US-SUB-004**
Как пользователь Free,
я хочу видеть прозрачные ограничения (например, «AI доступен в Pro»),
чтобы понимать, что даёт апгрейд.

**Acceptance Criteria:**

* Маркеры «Pro» видны в интерфейсе у недоступных функций.
* Переход по маркеру ведёт на экран тарифов.
* Ограничения не блокируют базовые сценарии Free.

---

# 8. Уведомления

## 8.1. Разрешение на уведомления

**US-NOT-001**
Как пользователь,
я хочу дать приложению разрешение на уведомления,
чтобы получать напоминания о задачах и событиях.

**Acceptance Criteria:**

* Системный диалог запрашивается один раз и повторно только по запросу пользователя.
* Отклонённое разрешение отображается как статус с инструкцией, как включить его в настройках устройства.
* Без разрешения напоминания не создаются и пользователь получает подсказку.

---

## 8.2. Получение напоминаний о событиях

**US-NOT-002**
Как пользователь,
я хочу получать уведомление за 15 минут до начала события,
чтобы ничего не пропускать.

**Acceptance Criteria:**

* Настраиваемое время упреждения: 5/15/30/60 минут и «в момент».
* Напоминание создаётся автоматически при создании события, если разрешения выданы.
* Тап по уведомлению открывает событие в календаре.

---

## 8.3. Управление уведомлениями

**US-NOT-003**
Как пользователь,
я хочу отключать и включать категории уведомлений,
чтобы контролировать информационный поток.

**Acceptance Criteria:**

* Отдельные переключатели для событий, задач, финансовых напоминаний и системных сообщений.
* Настройки синхронизируются между устройствами.
* Изменение настроек применяется к будущим уведомлениям.

---

# 9. Offline & Синхронизация

## 9.1. Работа без интернета (кэш)

**US-OFF-001**
Как пользователь,
я хочу иметь возможность продолжать работу без интернета,
чтобы приложение не блокировало меня.

**Acceptance Criteria:**

* Последние данные календаря/задач/финансов доступны из локального кэша.
* Созданные/изменённые сущности ставятся в очередь синхронизации.
* Пользователь видит, какие действия находятся «в очереди».

---

## 9.2. Отложенная синхронизация

**US-OFF-002**
Как пользователь,
я хочу, чтобы действия автоматически отправлялись на сервер после восстановления сети,
чтобы мне не приходилось делать это вручную.

**Acceptance Criteria:**

* Фоновые попытки синхронизации запускаются при восстановлении соединения.
* При успехе локальный статус действий обновляется без участия пользователя.
* При ошибке отправки отображается уведомление/баннер с возможностью повторить.

---

## 9.3. Оповещение о режиме офлайн

**US-OFF-003**
Как пользователь,
я хочу получать ненавязчивый баннер «Синхронизация отложена»,
чтобы понимать текущее состояние.

**Acceptance Criteria:**

* Баннер показывает статус: «Онлайн», «Оффлайн», «Синхронизация…».
* Баннер не перекрывает основной контент и может быть свернут.
* При переходе в онлайн баннер автоматически обновляется.

---

# 10. Настройки и профиль

## 10.1. Изменение рабочего графика

**US-SET-001**
Как пользователь,
я хочу изменять рабочий график в настройках,
чтобы календарь адаптировался к моей реальной жизни.

---

## 10.2. Переключение темы (Тёмная / Светлая)

**US-SET-002**
Как пользователь,
я хочу управлять темой оформления,
чтобы адаптировать интерфейс под освещение.

---

## 10.3. Изменение уведомлений

**US-SET-003**
Как пользователь,
я хочу настраивать уведомления,
чтобы приложение соответствовало моим привычкам.

---

## 10.4. Изменение временной зоны

**US-SET-004**
Как пользователь,
я хочу изменять часовой пояс,
чтобы корректно отображались все события.

---

# 11. Free / Pro дифференциация

### Free-пользователь может:

* пользоваться календарём;
* создавать задачи и цели;
* пользоваться Inbox;
* вести базовый бюджет;
* получать напоминания;
* видеть базовую аналитику.

### Pro-пользователь получает:

**US-PRO-001** — Доступ к AI-планировщику.
**US-PRO-002** — Расширенную аналитику по времени и финансам.
**US-PRO-003** — Расширенные правила планирования.
**US-PRO-004** — Неограниченное количество целей/проектов (если Free ограничен).
**US-PRO-005** — Приоритетную поддержку.

---

# 12. Autonomy Mode (опциональный AI-режим)

## 12.1. Активация и контроль режима

**US-AUTO-001**
Как пользователь,
я хочу включать/выключать Autonomy Mode через настройки и давать явное согласие на автоизменения,
чтобы автономное планирование включалось только под моим контролем.

**Acceptance Criteria:**

* Режим выключен по умолчанию и требует явного согласия.
* Есть тумблер и экран условий (что будет менять AI).
* Можно поставить на паузу без потери данных.

---

## 12.2. Автопланирование с подтверждением

**US-AUTO-002**
Как пользователь,
я хочу получать пакетные предложения от AI по перераспределению задач и событий,
чтобы быстро применять улучшенный план одним подтверждением.

**Acceptance Criteria:**

* Показывается список изменений (переносы, вставки буферов, отмены).
* Каждое изменение можно принять/отклонить, есть кнопка «Применить всё».
* Применение фиксируется в журнале AI-решений.

---

## 12.3. Self-Adjusting Policy Engine

**US-AUTO-003**
Как пользователь,
я хочу, чтобы AI автоматически подстраивал правила планирования под мои привычки (энергия, переносы, загруженность),
чтобы расписание оставалось реалистичным без ручной настройки.

**Acceptance Criteria:**

* AI обновляет буферы/слоты на основе наблюдаемых паттернов.
* Есть прозрачный лог: какие правила обновлены и почему.
* Можно откатить последние изменения правил.

---

## 12.4. Интеграции для автономности

**US-AUTO-004**
Как пользователь,
я хочу подключать HealthKit/Google Fit и внешние календари,
чтобы AI учитывал сон, активность и сторонние события при автопланировании.

**Acceptance Criteria:**

* Права запрашиваются отдельно для каждого источника.
* Пользователь видит, как данные влияют на предложения (лейблы «сон», «нагрузка», «внешнее событие»).
* Можно временно отключить использование конкретного источника данных.

---

## 12.5. История и безопасность изменений

**US-AUTO-005**
Как пользователь,
я хочу видеть историю действий AI и иметь возможность отката изменений,
чтобы чувствовать контроль над автономным режимом.

**Acceptance Criteria:**

* Есть журнал с датой, причиной и списком изменений.
* Откат возвращает расписание/правила в предыдущее состояние.
* Оповещение при массовых изменениях (например, >5 правок за раз).



========================================
FILE: ./Docs/LifeMerge/01_Product/User_Stories/User_Story_Map.md
========================================

# User Story Map (high-level)

1. **Onboarding**
   - Как новый пользователь, я хочу пройти короткий опрос целей, чтобы получить персональные подсказки.
   - Как пользователь, я хочу импортировать календарь, чтобы сразу видеть свои события.
2. **Plan Day/Week**
   - Как пользователь, я хочу создать задачи и разместить их в календаре, чтобы понимать нагрузку.
   - Как пользователь, я хочу получить AI-предложение расписания недели.
3. **Execute & Track**
   - Как пользователь, я хочу отмечать задачи выполненными и видеть прогресс по целям.
   - Как пользователь, я хочу фиксировать расходы и видеть бюджет.
4. **Review**
   - Как пользователь, я хочу недельный дайджест (выполнено/финансы/цели).
   - Как пользователь, я хочу предложения, что улучшить на следующей неделе.


========================================
FILE: ./Docs/LifeMerge/02_Design/Branding/Brand_Guidelines.md
========================================

# Brand Guidelines

- Название: **LifeMerge** (одно слово, F заглавная).
- Логотип: комбинация волны/потока и чекбокса; в темной теме используем светлый логотип.
- Цвета бренда: primary #5B8DEF, accent #FF9F1C, фон #0F1115.
- Тональность: поддерживающая, практичная, без излишнего пафоса.
- Фото: реальные люди 25–40, работающие и занимающиеся хобби, с тёплым светом.
- Айконсет: линийные иконки 24px с округлыми углами.


========================================
FILE: ./Docs/LifeMerge/02_Design/Interaction_Guidelines.md
========================================

# Interaction Guidelines — LifeMerge (MVP)

*Григорий — Interaction Design / Motion / Micro-interactions*

Документ определяет принципы анимаций, переходов и микро-взаимодействий для MVP LifeMerge. Опираться на UI Kit, тёмную тему, производительность Flutter и общие UX‑паттерны из дизайн-системы.

---

## 1. Цели анимаций в LifeMerge

1. Повысить ясность интерфейса — анимации должны помогать ориентироваться в данных (календарь, задачи, финансы).
2. Передавать тактильность — физические паттерны, реалистичная инерция, лёгкие пружины.
3. Снизить когнитивную нагрузку — направлять внимание, а не привлекать его без причины.
4. Работать в тёмной теме без визуального шума.
5. Быть лёгкими для производительности (60 fps, минимизация слоёв, избегать тяжёлых эффектов).

---

## 2. Паттерны анимаций для MVP

### 2.1. Fade-Scale для появления контента

**Использование:** карточки задач, элементы списков, записи Inbox, модальные окна.

* Время: 120–160 мс
* Кривая: easeOutCubic
* Поведение: лёгкое увеличение от 0.96 → 1.0 + fade 0 → 1
* Flutter: `FadeTransition + ScaleTransition`, без лишних RepaintBoundary

### 2.2. Slide-Fade вертикальный для переходов между вкладками

**Использование:** переключение Home → Calendar → Tasks → Finance.

* Время: 160–200 мс
* Кривая: standard (0.4, 0.0, 0.2, 1)
* Избегать больших параллаксов — акцент на плавности.

### 2.3. Shared Axis (Horizontal) для Calendar / Tasks

**Использование:** переходы между списками задач, карточкой задачи, карточкой события.

* Время: 180–220 мс
* Кривая: easeInOut
* Оси:

  * Горизонталь — для навигации между sibling‑экранами
  * Вертикаль — для переходов уровня вложенности (список → детальная)

### 2.4. Opacity Lift для выделения активного элемента

**Использование:** нажатие на карточку задачи, событие календаря, элемент Inbox.

* Время: 80–120 мс
* Лёгкое повышение яркости и глубины (elevation.sheet → elevation.card)
* Без масштабирования более чем на 1–2%

### 2.5. Animated Drag Feedback

**Использование:** drag & drop событий в Calendar.

* Время обратной связи: < 16 мс (реакция в один кадр)
* Эффект: при захвате — небольшое увеличение 1.00 → 1.04, тень усиливается.
* Возврат при отмене — пружина 180–220 мс.

---

## 3. Переходы для Calendar

### 3.1. День ↔ Неделя

**Цель:** сохранить пространственное восприятие времени.

**Анимация:**

* Изменение высоты таймлайнов с анимацией layout (AnimatedSize).
* События плавно перебираются в новую сетку.
* Duration: 220–260 мс.
* Кривая: easeInOutCubic.

**Рекомендации:**

* Не масштабировать весь экран — изменять лишь сетку.
* Включить hero‑анимацию для текущей временной метки.

### 3.2. Переход список событий → карточка события

**Паттерн:** Shared Axis Vertical.

* Деталь «выезжает» сверху, список слегка затемняется.
* Duration: 180–220 мс.
* Плавный elevation shift.

### 3.3. Drag & Drop: перемещение события

* Захват: тень ↑, масштаб 1.00 → 1.04.
* Перемещение: курсор/палец «ведёт» карточку без задержки.
* Drop: пружина 160–200 мс + небольшой fade на подтверждение.
* Конфликт времени (overlap): короткий красный highlight 80 мс.

---

## 4. Переходы для Tasks

### 4.1. Список задач → карточка задачи

**Паттерн:** Shared Axis Vertical.

* Сжатие списка вниз, карточка поднимается вверх.
* Duration: 200 мс.

### 4.2. Добавление задачи

**Паттерн:** Fade-Scale Up.

* Скейл 0.96 → 1.0 + opacity 0 → 1.
* Duration: 140–160 мс.
* Подчеркнуть момент появления и облегчить восприятие нового элемента.

### 4.3. Отметка «выполнено»

**Паттерн:** Completion Sweep.

* Иконка галочки анимируется sweep‑движением 120 мс.
* Карточка выцветает 1 → 0.4 opacity + лёгкий подъём 4 px.
* Полное исчезновение через 200 мс, если настроено автоскрытие.

### 4.4. Работа с подзадачами

* Раскрытие: height animation (AnimatedSize) 160 мс.
* Чёткая визуальная иерархия за счёт сдвига и линии слева.

---

## 5. Общие принципы Micro‑Interactions

### 5.1. Реалистичные тайминги

* Малые взаимодействия: 80–120 мс.
* Средние переходы: 160–220 мс.
* Большие изменения структуры: 220–300 мс.

### 5.2. Физичность без «пружинности ради пружинности»

* Использовать пружину только для drag/drop и подтверждений.
* Для всего остального — bezier-кривые UI Kit.

### 5.3. Отсутствие лишней хореографии

* Никаких «сложных входов» списков и карточек.
* Ключевой принцип MVP — скорость и визуальная ясность.

### 5.4. Темная тема

* Избегать светящихся элементов.
* Анимации должны работать без изменения контраста.

### 5.5. Производительность

* До 2 одновременно анимируемых свойств: opacity + scale или offset + opacity.
* Layout изменения через AnimatedSize, избегать анимации больших списков.

### 5.6. Обратная связь при ошибках

* Ошибочные состояния — короткий shake или highlight 80 мс.
* Для сетевых ошибок — fade‑banner сверху 200 мс.

---

## 6. Компоненты с обязательными анимациями

* Календарь: drag/drop, переход день⇄неделя, открытие карточки события.
* Задачи: отметка выполнения, открытие карточки, добавление новой.
* Inbox: появление элемента, преобразование в задачу/цель.
* Модальные окна: fade‑scale.

---

## 7. Не допускается

* Масштабирование экрана > 4% — вызывает дезориентацию.
* Избыточные тени на тёмной теме.
* Длительные (>300 мс) переходы в основных сценариях.
* Нелинейные кривые типа bounce для текстовых списков.

---

## 8. Требования к реализации (Flutter)

* Использовать Implicit Animations там, где возможно.
* Для Calendar использовать RepaintBoundary вокруг крупных таймлайнов.
* Обязательный тест performance профилем: 60 fps на Pixel 6 / iPhone 12.
* Анимации должны учитываться в DoD: UI соответствует макетам и спецификациям анимации.

---

## 9. Следующие шаги

1. Утвердить с Lead UI/UX Designer.
2. Синхронизировать с Flutter-командой по реализуемости.
3. Добавить анимации в прототип Figma.
4. Создать библиотеку motion‑токенов (durations, curves).

---

Документ готов к итерациям и расширению для Pro 1.0.


========================================
FILE: ./Docs/LifeMerge/02_Design/Prototypes/Dark_Mode/Readme.md
========================================

# Dark Mode – Prototypes

Здесь хранятся дизайн-спецификации тёмной темы:
- основные экраны,
- компоненты,
- цветовые токены,
- уровни теней и контрастности.

Файлы пригодны для передачи разработчикам.


========================================
FILE: ./Docs/LifeMerge/02_Design/Prototypes/Notes/MVP_Wireframes.md
========================================

Структура MVP_Wireframes.md:

Введение: кратко описано, что ниже приведён список экранов MVP с пояснениями. Указано, что эти экраны отражены в прототипах/wireframes, и что детальные визуальные макеты доступны на странице "Ready for Dev" (с общим линком на файл Figma). Также поясняется система приоритетов (например, P1 – критически необходим для MVP, P2 – желательный, но может быть отложен, если не успеваем).

Список экранов по разделам: экраны сгруппированы по тем же блокам: Auth, Calendar, Tasks:

Auth:

Onboarding_v1 – Цель: познакомить нового пользователя с приложением (welcome-скрины). Приоритет: P1 (высокий), т.к. влияет на конверсию новых пользователей. Figma: Onboarding_v1.

ScheduleSetup_v1 – Цель: сбор данных о графике пользователя для персонализации. Приоритет: P2 (средний) – полезно, но не блокирует MVP, может быть упрощено. Figma: ScheduleSetup_v1.

Register_v1 – Цель: регистрация пользователя. Приоритет: P1. Figma: Register_v1.

Login_v1 – Цель: вход в аккаунт. Приоритет: P1. Figma: Login_v1.

Recovery_v1 – Цель: восстановление пароля. Приоритет: P2. Figma: Recovery_v1.

Calendar:

Calendar_Day_v1 – Цель: показать расписание на день. Приоритет: P1 (основной экран календаря). Figma: Calendar_Day_v1.

Calendar_Week_v1 – Цель: обзор недели. Приоритет: P2 (можно запустить MVP и без недельного вида, но желателен). Figma: Calendar_Week_v1.

Calendar_Month_v1 – Цель: обзор месяца. Приоритет: P2. Figma: Calendar_Month_v1.

Event_New_v1 – Цель: создание нового события. Приоритет: P1 (ядро функционала календаря). Figma: Event_New_v1.

Event_Details_v1 – Цель: просмотр/редактирование события. Приоритет: P1. Figma: Event_Details_v1.

Tasks:

Task_List_v1 – Цель: список всех задач (с фильтрами). Приоритет: P1 (основной экран задач). Figma: Task_List_v1.

Task_Detail_v1 – Цель: детали задачи. Приоритет: P1. Figma: Task_Detail_v1.

Task_Form_v1 – Цель: создание/редактирование задачи. Приоритет: P1. Figma: Task_Form_v1.

(Каждый пункт содержит имя фрейма, краткое описание цели/функции экрана, приоритет и гиперссылку на макет Figma. Ссылки указывают прямо на конкретные фреймы на странице "Ready for Dev".)

Примечания/Допущения: в конце файла приведены общие заметки. Например: «Экран “Week View” отмечен как P2 – может быть реализован во вторую очередь, если сроки поджимают, основной функционал календаря обеспечит Day и Month». Или: «В MVP не включён раздел Finance (финансы) – он в планах на будущее, поэтому в списке отсутствуют соответствующие экраны». Также зафиксировано, что критерий успешности MVP – наличие как минимум одного рабочего сценария для каждой ключевой сущности (задачи, события, цели), и перечисленные экраны этому соответствуют.

Документ MVP_Wireframes.md становится частью проектной документации. Он облегчает коммуникацию: новые члены команды или сторонние участники могут быстро понять, какие экраны будут в первом релизе и почему. При изменениях (scope change) документ обновляется. Кроме того, наличие ссылок на Figma обеспечивает актуальность: всегда можно кликнуть и увидеть последний дизайн соответствующего экрана.

========================================
FILE: ./Docs/LifeMerge/02_Design/Prototypes/Web_Future/Notes/Web_Adaptive_Design_Principles.md
========================================

Здесь пока пусто

========================================
FILE: ./Docs/LifeMerge/02_Design/Prototypes/Web_Future/Notes/Web_Navigation_Concepts.md
========================================

Здесь пока пусто

========================================
FILE: ./Docs/LifeMerge/02_Design/Prototypes/Web_Future/Readme.md
========================================

# Web Future – Prototypes

Папка хранит концепты будущей web-версии LifeMerge:
- адаптивная панель,
- двухпанельный режим,
- календарь и финансы на широких экранах.

Файлы делятся на:
- Wireframes — структурные макеты,
- High_Fidelity — высокодетализированные дизайны,
- Notes — описание UX решений.


========================================
FILE: ./Docs/LifeMerge/02_Design/UI_Kit/Colors.md
========================================

# Цвета

| Токен | Значение | Использование |
|-------|----------|---------------|
| `primary` | #5B8DEF | Кнопки, активные элементы |
| `primaryDark` | #3562C2 | Hover/нажато, тёмная тема |
| `accent` | #FF9F1C | Уведомления, акценты на карточках |
| `success` | #34C759 | Выполнено, позитивные статусы |
| `error` | #FF3B30 | Ошибки, критичные уведомления |
| `bg` | #0F1115 | Фон приложения (dark first) |
| `surface` | #181C22 | Карточки, модальные окна |
| `textPrimary` | #FFFFFF | Основной текст |
| `textSecondary` | #B8C2D1 | Вторичный текст, подписи |


========================================
FILE: ./Docs/LifeMerge/02_Design/UI_Kit/Components/Buttons.md
========================================

# Кнопки

- **Primary**: background `primary`, текст `textPrimary`, радиус `12`, высота `52`. Состояния: default, pressed (`primaryDark`), disabled (20% opacity).
- **Secondary**: обводка `primary`, текст `primary`, фон `surface`. Hover/pressed затемнение 8%.
- **Ghost/Icon**: без рамки, padding 12, иконка 24px.
- Минимальная ширина 120px, tap area 44px.


========================================
FILE: ./Docs/LifeMerge/02_Design/UI_Kit/Components/Cards.md
========================================

# Карточки

- Фон `surface`, радиус `12`, тень `elevation.card`.
- Внутренние отступы: `16` по всем сторонам; между элементами `8`.
- Поддерживаются вариации: задача, событие, финоперация, цель (отличаются иконкой и акцентом).
- Для задач и событий показываем бейдж статуса/источника в правом верхнем углу.


========================================
FILE: ./Docs/LifeMerge/02_Design/UI_Kit/Components/Chips.md
========================================

# Чипсы

- Радиус 16, высота 32, padding 12.
- Варианты: фильтр (toggle), статус (filled), тег (outline).
- Цвета: primary для активных, surface + текст вторичный для неактивных.
- Иконка слева опциональна, крестик для удаления тегов справа.


========================================
FILE: ./Docs/LifeMerge/02_Design/UI_Kit/Components/Inputs.md
========================================

# Поля ввода

- Высота 52, радиус `12`, фон `surface`.
- Обводка 1px `primary` при фокусе, `textSecondary` по умолчанию.
- Подписи/лейблы `Caption`, плейсхолдер вторичным цветом.
- Поддержка иконки слева, кнопки очистки справа.
- Ошибка: обводка и текст `error`, вспомогательный текст под полем.


========================================
FILE: ./Docs/LifeMerge/02_Design/UI_Kit/Components/Modals.md
========================================

# Модальные окна/боттомшиты

- Радиус верхних углов 16, фон `surface`, тень `elevation.sheet`.
- Хэндл для перетягивания 40x4, отступ сверху 8.
- Внутренние отступы 20 по сторонам, кнопки внизу закреплены.
- Поддержка full-screen модалов для создания задач/событий.


========================================
FILE: ./Docs/LifeMerge/02_Design/UI_Kit/Components/Navigation.md
========================================

# Навигация

- Нижняя таб-бар на 5 вкладок: Home, Calendar, Tasks, Finance, AI/Inbox.
- FAB на Home для быстрого создания задачи/события/финоперации.
- Вторичный top-bar с переключением вида календаря (день/неделя/месяц).
- Deeplink из пушей ведёт на конкретную задачу/событие.


========================================
FILE: ./Docs/LifeMerge/02_Design/UI_Kit/Dark_Theme.md
========================================

# Темная тема

- **Dark-first:** интерфейс по умолчанию использует тёмную палитру (`bg`, `surface`), светлая тема не проработана.
- **Контраст:** минимально `4.5:1` для текста и `3:1` для иконок/бордеров. Используем `textPrimary` для основного текста и `textSecondary` для подписи/плейсхолдера.
- **Состояния поверхностей:** hover — осветляем фон на `8%`, pressed — на `12%` (можно через белый overlay), disabled — понижаем непрозрачность до `60%`.
- **Блики и тени:** карточки и модалки опираются на токены `elevation.card` и `elevation.sheet`; избегаем жёстких теней, используем мягкие размытия.
- **Акценты:** `primary` — основной брендовый цвет, `primaryDark` — для hover/pressed и тёмных фоновых элементов; `accent` применяем только для уведомлений и бейджей.
- **Изображения и логотипы:** на тёмном фоне применяем светлые версии логотипа и иллюстраций (см. бренд-гайд).
- **Градиенты и шум:** допускаются лёгкие шумовые/радиальные градиенты на фоне, но без ухудшения читаемости текста.


========================================
FILE: ./Docs/LifeMerge/02_Design/UI_Kit/Design_Tokens.json
========================================

{
  "colors": {
    "primary": "#5B8DEF",
    "primaryDark": "#3562C2",
    "accent": "#FF9F1C",
    "success": "#34C759",
    "error": "#FF3B30",
    "bg": "#0F1115",
    "surface": "#181C22",
    "textPrimary": "#FFFFFF",
    "textSecondary": "#B8C2D1"
  },
  "typography": {
    "fontFamily": "Inter",
    "h1": {"size": 32, "weight": 700, "lineHeight": 38},
    "h2": {"size": 24, "weight": 700, "lineHeight": 30},
    "body": {"size": 16, "weight": 400, "lineHeight": 22},
    "caption": {"size": 13, "weight": 400, "lineHeight": 18}
  },
  "radius": {"s": 8, "m": 12, "l": 16},
  "spacing": {"xs": 4, "s": 8, "m": 12, "l": 16, "xl": 24},
  "elevation": {"card": 8, "sheet": 16}
}


========================================
FILE: ./Docs/LifeMerge/02_Design/UI_Kit/Typography.md
========================================

# Типографика

- Базовый шрифт: **Inter**.
- Заголовки: `H1 32/38 bold`, `H2 24/30 bold`, `H3 20/26 semibold`.
- Текст: `Body 16/22 regular`, `Caption 13/18 regular`.
- Используем `1.2–1.3` line-height для читаемости в темной теме.
- Максимум 2 цвета текста: `textPrimary` и `textSecondary`.


========================================
FILE: ./Docs/LifeMerge/02_Design/UI_Kit/UI_Kit_v1.0.md
========================================

UI Kit v1.0 для проекта LifeMerge
Обязательные компоненты дизайна (Приоритет 1)
Кнопки (Buttons)

Включены три стиля кнопок – Primary (основная), Secondary (второстепенная) и Tertiary (дополнительная). Все кнопки имеют высоту 48pt и скругленные углы с радиусом 10pt, обеспечивая достаточную площадь нажатия (что соответствует минимальному рекомендованному размеру тап-таргета ~48dp
m1.material.io
). Для каждой кнопки проработаны состояния: обычное (default), наведение/нажатие (pressed), неактивное (disabled) и загрузка (loading).

Primary-кнопки используются для ключевых действий и выделяются основным цветом темы; Secondary – для второстепенных действий (может быть с контуром или более мягким цветом), Tertiary – для вспомогательных действий (часто отображаются как текстовые кнопки без заливки). Состояние загрузки оформлено либо встроенным индикатором на кнопке, либо заменой текста на спиннер. Неактивное состояние визуально приглушено (более бледный фон и текст) и не допускает взаимодействия.

Поля ввода (Input Fields)

В UI Kit присутствуют текстовые поля для ввода (например, логин, пароль, поиск и т.п.) с метками (label) и вспомогательным текстом. Все поля оформлены в едином стиле с рамкой или подчеркиванием, обеспечивая достаточный контраст и размер шрифта для читабельности. Предусмотрены различные состояния: дефолтное (пустое поле без фокуса), фокус (focused) – с подсветкой рамки или тени, заполненное (filled) – когда пользователь ввёл данные, состояние ошибки (error) – с красной рамкой и сообщением об ошибке, и неактивное (disabled) – с бледным текстом/рамкой и без возможности ввода. Наличие всех этих состояний соответствует лучшим практикам дизайн-систем: поля ввода являются одними из наиболее распространённых компонентов и должны включать метку, подсказку и визуальную индикацию ошибок
uxpin.com
uxpin.com
.

Например, для состояния ошибки отображается понятный текст ошибки и изменяется цвет рамки на цвет ошибки из палитры.

Карточки (Cards)

Разработаны три вида карточек для разных типов контента: TaskCard, EventCard, FinanceCard. Все карточки имеют скругление углов 12pt и лёгкую тень, чтобы выделяться над фоном. Карточки служат контейнерами для связанной информации и действий по задачам, событиям или финансам. Единый стиль карточек помогает пользователям быстрее сканировать содержимое
uxpin.com
. Каждая карточка содержит заголовок, иконки или превью (если применимо) и краткие детали: например, TaskCard включает название задачи, статус и дедлайн; EventCard – название события, дату/время и место; FinanceCard – сумму, категорию расхода/дохода. При взаимодействии карточки могут слегка подниматься (эффект hover) или изменять тень. Все карточки адаптированы под светлую и тёмную тему (фон и текст автоматически меняют цвет согласно токенам темы).

Чипсы (Chips)

Небольшие метки-фильтры высотой 28pt, используемые для отображения категорий или атрибутов и для фильтрации контента. Чипсы имеют скруглённые углы (радиус примерно 14pt) и содержат короткий текст или иконку с текстом. Реализованы состояния: обычное (default) – нейтральный фон (или обводка) и стандартный цвет текста; выбранное (selected) – фон или обводка подсвечены основным цветом, текст контрастный (например, белый на активном фоне); неактивное (disabled) – элемент бледнее, недоступен для взаимодействия. Чипсы помогают пользователю отмечать выборы или фильтровать элементы и часто используются группами, позволяя множественный выбор.

Верхняя панель (App Bar)

Фиксированная верхняя панель высотой 56pt, содержащая заголовок экрана и иконки действий. App Bar обеспечивает контекст и навигацию на всех основных экранах. Слева обычно располагается иконка навигации (например, “бургер” для меню или стрелка назад для возврата), по центру – заголовок текущего раздела, а справа – одна или две иконки действий (например, поиск, настройки). Высота 56pt соответствует гайдлайнам Material для мобильных приложений, обеспечивая удобство касания элементов. В тёмной теме App Bar меняет цвет фона на более тёмный, а текст/иконки – на светлые, чтобы сохранить контраст.

Нижняя навигация (Bottom Navigation)

Нижняя панель навигации с пятью основными разделами приложения, представленными иконками и подписями. Каждый элемент отображается как иконка (и текст) и имеет состояния: default (не выбран) – обычно монохромная или приглушённая иконка, selected (выбран) – окрашенная основным цветом и (если предусмотрено) сопровождаемая яркой подписью. Bottom Navigation фиксируется внизу экрана, облегчая пользователю переключение между разделами (например, Календарь, Задачи, Финансы, Профиль). Пять пунктов – это максимум для сохранения читаемости и удобства нажатия; каждый пункт имеет достаточную ширину (~минимум 48pt) для комфортного взаимодействия. При выборе раздела может отображаться небольшая анимация или изменение фона под иконкой, сигнализируя о смене текущего раздела.

Индикаторы загрузки (Spinners & Progress)

Для состояний загрузки и ожидания предусмотрены анимированные индикаторы. Используется спиннер (круговой индикатор) для фоновых коротких процессов и прогресс-бар (линейная полоска) для более продолжительных или многошаговых операций. Спиннер оформлен в цвете primary (например, вращающийся кружок основного цвета на прозрачном фоне для светлой темы, и наоборот для тёмной темы). Размер спиннера адаптируется под контекст: маленький – внутри кнопки при её состоянии loading, стандартный (~24pt) – по центру экрана при загрузке контента. Наличие явных индикаторов прогресса важно для обратной связи пользователю
uxpin.com
.

Пользователь видит, что приложение обрабатывает запрос и не зависло. Дополнительно применяются скелетоны – placeholders в виде серых блоков вместо контента, чтобы показать структуру данных во время их загрузки (например, серые прямоугольники вместо карточек списка).

Цветовые токены и темы (Colors)

Определена цветовая палитра с разделением на семантические токены для светлой и тёмной тем. Основные токены включают: primary (брендовый основной цвет – используется для акцентных элементов, кнопок, активных состояний), secondary (дополнительный цвет для акцентов или второстепенных элементов интерфейса), background (основной цвет фона приложения), surface (цвет поверхностей, например, карточек, панелей), error (цвет для состояний ошибок), success и warning (для индикации успешных действий и предупреждений), а также текстовые цвета вроде onPrimary и onSurface (цвет текста/иконок поверх соответствующих фонов).

Для каждого токена задано два значения – для light и dark темы. При переключении темы значения меняются на соответствующие, но имя токена остаётся тем же (это реализовано через дизайн-токены Figma или CSS-переменные). Это позволяет единообразно применять цвета в коде и дизайне: например, токен primary может быть синим в светлой теме и светло-голубым в тёмной для контраста, но в дизайне везде обозначается как color.primary. Такой механизм соответствует современным дизайн-системам: дизайн-токен связывает абстрактное имя цвета с конкретными значениями под каждую тему
atlassian.design
. Палитра подобрана с учётом контрастности (для текста на фоне, иконок на кнопках и т.п.) согласно WCAG.

Типографика (Typography)

Установлены стили текста для заголовков и базового текста, основанные на единой шкале размеров. Предусмотрено 3 уровня заголовков: H1, H2, H3 – от самого крупного к меньшим. Например, H1 используется для самых важных заголовков (размер порядка 32pt, полужирный), H2 – для подпунктов или разделов (около 24pt, полужирный), H3 – для подразделов/секций (около 20pt, полужирный либо обычный). Основной текст имеет два базовых стиля: Body1 (например, 16pt, нормальный вес) – для основного содержания, Body2 (около 14pt) – для вторичного текста. Также задан стиль Caption (~12pt, мелкий шрифт для подписей, дат и т.п.) и стиль Button (для текста кнопок – обычно 14–16pt, полужирный, может быть верхним регистром).

Все текстовые стили определены с указанием шрифта (семейство), начертания, размера, межстрочного интервала и пр. Благодаря этому при разработке используются именно эти значения, а дизайн остаётся цельным. Стили вынесены в отдельные Text Styles в Figma, что ускоряет применение. Определение типографической иерархии в UI Kit гарантирует, что дизайнеры и разработчики говорят “на одном языке” и соблюдается визуальная иерархия текста
productstar.ru
.

Все перечисленные компоненты и стили включены в финальную версию UI Kit 1.0. Это соответствует лучшим практикам: полноценный UI Kit содержит базовые интерактивные элементы (кнопки, поля ввода, переключатели), контейнеры и карточки, навигационные блоки, типографику и цветовую палитру
productstar.ru
productstar.ru
. Компоненты согласованы между собой по стилю, отступам, радиусам скругления, цветовому оформлению и поведению. Благодаря этому единообразию разработчики смогут использовать UI Kit как единый источник правды, а пользователи ощутят целостный и знакомый опыт работы с приложением.

Крайние сценарии (Edge Cases & States)

При разработке дизайна учтены особые состояния интерфейса – ситуации, когда контент отсутствует, произошла ошибка, идёт загрузка или нет подключения. Проработка этих сценариев повышает качество UX и предотвращает замешательство пользователей. Ниже описаны подходы к таким состояниям:

Пустые состояния (Empty States)

Для экранов или разделов, где отсутствуют данные (например, нет задач, нет событий в календаре, результаты поиска пусты), разработаны специальные макеты. Вместо пустого экрана отображается дружелюбное сообщение и иллюстрация/иконка, объясняющие ситуацию и предлагающие следующий шаг. Например, на экране списка задач, если задач нет, выводится сообщение: «У вас пока нет задач. Нажмите +, чтобы добавить первую.» – вместе с условной иконкой (например, чекбокс или папка) в приглушённых тонах. Такое сообщение сразу информирует о состоянии системы и подсказывает пользователю, что делать дальше
nngroup.com
. Без этого пользователь мог бы задуматься: загрузились ли данные, произошла ли ошибка или нужно самостоятельно добавить что-то? Каждый пустой экран выдержан в фирменном стиле (цвета, шрифты) и может содержать CTA – например, кнопку для создания нового элемента прямо из пустого состояния. Таким образом, пустой экран превращается в полезный: информирует и направляет пользователя, вместо того чтобы просто показывать пустое место.

Ошибочные состояния (Error States)

Предусмотрены экраны и всплывающие уведомления для различных ошибок – от ошибок ввода (не пройдена валидация формы) до сбоев загрузки или проблемы с сетью. Каждое сообщение об ошибке сформулировано понятно и содержит инструкцию для пользователя, как действовать (например: «Не удалось загрузить данные. Проверьте подключение и попробуйте снова.»). Визуально ошибки выделяются использованием цвета error из палитры (как правило, ярко-красного) и соответствующей иконкой (например, красный восклицательный знак). Для критических сбоев, которые блокируют работу приложения, спроектирован отдельный экран-заглушка: крупная иконка ошибки, текст пояснения и кнопка действия («Повторить» или «Помощь»). Для локальных ошибок (скажем, не загрузилась отдельная карточка списка) – на её месте может отображаться небольшой серый блок с сообщением об ошибке. В компоненты форм также встроено отображение ошибок: у поля ввода появляется красная рамка и текст-подсказка под ним. Благодаря унифицированному оформлению ошибок пользователь сразу распознаёт проблему и понимает, как её решить.

Состояния загрузки (Loading States)

Когда данные загружаются или выполняется длительная операция, пользователь видит явные индикаторы процесса. Помимо упомянутых выше спиннеров и прогресс-баров, на местах контента используются скелетоны – временные серые блоки, имитирующие структуру страницы. Например, пока список задач не подгрузился, на экране отображаются несколько серых полос вместо текста и круглые заготовки вместо иконок/аватаров. Это лучше, чем просто пустой экран, так как даёт представление о том, что именно загружается (список, карточки и т.д.). Если операция критична и происходит на отдельном экране (например, авторизация), может показываться полноэкранный спиннер или блокирующий индикатор. По завершении загрузки скелетоны исчезают, и появляются реальные данные, либо происходит автоматический переход на другой экран. Таким образом, всегда соблюдается принцип обратной связи: приложение явно показывает, что оно занято, и пользователь понимает, что нужно подождать
nngroup.com
 (избегаем ситуации, когда пустой экран заставляет гадать, идет загрузка или нет).

Офлайн-режим (Offline States)

Приложение распознаёт отсутствие интернет-соединения и уведомляет об этом пользователя. В UI предусмотрен офлайн-баннер – заметная полоса в верхней части экрана (либо всплывающее toast-сообщение), появляющаяся при потере сети. В нём отображается сообщение вроде: «Вы офлайн. Данные могут быть не обновлены.» вместе с иконкой отсутствия сигнала. Такое уведомление появляется сразу, как только соединение пропадает, чтобы пользователь понял, почему новый контент не загружается
web.dev
. Одновременно некоторые действия в офлайн-режиме ограничиваются: например, кнопки, требующие соединения (обновить, отправить форму), могут становиться неактивными, сопровождаясь подсказкой. Если часть функционала доступна офлайн (например, просмотр ранее загруженных данных, создание элементов с отложенной синхронизацией), приложение позволяет продолжать работу и помечает несинхронизированные изменения специальным значком. Как только связь восстановлена, пользователь получает сигнал (исчезновение баннера или уведомление «Соединение восстановлено»), и отложенные действия могут быть автоматически выполнены. Такой подход соответствует рекомендациям по офлайн-UX: чётко информировать о состоянии приложения и доступных действиях при потере связи
web.dev
web.dev
. Пользователь остаётся в курсе событий и не теряет доверия к приложению даже при нестабильном интернете.

Проработка этих крайних сценариев на этапе дизайна предотвращает состояние неопределённости для пользователя. Каждый ключевой экран в макетах имеет вариант под эти случаи (empty/error/loading/offline), и они вынесены на страницу Figma для разработки. Например, присутствует отдельный экран списка задач без задач, экран ошибки сети, офлайн-баннер и т.д. – все они учтены в дизайне и будут реализованы разработчиками.

Wireframes низкой детализации для основных блоков

Для планирования UX-логики проекта подготовлен комплект wireframes (простых схематичных экранов) по основным функциональным блокам: Auth, Calendar, Tasks. Эти наброски отражают структуру экранов и последовательность действий пользователя, без детальной прорисовки UI – что позволяет команде сфокусироваться на функциональности, а не на стиле
interaction-design.org
. Wireframes легко корректировать и обсуждать; они служат основой для последующей детальной дизайна. Ниже перечислены экраны и сценарии, покрытые wireframes, с пояснением их целей:

Блок авторизации (Auth)

Onboarding (онбординг): Серия стартовых экранов, знакомящих пользователя с возможностями приложения при первом запуске. Обычно это 2–3 экрана-слидера с краткими описаниями и иллюстрациями. Цель: вовлечь нового пользователя и кратко показать ценность LifeMerge до регистрации. Wireframe отображает место под изображение/иконку, несколько строк текста-инструкции и кнопку «Далее» (или «Начать»). После онбординга пользователь переходит к регистрации.

Schedule/Graph (настройка графика): Примечание: В ТЗ упомянут «График» в контексте Auth. Предположительно, это экран, где новый пользователь настраивает свой распорядок (например, рабочие часы, предпочтительные часы для задач) либо демонстрация календарного графика. Цель: собрать персональные данные для персонализации (если это часть онбординга) – например, когда удобно планировать задачи. Wireframe показывает интерактивный элемент (календарь или шкалу времени), где пользователь отмечает свой график. Если этот шаг необязателен, предусмотрена кнопка «Пропустить».

Registration (регистрация): Экран создания нового аккаунта с формой ввода (имя, email, пароль и т.п.). Цель: позволить пользователю зарегистрироваться. Wireframe отображает поля ввода, кнопку «Зарегистрироваться» и ссылку «Уже есть аккаунт? Войти». Учтены детали UX: кнопка остается неактивной, пока не заполнены обязательные поля; при ошибке (например, email уже занят) будет показано сообщение ошибки под полем.

Login (вход): Экран входа для существующих пользователей. Содержит поля логина (например, email) и пароля, кнопку «Войти» и ссылку «Забыли пароль?». Цель: предоставить быстрый доступ к аккаунту. Wireframe минималистичен: логотип/название приложения, поля и кнопка – ничего лишнего. Добавлена опция «Keep me signed in» (если требуется).

Password Recovery (восстановление пароля): Процесс сброса пароля. Цель: помочь пользователю восстановить доступ. Wireframe представляет два шага: ввод email/телефона на первом экране и подтверждение на втором. На первом – поле «Email» и кнопка «Восстановить пароль». На втором – сообщение «Мы отправили ссылку для сброса на ваш email» и кнопка «OK». Продуманы нюансы: например, если email не найден, отобразится соответствующая ошибка.

Эти wireframes охватывают полный путь нового пользователя от установки приложения до входа, а также сценарий восстановления. Они показывают, как пользователь переходит от онбординга к регистрации, от регистрации к входу и т.д. Несмотря на простоту (низкая детализация), уже на этом этапе проверена логика: никакой необходимый шаг не упущен, навигация между экранами очевидна (например, из регистрации можно перейти на экран входа и наоборот). Такой подход помогает рано выявить и устранить проблемы в UX потоке.

Блок календаря (Calendar)

Day View (День): Экран календаря для одного дня. Цель: детально показать расписание пользователя на выбранный день. Wireframe отображает верхний бар с датой и, возможно, переключателями просмотра (день/неделя/месяц) или кнопкой «Сегодня». Основная часть – список событий за день, отсортированных по времени. Каждый элемент содержит время, название события (и, возможно, место или пометку). Если событий нет, внизу экрана – иллюстрация и текст пустого состояния («Нет событий»). Предусмотрена кнопка «+» (Floating Action Button) для создания нового события.

Week View (Неделя): Экран календаря на неделю. Цель: дать обзор нагрузки на неделю. Wireframe показывает сетку 7 дней (пн-вс) с краткими отметками событий (например, маленькие блоки или полоски внутри ячеек дней). Верхняя панель – управление (стрелки переключения недель, выпадающий список выбора недели, либо табы для разных видов). Если событий мало, они могут отображаться списком по дням. Этот экран поможет пользователю планировать недельную занятость.

Month View (Месяц): Экран календаря на месяц. Цель: показать долгосрочный план (даты с событиями). Wireframe представляет типичную сетку календаря (5–6 строк недель, 7 столбцов дней). Внутри ячеек дней отмечены события, например, маленькими точками или цветными метками (если много событий, может отображаться число «+3» и т.д.). Выбранный день подсвечивается. Этот экран удобен для выбора конкретной даты – по тапу на день пользователь перейдёт в Day View.

Create Event (Новое событие): Экран создания события. Цель: позволить пользователю добавить новую встречу или напоминание. Wireframe включает форму: поля «Название», «Дата и время» (с кнопкой выбора на календаре/таймпикере), «Место» (с иконкой карты), «Описание» и, возможно, переключатели или список участников. Кнопка «Сохранить» активна, когда заполнено обязательное поле (название). Также показана кнопка «Отмена» для закрытия формы. Все элементы размещены компактно, возможно, экран реализуется как модальное окно поверх календаря.

Event Details (Детали события): Экран просмотра информации о событии. Цель: дать полный контекст по выбранному событию и опции действий. Wireframe показывает заголовок события, дату и время, место (с иконкой местоположения), описание, список участников (с аватарками или инициалами). Внизу – кнопки «Редактировать» и «Удалить событие». Этот экран может вызываться по тапу на событие из календаря. Если событие прошло, оно может быть отображено серым или с пометкой «Прошедшее».

Wireframes календаря охватывают все основные задачи пользователя, связанные с управлением временем: от просмотра расписания (на разных уровнях детализации) до создания и редактирования событий. Они обеспечивают последовательность: пользователь может перейти с Month к Day, создать событие, увидеть его тут же в списке. Навигация и действия проверены: FAB «+» открывает форму, тап на событие – экран деталей, стрелки переключают периоды и т.д. Благодаря низкой детализации, эти схемы были использованы для быстрого UX-тестирования (например, в обсуждениях команды): убедиться, что все понятны и ничего не забыто.

Блок задач (Tasks)

Task List (список задач): Экран со списком всех задач пользователя. Цель: предоставить удобный обзор дел и инструменты фильтрации. Wireframe включает верхнюю панель с заголовком («Задачи» или «Мои задачи») и иконками (поиск, фильтр). Ниже – горизонтальный список фильтров (например, вкладки: «Все», «Сегодня», «Выполненные», «По проектам»), реализуемый как Chip-группа. Основное пространство – перечень задач вертикально. Каждая строка содержит чекбокс (для отметки выполнения), название задачи, возможно, значок приоритета или дедлайн датой. Если задач нет, выводится сообщение пустого состояния. В углу – плавающая кнопка «+» для добавления новой задачи.

Task Detail (детали задачи): Экран подробностей задачи. Цель: показать всю информацию по задаче и дать возможность действий (изменить, отметить выполненной). Wireframe отображает заголовок задачи крупным шрифтом, под ним – переключатель или чекбокс статуса («Выполнена / Не выполнена»). Далее – описание задачи (многострочный текст), информация о дедлайне (иконка календаря и дата), категория/проект (если есть), вложения (иконки файлов). Также может быть блок подзадач, если концепция поддерживает чек-лист внутри задачи. Внизу экрана – кнопки «Редактировать» и «Удалить».

Task Form (форма задачи): Экран создания/редактирования задачи. Цель: позволить пользователю добавить новую задачу или изменить существующую. Wireframe показывает форму с полями: «Название задачи» (текстовое поле), «Описание» (многострочное поле), «Дедлайн» (с выбором даты/времени), «Категория/Проект» (выпадающий список), «Приоритет» (например, выбор P0/P1/P2), возможно «Напоминание» (переключатель). Верхняя панель – заголовок «Новая задача» или «Редактировать задачу» и кнопка «Сохранить». Если редактирование, поля предзаполнены текущими значениями. При валидации – например, если не заполнено название – под полем или всплывающим сообщением будет указано, что оно обязательное.

Wireframes для задач покрывают полный функционал менеджера задач: от обзора всего списка до деталей и создания. Они показывают, как пользователь может фильтровать дела (например, выбрав «Сегодня» увидит только сегодняшние задачи), как может быстро отметить задачу выполненной (чекбокс в списке), как просмотреть подробности (тап по задаче) и отредактировать их. Связи между экранами продуманы: после нажатия «Сохранить» на форме – возвращаемся к списку, обновлённому; при удалении задачи – она убирается из списка и, возможно, показывается snackbar с опцией «Отменить». Поскольку эти схемы были согласованы с командой, все обязательные элементы UI (например, фильтры, кнопка добавления) включены заранее, а не добавляются в последний момент.

Примечание: Все указанные wireframes интегрированы в прототип (например, связаны в Figma), чтобы можно было последовательно пройти пользовательский путь: регистрация → вход → основной экран (например, календарь или задачи), создание элемента, и т.д. Это помогло убедиться, что переходы понятны, а также послужило основой для обсуждения с командой и раннего тестирования. Wireframes намеренно низкой детализации (без цвета, шрифтов, лишь блоки и условные обозначения) – это соответствует практике постепенного повышения fidelity: сначала проработка содержания и логики, потом визуального стиля
interaction-design.org
.

Страница "🌟 Ready for Dev" в Figma

После завершения дизайна подготовлена отдельная страница 🌟 Ready for Dev в файле Figma. На эту страницу скопированы все утверждённые фреймы UI Kit и экранов, описанных выше. Выделение отдельной страницы для финальных макетов – часть процесса hand-off, которая облегчает работу разработчиков
jobs.ataccama.com
. Они могут открыть страницу и сразу увидеть все готовые экраны и компоненты, без черновых версий и лишней информации.

Организация страницы:

Сначала размещён блок UI Kit v1.0 – все приоритетные компоненты и стили. Компоненты сгруппированы по категориям: кнопки (со всеми их состояниями), поля ввода, карточки, чипсы, AppBar, BottomNav, индикаторы, примеры цветовой палитры (светлая/тёмная) и образцы текстовых стилей. Каждый компонент представлен единообразно и подписан. Это позволяет разработчикам легко находить нужный элемент и сверяться с его параметрами (например, размеры кнопки, отступы, цвет текста). Страница фактически служит справочником: UI Kit всегда «под рукой» у команды разработки.

Далее идут фреймы экранов, разбитые на разделы по функциональным блокам: Auth, Calendar, Tasks. Например, в секции Auth находятся фреймы Onboarding_v1, Register_v1, Login_v1, Recovery_v1 (названия условные, но следуют шаблону [Экран]_v1). В секции Calendar – Calendar_Day_v1, Calendar_Week_v1, Calendar_Month_v1, Event_New_v1, Event_Details_v1. В секции Tasks – Task_List_v1, Task_Detail_v1, Task_Form_v1. Такое именование (с суффиксом версии) упрощает отслеживание изменений: если экран потребуется доработать, появится версия v2 на той же странице.

Ключевое свойство – все эти фреймы используют компоненты из UI Kit. То есть кнопки, поля, иконки и прочее вставлены как инстансы готовых компонентов. Благодаря этому дизайн экранов строго соответствует библиотеке компонентов: например, Primary-кнопка на экране регистрации – это экземпляр компонента Primary Button из UI Kit (в Figma). Если в UI Kit обновится стиль (скажем, цвет или радиус), он автоматически обновится на всех экранах. Для разработчиков это сигнал, что дизайн консистентен, и они могут переиспользовать одни и те же ресурсы (кнопки, поля) в коде.

Каждый экран на странице снабжён необходимыми аннотациями. В Figma использованы комментарии и Section descriptions для пояснений. Например, рядом с экранами онбординга может быть примечание «Свайп или кнопка “Далее” переводит на следующий слайд», на экране задачи – «Чекбокс помечает задачу выполненной, при этом она уходит из активного списка». Эти пояснения выделены так, чтобы в режимах Dev Mode Figma их тоже было видно. Они помогают разработчикам понять динамику и интерактивное поведение, которое неявно из статичного макета.

Помимо основных (happy path) экранов, на страницу Ready for Dev добавлены и edge-case экраны: пустые состояния, ошибки, офлайн-баннеры. Они либо расположены рядом с соответствующими основными экранами, либо в отдельной секции «States». Например, рядом с Task_List_v1 находится мини-экран Task_List_Empty_v1 с сообщением «У вас нет задач»; рядом с Calendar_Day_v1 – состояние «нет событий»; вынесен отдельно offline-banner. Благодаря этому разработчики видят все вариации интерфейса в одном месте
jobs.ataccama.com
, и ничего не упустится при реализации.

После финальной проверки дизайна все эти фреймы помечены статусом Figma «Ready for dev» (если используется функциональность статусной маркировки). Это служит явным индикатором, что дизайн зафиксирован для разработки
figma.com
. Дизайнеры воздерживаются от внесения изменений на этой странице без соглашения с командой, чтобы избежать расхождений. Более того, по договорённости, любые новые версии экранов (v2) или альтернативные концепты будут на других страницах (например, «Discovery»), а Ready for Dev остается стабильной и отражает именно то, что должно быть реализовано в текущем спринте/MVP.

Такой подход к организации файла получил положительные отзывы внутри команды: «Если макеты явно отмечены как “готово к разработке” и собраны на одной странице, ориентироваться очень легко». Разработчики точно знают, где смотреть, и уверены, что эти экраны актуальны и утверждены. Это снижает количество вопросов и ошибок на этапе реализации, ускоряет интеграцию (так как компоненты и стили уже систематизированы).

========================================
FILE: ./Docs/LifeMerge/02_Design/UI_Kit/UI Kit & Wireframes figma.md
========================================

LifeMerge UI Kit & Wireframes Implementation

This document summarises the finalised UI Kit v1.0, outlines the key wireframes for the MVP, and lists the screens that are marked as Ready for Development. Since direct editing in Figma is unavailable in this environment, the specifications are provided here for import into your design tool of choice.

UI Kit Components
Buttons

Three button styles are defined: Primary, Secondary and Tertiary. All buttons have a fixed height of 48 pt and rounded corners with a 10 pt radius. States include:

Default – normal background and label colours based on button type.

Pressed – background darkens slightly to indicate active press.

Disabled – lower opacity and muted colours; the button is not interactive.

Loading – shows an inline spinner in place of, or alongside, the label.

Input Fields

Text input fields are sized at 48 pt high and include a label, placeholder, optional icon and helper text. Supported states:

Default – empty field with placeholder text.

Focused – border highlights and the label floats above the input.

Filled – displays the user’s input; label remains above the field.

Error – border changes to the error colour; an error message appears below.

Disabled – muted appearance; the field is read‑only.

Cards

Cards act as containers for related content. They have 12 pt corner radius and a subtle shadow elevation. Three variants exist:

Variant	Use case
TaskCard	Shows task title, due date, priority and status
EventCard	Displays event name, date/time and location
FinanceCard	Contains transaction amount, category and type

Cards may elevate slightly or change shadow on hover or press.

Chips

Chips (tags) are used for categories and filters. They have a height of 28 pt with rounded ends. States include default (neutral border or background), selected (filled with accent colour and contrasting text) and disabled (reduced opacity).

App Bar

The top navigation bar is 56 pt high and contains a title and action icons. It adapts to light and dark themes. The bar may include a back button or menu icon on the left and context‑specific actions on the right.

Bottom Navigation

Bottom navigation consists of five items – Calendar, Tasks, Finance, Inbox and Profile. Each item shows an icon and optional label. States: default (neutral colour) and selected (accent colour and bold label). Icons switch colours in dark mode.

Spinners & Loading Indicators

Use circular spinners for indeterminate processes and skeleton placeholders for loading lists or cards. Where possible, use progress bars to indicate determinate progress. Indicators adopt neutral or primary colours appropriate for the active theme.

Colour Tokens

The palette is defined via tokens to support light and dark themes. Key tokens include:

Token	Description
primary	Main brand colour for highlights
secondary	Secondary accent or supporting colour
background	Page background colour
surface	Surface backgrounds (cards, panels)
error	Colour used for error states
success	Colour used for success messages
warning	Colour used for warnings
onPrimary	Colour of text/icons on a primary surface
onSecondary	Colour of text/icons on secondary surfaces
onBackground	Colour of text/icons on the background
onSurface	Colour of text/icons on a surface

Each token has values for both the light and dark themes to maintain sufficient contrast.

Typography

The type scale defines a clear hierarchy:

Style	Approximate size	Use
H1	32 pt	Main page titles
H2	24 pt	Section titles
H3	20 pt	Subsection headings
Body 1	16 pt	Primary body text
Body 2	14 pt	Secondary text
Caption	12 pt	Annotations and captions
Button	16 pt (bold)	Labels on buttons
Edge Cases & States

Proper handling of edge cases is critical for a polished user experience:

Empty states – when there is no content, show a friendly illustration and a brief message that explains the situation and offers a call‑to‑action to add content.

Error states – use the error colour token to highlight inputs or modules in error; provide clear messages and actions to recover (e.g. a Retry button for network errors).

Loading states – display skeleton placeholders or spinners while data is loading; subtle animations convey that the content is on its way.

Offline states – when connectivity is lost, show a banner or toast informing the user. Disable network‑dependent actions and allow offline functionality where possible. Notify the user once the connection returns.

MVP Wireframes

The following wireframes outline the core screens for the MVP. They are described at a structural level without visual styling so they can be implemented in any design tool.

Auth Screens

Onboarding – a series of slides introducing the value of the app with imagery and short text. Users can navigate forward or skip entirely.

Schedule Setup – an optional step where the user specifies their working pattern or preferred hours to personalise scheduling.

Registration – a form capturing email and password with inline validation and error feedback.

Login – a simple form for returning users to sign in with their credentials; includes an option to stay signed in.

Password Recovery – a two‑step flow to request a password reset via email and to confirm the reset.

Calendar Screens

Day View – detailed schedule for a single day with time slots and events stacked vertically. A floating action button allows creation of a new event.

Week View – a grid of seven columns representing days of the week with events displayed as blocks. Suitable for viewing relative occupancy across the week.

Month View – an overview calendar showing days of the month with subtle markers indicating the presence of events. Selecting a day drills down to the Day View.

Create Event – a form to add a new event: name, date/time picker, location and optional description; includes options for repetition and reminders.

Event Details – displays all information about an event (title, date/time, location, description, participants) and provides actions to edit or delete the event.

Task Screens

Task List – shows all tasks grouped by filters (e.g. by status or priority). Each item has a checkbox to mark it complete.

Task Detail – presents full details of a task: description, due date, context, priority, attachments, and allows editing or deletion.

Task Form – a form for creating or editing tasks; fields include name, description, due date, priority, context and reminder settings.

Ready for Development Screens

The following screens and components have been finalised and are ready to be handed off to engineering. They comply with the UI Kit and meet the Definition of Ready/Done criteria:

Onboarding_v1

Register_v1

Login_v1

Recovery_v1

Calendar_Day_v1

Task_List_v1

Task_Detail_v1

Event_New_v1

Each screen uses components defined in UI Kit v1.0 and accounts for all edge cases and states. These designs align with the MVP scope and can be imported into Figma or another design tool to continue development.

========================================
FILE: ./Docs/LifeMerge/03_Technical/AI/JSON Schema/calendar_min.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/calendar_min.json",
    "title": "CalendarMin",
    "type": "array",
    "items": {
        "type": "object",
        "additionalProperties": false,
        "required": [
            "id",
            "starts_at",
            "ends_at",
            "type",
            "source"
        ],
        "properties": {
            "id": {
                "type": "string",
                "minLength": 1
            },
            "starts_at": {
                "type": "string",
                "format": "date-time"
            },
            "ends_at": {
                "type": "string",
                "format": "date-time"
            },
            "type": {
                "type": "string",
                "enum": [
                    "event",
                    "task_block",
                    "finance_event"
                ]
            },
            "source": {
                "type": "string",
                "enum": [
                    "lifemerge",
                    "google",
                    "apple"
                ]
            },
            "task_id": {
                "type": "string",
                "minLength": 1
            }
        }
    }
}

========================================
FILE: ./Docs/LifeMerge/03_Technical/AI/JSON Schema/goals_min.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/goals_min.json",
    "title": "GoalsMin",
    "type": "array",
    "items": {
        "type": "object",
        "additionalProperties": false,
        "required": [
            "id",
            "title"
        ],
        "properties": {
            "id": {
                "type": "string",
                "minLength": 1
            },
            "title": {
                "type": "string",
                "minLength": 1,
                "maxLength": 128
            }
        }
    }
}

========================================
FILE: ./Docs/LifeMerge/03_Technical/AI/JSON Schema/metadata.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/metadata.json",
    "title": "PlannerMetadata",
    "type": "object",
    "additionalProperties": false,
    "required": [
        "request_id",
        "user_hash",
        "model_version",
        "prompt_version"
    ],
    "properties": {
        "request_id": {
            "type": "string",
            "minLength": 8,
            "maxLength": 128
        },
        "user_hash": {
            "type": "string",
            "minLength": 16,
            "maxLength": 128
        },
        "model_version": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64
        },
        "prompt_version": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64
        },
        "ab_bucket": {
            "type": "string",
            "maxLength": 64
        }
    }
}

========================================
FILE: ./Docs/LifeMerge/03_Technical/AI/JSON Schema/plan_week_request.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/plan_week_request.json",
    "title": "PlanWeekRequest",
    "type": "object",
    "additionalProperties": false,
    "required": [
        "period",
        "tasks",
        "calendar",
        "preferences",
        "goals",
        "metadata"
    ],
    "properties": {
        "period": {
            "type": "object",
            "additionalProperties": false,
            "required": [
                "start_utc",
                "end_utc"
            ],
            "properties": {
                "start_utc": {
                    "type": "string",
                    "format": "date-time"
                },
                "end_utc": {
                    "type": "string",
                    "format": "date-time"
                }
            }
        },
        "tasks": {
            "$ref": "tasks_min.json"
        },
        "calendar": {
            "$ref": "calendar_min.json"
        },
        "preferences": {
            "$ref": "preferences.json"
        },
        "goals": {
            "$ref": "goals_min.json"
        },
        "metadata": {
            "$ref": "metadata.json"
        }
    }
}

========================================
FILE: ./Docs/LifeMerge/03_Technical/AI/JSON Schema/plan_week_response.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/plan_week_response.json",
    "title": "PlanWeekResponse",
    "type": "object",
    "additionalProperties": false,
    "required": [
        "plan",
        "notes",
        "model_version"
    ],
    "properties": {
        "plan": {
            "type": "array",
            "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                    "starts_at",
                    "ends_at",
                    "type"
                ],
                "properties": {
                    "starts_at": {
                        "type": "string",
                        "format": "date-time"
                    },
                    "ends_at": {
                        "type": "string",
                        "format": "date-time"
                    },
                    "type": {
                        "type": "string",
                        "enum": [
                            "task",
                            "rest",
                            "focus"
                        ]
                    },
                    "task_id": {
                        "type": "string",
                        "minLength": 1
                    }
                }
            }
        },
        "notes": {
            "type": "array",
            "items": {
                "type": "string",
                "maxLength": 280
            },
            "maxItems": 32
        },
        "constraints_applied": {
            "type": "array",
            "items": {
                "type": "string",
                "maxLength": 64
            },
            "maxItems": 64
        },
        "model_version": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64
        }
    }
}

========================================
FILE: ./Docs/LifeMerge/03_Technical/AI/JSON Schema/preferences.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/preferences.json",
    "title": "PlannerPreferences",
    "type": "object",
    "additionalProperties": false,
    "required": [
        "timezone",
        "weekend_policy",
        "buffer_minutes_default",
        "focus_windows",
        "forbidden_windows"
    ],
    "properties": {
        "timezone": {
            "type": "string",
            "minLength": 1
        },
        "weekend_policy": {
            "type": "string",
            "enum": [
                "no_tasks",
                "light_only",
                "allow"
            ]
        },
        "buffer_minutes_default": {
            "type": "integer",
            "minimum": 0,
            "maximum": 120
        },
        "focus_windows": {
            "type": "array",
            "items": {
                "$ref": "#/definitions/time_window"
            },
            "maxItems": 28
        },
        "forbidden_windows": {
            "type": "array",
            "items": {
                "$ref": "#/definitions/time_window"
            },
            "maxItems": 56
        }
    },
    "definitions": {
        "time_window": {
            "type": "object",
            "additionalProperties": false,
            "required": [
                "weekday",
                "start",
                "end"
            ],
            "properties": {
                "weekday": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 7
                },
                "start": {
                    "type": "string",
                    "pattern": "^([01]\\d|2[0-3]):[0-5]\\d$"
                },
                "end": {
                    "type": "string",
                    "pattern": "^([01]\\d|2[0-3]):[0-5]\\d$"
                }
            }
        }
    }
}

========================================
FILE: ./Docs/LifeMerge/03_Technical/AI/JSON Schema/tasks_min.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/tasks_min.json",
    "title": "TasksMin",
    "type": "array",
    "items": {
        "type": "object",
        "additionalProperties": false,
        "required": [
            "id",
            "title",
            "priority",
            "estimated_minutes",
            "status"
        ],
        "properties": {
            "id": {
                "type": "string",
                "minLength": 1
            },
            "title": {
                "type": "string",
                "minLength": 1,
                "maxLength": 256
            },
            "priority": {
                "type": "string",
                "enum": [
                    "P0",
                    "P1",
                    "P2"
                ]
            },
            "estimated_minutes": {
                "type": "integer",
                "minimum": 5,
                "maximum": 1440
            },
            "due_at": {
                "type": "string",
                "format": "date-time"
            },
            "goal_id": {
                "type": "string",
                "minLength": 1
            },
            "status": {
                "type": "string",
                "enum": [
                    "open",
                    "done",
                    "canceled"
                ]
            }
        }
    }
}

========================================
FILE: ./Docs/LifeMerge/03_Technical/API/AI_Planner_API.md
========================================

# AI Planner API (v1)

## Общие правила
- Требуется Bearer JWT + заголовки `Accept-Language`, `X-Timezone`; лимит 5 запросов/мин на пользователя.
- Используем `request_id` или `X-Idempotency-Key` для отслеживания повторов, все ответы содержат `model_version`.
- Формат ошибок: `{error: {code, message, details?}}`; при недоступности LLM возвращается `503 ai_unavailable`.
- Поля `user_id` не передаются в LLM; вместо них хэш. Все вызовы проходят через сервис аудита с логированием промптов/ответов (без чувствительных данных).

## POST /v1/ai/plan_week
- Body: `{goals[], tasks[], calendar[], preferences{focus_hours[], sleep, timezone}, request_id}`
- Response: `{plan: [ {day, slots:[{starts_at, ends_at, type(task|focus|rest), task_id?}]} ], notes, model_version}`
- В ответ добавляется `request_id` и `generated_at`; сохраняется в таблицу `ai_plans` вместе с `X-AI-Model` и `X-Prompt-Version`.

## POST /v1/ai/insights
- Body: `{period, metrics, request_id}`
- Response: текстовые выводы и списки рекомендаций.
- Поддерживает параметр `tone` (friendly|neutral|direct) для адаптации копирайта.

## POST /v1/ai/rephrase
- Body: `{text, tone (friendly|formal), request_id}`
- Ответ содержит `variants[]` и оценку токсичности входного текста.

## Безопасность
- Требуется Bearer токен; лимит 5 запросов/мин на пользователя.
- Поля `user_id` не передаются в LLM; вместо них хэш.

## Версионирование
- Заголовок `X-AI-Model` и `X-Prompt-Version` для отслеживания качества; сохраняем в `ai_plans`.


========================================
FILE: ./Docs/LifeMerge/03_Technical/API/Auth_API.md
========================================

# Auth API (v1)

## Общие правила
- Все ответы используют структуру ошибок `{error: {code, message, details?}}`; успешные ответы содержат `request_id` для трассировки.
- Авторизация по Bearer JWT в `Authorization`, кроме `/signup`, `/login`, `/refresh`, `/forgot`, `/reset`.
- Локализация через `Accept-Language`; часовой пояс клиента передаётся в `X-Timezone` и фиксируется в сессии.
- Для защищённых операций поддерживаются `X-Idempotency-Key` и `request_id` (обязательно для серверного аудита и офлайн-синхронизации).
- Все токены выдаются только по HTTPS; refresh токены привязаны к `device_id` и могут быть отозваны для конкретного устройства или всех устройств.

## POST /v1/auth/signup
- body: `{email, password, full_name?, timezone}`
- result: `{user, access_token, refresh_token}`
- Ограничение по частоте: rate limit на пользователя/IP для предотвращения брутфорса.

## POST /v1/auth/login
- body: `{email, password, device_id}`
- result: `{user, access_token, refresh_token}`
- Ответ включает `created_at`, `updated_at`, `deleted` флаг пользователя для корректного состояния клиента.

## POST /v1/auth/refresh
- body: `{refresh_token, device_id}`
- result: `{access_token}`
- При несовпадении `device_id` возвращаем `401` с кодом `refresh_invalid_device`.

## POST /v1/auth/logout
- headers: `Authorization`
- body: `{all_devices?: boolean}`
- result: `{success: true}`

## POST /v1/auth/forgot
- body: `{email}` → письмо с кодом/ссылкой
- Ответ содержит TTL кода и маскированный email назначения.

## POST /v1/auth/reset
- body: `{email, code, new_password}`
- После успешного сброса старые refresh токены инвалидируются.

Общие правила: rate limit для `/signup` и `/forgot`, ответы содержат `request_id`.


========================================
FILE: ./Docs/LifeMerge/03_Technical/API/Calendar_API.md
========================================

# Calendar API (v1)

## Общие правила
- Требуется `Authorization: Bearer <token>`, заголовки `Accept-Language` и `X-Timezone` для корректного расчёта повторений и длительности.
- Идемпотентность через `request_id` или `X-Idempotency-Key` для всех операций создания/изменения/удаления.
- Ошибки в формате `{error: {code, message, details?}}`; при конфликте `updated_at` возвращается `409` с актуальным событием.
- Ответы включают `created_at`, `updated_at`, `deleted`, `source` (lifemerge/google/apple) для офлайн-синхронизации и разрешения конфликтов.

## GET /v1/calendar/events
- Query: `from`, `to`, `cursor?`, `limit?`, `sources?` (lifemerge/google/apple)
- Пагинация cursor-based; ответ содержит `next_cursor`.

## POST /v1/calendar/events
- Body: `{title, starts_at, ends_at, location?, recurrence_rule?, task_id?, source?, request_id}`
- При `task_id` создаётся привязка задачи к слоту.
- Принимаются временные зоны в ISO-8601; сервер нормализует к TZ пользователя.

## PATCH /v1/calendar/events/{id}
- Body: `{title?, starts_at?, ends_at?, location?, recurrence_rule?, request_id}`
- Для правок серии допускается `apply_to` (this|future|all) в `details`.

## DELETE /v1/calendar/events/{id}
- Soft delete; body `{request_id}`
- Для повторяющихся событий поддерживается `scope` (this|future|all).

## Синхронизация
- `POST /v1/calendar/import` — подключение внешнего календаря (OAuth token в защищённом хранилище).
- `POST /v1/calendar/webhook/google` — точка для уведомлений; подписки на 60 дней вперёд.
- Все события содержат `updated_at` и `source` для разрешения конфликтов.


========================================
FILE: ./Docs/LifeMerge/03_Technical/API/Finance_API.md
========================================

# Finance API (v1)

## Общие правила
- Все запросы требуют Bearer JWT, а также заголовки `Accept-Language` и `X-Timezone` для нормализации дат и валютных обозначений.
- Для операций записи используем `request_id` или `X-Idempotency-Key`; ответы содержат `created_at`, `updated_at`, `deleted`.
- Пагинация cursor-based (`cursor`, `limit`); формат ошибок `{error: {code, message, details?}}`.
- Все суммы передаются в минорных единицах (integer) или decimal строго с указанием `currency`.

## Категории
- `GET /v1/finance/categories` — список (с `next_cursor` при пагинации).
- `POST /v1/finance/categories` — `{name, type: income|expense, color?, request_id}`
- `PATCH /v1/finance/categories/{id}` — обновление.

## Транзакции
- `GET /v1/finance/transactions` — фильтры: `from`, `to`, `category_id`, `cursor`, `limit`.
- `POST /v1/finance/transactions` — `{amount, currency, category_id?, happened_at, note?, request_id}`
- `PATCH /v1/finance/transactions/{id}` — любые поля + `request_id`.
- `DELETE /v1/finance/transactions/{id}` — soft delete.

## Бюджеты и отчёты
- `POST /v1/finance/budgets` — `{category_id?, period_start, period_end, limit_amount, currency, request_id}`
- `GET /v1/finance/summary` — агрегаты по периодам, прогноз до конца месяца, перерасход.
- Все отчёты содержат поле `currency` и временные интервалы, нормализованные к TZ пользователя.

Все суммы в API передаются в копейках/центах (integer) либо decimal, согласовано по `currency`.


========================================
FILE: ./Docs/LifeMerge/03_Technical/API/Goals_API.md
========================================

# Goals API (v1)

## Общие правила
- Все запросы защищены Bearer JWT; заголовки `Accept-Language` и `X-Timezone` обязательны для корректного отображения сроков.
- Изменяющие операции требуют `request_id` или `X-Idempotency-Key` для идемпотентности (офлайн-режим, повторные отправки).
- Пагинация cursor-based: `cursor`, `limit`; ответы возвращают `next_cursor`.
- Ошибки оформляются как `{error: {code, message, details?}}`; при конфликте по `updated_at` возвращается `409`.

## GET /v1/goals
- Query: `status?`, `area?`, `cursor?`, `limit?`
- Ответ дополнительно отдаёт агрегаты по связанным задачам (`tasks_open`, `tasks_done`).

## POST /v1/goals
- Body: `{title, description?, area?, target_date?, request_id}`
- При создании можно передать стартовый `progress` и список связанных `task_ids`.

## PATCH /v1/goals/{id}
- Body: `{title?, description?, area?, target_date?, status?, progress?, request_id}`
- При смене статуса на `completed` фиксируется `completed_at`.

## DELETE /v1/goals/{id}
- Soft delete; body `{request_id}`.
- Удаление каскадно архивирует связанные задачи (статус deferred).

## Метрики и прогресс
- `GET /v1/goals/{id}/progress` — агрегированный прогресс по задачам.
- `POST /v1/goals/{id}/progress` — ручное обновление прогресса `{progress, note?, request_id}`.
- Ответ включает связанные активные задачи (до 5) для виджета «Фокус дня».


========================================
FILE: ./Docs/LifeMerge/03_Technical/API/Inbox_API.md
========================================

# Inbox API (v1)

## Общие правила
- Авторизация: `Authorization: Bearer <token>`, поддержка `Accept-Language` и `X-Timezone`.
- Все записи имеют `created_at`, `updated_at`, `deleted`; изменяющие операции требуют `request_id` или `X-Idempotency-Key`.
- Ответы и ошибки следуют формату `{error: {code, message, details?}}` и всегда возвращают `request_id` для трассировки.
- Пагинация cursor-based (`cursor`, `limit`) с `next_cursor` в ответе.

## GET /v1/inbox
- Query: `status?`, `cursor?`, `limit?`
- Возвращает список входящих элементов с метаданными источника (`source`, `payload_type`).

## POST /v1/inbox
- Body: `{source, payload, request_id}` — создание входящего элемента (из виджета/интеграции).
- Для ассистента допускается `context` (текст) для последующей конвертации AI.

## POST /v1/inbox/{id}/convert
- Body: `{type: task|event|note, mapped_fields, request_id}` — конвертация во внутренние сущности.
- В ответе возвращается созданная сущность и обновлённый статус inbox-элемента.

## PATCH /v1/inbox/{id}
- Body: `{status?, payload?, request_id}` (статусы: new, converted, archived).
- При конфликте по `updated_at` возвращается `409`.

## DELETE /v1/inbox/{id}
- Body: `{request_id}`

Ответы содержат `created_at` и `updated_at`, пригодны для офлайн-синхронизации.


========================================
FILE: ./Docs/LifeMerge/03_Technical/API/OpenAPI.yaml
========================================

openapi: 3.0.3
info:
  title: LifeMerge API
  version: 1.0.0
servers:
  - url: https://api.stage.lifemerge/v1
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  parameters:
    AcceptLanguage:
      in: header
      name: Accept-Language
      schema: { type: string, example: ru-RU }
      required: false
      description: UI локализация, влияет на тексты ошибок и уведомлений
    Timezone:
      in: header
      name: X-Timezone
      schema: { type: string, example: Europe/Moscow }
      required: false
      description: Часовой пояс клиента, используется для дат и повторений
    Cursor:
      in: query
      name: cursor
      schema: { type: string }
      required: false
      description: Токен курсора для пагинации
    Limit:
      in: query
      name: limit
      schema: { type: integer, minimum: 1, maximum: 100, default: 20 }
      required: false
      description: Количество элементов в ответе
  schemas:
    ErrorResponse:
      type: object
      properties:
        error:
          type: object
          properties:
            code: { type: string }
            message: { type: string }
            details: { type: object }
    Task:
      type: object
      properties:
        id: { type: string, format: uuid }
        title: { type: string }
        description: { type: string }
        goal_id: { type: string, format: uuid, nullable: true }
        due_at: { type: string, format: date-time, nullable: true }
        created_at: { type: string, format: date-time }
        updated_at: { type: string, format: date-time }
        deleted: { type: boolean }
    TaskCreate:
      type: object
      required: [title]
      properties:
        title: { type: string }
        description: { type: string }
        goal_id: { type: string, format: uuid }
        due_at: { type: string, format: date-time }
        request_id: { type: string }
paths:
  /auth/login:
    post:
      summary: User login
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - $ref: '#/components/parameters/Timezone'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email: { type: string, format: email }
                password: { type: string }
                device_id: { type: string }
      responses:
        '200':
          description: tokens
        '401':
          description: invalid credentials
          content:
            application/json:
              schema: { $ref: '#/components/schemas/ErrorResponse' }
  /tasks:
    get:
      summary: List tasks
      security:
        - bearerAuth: []
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - $ref: '#/components/parameters/Timezone'
        - in: query
          name: status
          schema: { type: string }
        - in: query
          name: goal_id
          schema: { type: string, format: uuid }
        - in: query
          name: due_from
          schema: { type: string, format: date-time }
        - in: query
          name: due_to
          schema: { type: string, format: date-time }
        - $ref: '#/components/parameters/Cursor'
        - $ref: '#/components/parameters/Limit'
      responses:
        '200':
          description: ok
          content:
            application/json:
              schema:
                type: object
                properties:
                  items:
                    type: array
                    items: { $ref: '#/components/schemas/Task' }
                  next_cursor: { type: string, nullable: true }
        '401':
          description: unauthorized
          content:
            application/json:
              schema: { $ref: '#/components/schemas/ErrorResponse' }
    post:
      summary: Create task
      security:
        - bearerAuth: []
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - $ref: '#/components/parameters/Timezone'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TaskCreate'
      responses:
        '201':
          description: created
          content:
            application/json:
              schema: { $ref: '#/components/schemas/Task' }
        '409':
          description: conflict (duplicate request_id)
          content:
            application/json:
              schema: { $ref: '#/components/schemas/ErrorResponse' }


========================================
FILE: ./Docs/LifeMerge/03_Technical/API/Tasks_API.md
========================================

# Tasks API (v1)

## Общие правила
- Требуется `Authorization: Bearer <token>`, `Accept-Language` и `X-Timezone` для корректных дат дедлайнов.
- Для всех изменяющих операций передаётся `request_id` или `X-Idempotency-Key` (гарантия идемпотентности при офлайн-синхронизации).
- Пагинация cursor-based: параметры `cursor`, `limit`; ответы возвращают `next_cursor`.
- Ошибки: `{error: {code, message, details?}}`, например `validation_error`, `not_found`, `conflict` (при обновлении устаревшей версии `updated_at`).

## GET /v1/tasks
- Query: `status?`, `goal_id?`, `due_from?`, `due_to?`, `cursor?`, `limit?`
- Response: список задач + `next_cursor`.
- У каждой записи есть `created_at`, `updated_at`, `deleted` для офлайн-режима.

## POST /v1/tasks
- Body: `{title, description?, goal_id?, due_at?, priority?, estimated_minutes?, energy_level?, request_id}`
- Response: созданная задача.
- При создании можно передать `reminder_at[]` для мгновенной подписки на напоминания.

## PATCH /v1/tasks/{id}
- Body: любые изменяемые поля + `request_id`.
- Конфликты по `updated_at` возвращают `409` с актуальной задачей в `details.current`.

## DELETE /v1/tasks/{id}
- Soft delete. Body: `{request_id}`.
- Удалённые задачи помечаются `deleted=true` и остаются доступными в истории синка.

## Подзадачи
- `POST /v1/tasks/{id}/subtasks` → `{title, request_id}`
- `PATCH /v1/subtasks/{subtask_id}` → `{title?, done?, request_id}`
- Подзадачи наследуют `updated_at` для разрешения конфликтов.

## Напоминания/статусы
- `POST /v1/tasks/{id}/status` → `{status, request_id}` (todo/in_progress/done/deferred)
- `POST /v1/tasks/{id}/reminders` → `{remind_at}`
- Ответы содержат `updated_at` для разрешения конфликтов офлайн-синхронизации.


========================================
FILE: ./Docs/LifeMerge/03_Technical/Architecture/AI_Architecture.md
========================================

# AI Architecture

## Сервисы
- **AI Planner API:** принимает профиль пользователя, цели, занятость календаря, предпочтения энергии/фокуса, возвращает план недели.
- **Insights:** генерирует текстовые резюме недели/финансов, теги для задач и целей.
- **Safety Layer:** проверка токенов, лимиты на объём текста, фильтрация запрещённого контента.

## Поток планирования
1. Backend собирает контекст (цели, задачи, события, предпочтения) и отправляет в AI сервис.
2. AI сервис вызывает LLM (внешний провайдер), применяет промпт-шаблоны и пост-обработку (нормализация дат, ограничения бюджета времени).
3. Результат сохраняется в БД через backend (`ai_plans` + связанные задачи/события), пользователю показывается diff.

## Технические детали
- Реализация на Python/Node, контейнер; запросы через REST `/v1/plan`, `/v1/summary`.
- Асинхронная обработка через очередь; синхронный ответ только для быстрых подсказок (<3 сек).
- Логирование запросов обезличено (hash user_id), содержимое подсказок хранится в зашифрованном виде.
- Версионирование промптов и моделей (`model_version`, `prompt_version`) для сравнения качества.

## Качество и безопасное использование
- Метрики: время отклика, % успешных планов, % ручных правок пользователем, жалобы на качество.
- A/B: сравнение разных промптов/моделей на когортах stage/prod.
- Fallback: при недоступности LLM — базовый план на шаблонах (распределение задач по приоритету и сроку).


========================================
FILE: ./Docs/LifeMerge/03_Technical/Architecture/Backend_Architecture.md
========================================

# Backend Architecture

## Модули
- **Auth:** регистрация, вход, refresh, устройства, роли.
- **Tasks/Goals:** CRUD, подзадачи, напоминания, статусы, прогресс целей.
- **Calendar:** события, повторения, синхронизация с внешними календарями.
- **Finance:** транзакции, категории, бюджеты, отчёты.
- **Inbox:** сбор уведомлений/входящих идей с конвертацией в задачи/события.
- **Notifications:** пуши/почта, расписания триггеров.

## Технологии
- REST API (FastAPI/Express), PostgreSQL, Redis для кеша и сессий, Celery/BullMQ для очередей.
- Авторизация через JWT, rate-limit middleware, OpenAPI спецификация генерируется автоматически.
- Модульная монолитная структура или микросервисы (Auth+Core, AI отдельный) в зависимости от нагрузки.

## Паттерны
- DTO ↔ Domain мапперы, репозитории для БД, сервисы с бизнес-логикой.
- Idempotency для POST/PATCH/DELETE, optimistic locking с `updated_at`.
- Вебхуки для синхронизации календарей, retry с экспоненциальной задержкой.

## Масштабирование
- API горизонтально за балансером; воркеры масштабируются по метрикам очереди.
- Кеширование справочников и публичных настроек; heavy-вычисления в воркерах.
- Фичефлаги для дорогих функций (AI, интеграции) и для миграций данных.


========================================
FILE: ./Docs/LifeMerge/03_Technical/Architecture/Data_Model/Database_Schema.sql
========================================

-- LifeMerge core schema (PostgreSQL)

CREATE TABLE users (
    id UUID PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    currency CHAR(3) NOT NULL DEFAULT 'USD',
    is_pro BOOLEAN NOT NULL DEFAULT false,
    trial_end TIMESTAMPTZ,
    full_name TEXT,
    timezone TEXT NOT NULL DEFAULT 'UTC',
    role TEXT NOT NULL DEFAULT 'user',
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE goals (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    category TEXT,
    deadline TIMESTAMPTZ,
    progress NUMERIC(5,2) DEFAULT 0,
    status TEXT NOT NULL DEFAULT 'active',
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE tasks (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    goal_id UUID REFERENCES goals(id) ON DELETE SET NULL,
    title TEXT NOT NULL,
    description TEXT,
    context TEXT,
    energy_level TEXT CHECK (energy_level IN ('light','medium','heavy')),
    estimated_minutes INTEGER,
    priority TEXT DEFAULT 'P2' CHECK (priority IN ('P0','P1','P2')),
    deadline TIMESTAMPTZ,
    is_recurring BOOLEAN NOT NULL DEFAULT false,
    recurrence_rule TEXT,
    status TEXT NOT NULL DEFAULT 'open' CHECK (status IN ('open','done','canceled')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted BOOLEAN NOT NULL DEFAULT false
);

CREATE TABLE subtasks (
    id UUID PRIMARY KEY,
    task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    done BOOLEAN NOT NULL DEFAULT false,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE finance_categories (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    type TEXT NOT NULL CHECK (type IN ('income','expense')),
    color TEXT,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE finance_transactions (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    category_id UUID REFERENCES finance_categories(id) ON DELETE SET NULL,
    type TEXT NOT NULL CHECK (type IN ('income','expense')),
    linked_event_id UUID,
    is_recurring BOOLEAN NOT NULL DEFAULT false,
    recurrence_rule TEXT,
    amount NUMERIC(14,2) NOT NULL,
    currency CHAR(3) NOT NULL DEFAULT 'USD',
    happened_at TIMESTAMPTZ NOT NULL,
    transaction_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    note TEXT,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted BOOLEAN NOT NULL DEFAULT false
);

CREATE TABLE calendar_events (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    type TEXT NOT NULL CHECK (type IN ('event','task_block','finance_event')),
    linked_task_id UUID REFERENCES tasks(id) ON DELETE SET NULL,
    linked_finance_id UUID REFERENCES finance_transactions(id) ON DELETE SET NULL,
    title TEXT NOT NULL,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    location TEXT,
    source TEXT DEFAULT 'lifemerge',
    category TEXT,
    recurrence_rule TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted BOOLEAN NOT NULL DEFAULT false
);

CREATE TABLE inbox_items (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    text TEXT,
    type TEXT NOT NULL CHECK (type IN ('idea','task','goal','finance')),
    source TEXT, -- email, widget, integration
    payload JSONB NOT NULL,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active','processed')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE budgets (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    category_id UUID REFERENCES finance_categories(id) ON DELETE SET NULL,
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    limit_amount NUMERIC(14,2) NOT NULL,
    currency CHAR(3) NOT NULL DEFAULT 'USD'
);

CREATE TABLE ai_plans (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    plan_json JSONB NOT NULL,
    prompt_version TEXT,
    model_version TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_tasks_user_deadline ON tasks(user_id, deadline);
CREATE INDEX idx_events_user_start ON calendar_events(user_id, start_time);
CREATE INDEX idx_fin_tx_user_date ON finance_transactions(user_id, happened_at);


========================================
FILE: ./Docs/LifeMerge/03_Technical/Architecture/Mobile_Architecture_Flutter.md
========================================

# Mobile Architecture (Flutter)

## Слои
- **Presentation:** `views`, `widgets`, `state` (riverpod/provider), маршруты через `go_router`.
- **Domain:** use-cases (например, `planWeek`, `syncTasks`), модели без зависимостей на Flutter.
- **Data:** репозитории (API + локальное хранилище), мапперы DTO ↔ domain, кеширование.
- **Infrastructure:** HTTP клиент, secure storage, аналитика, пуши.

## Офлайн/онлайн
- Локальная БД `sqflite` содержит задачи, события, транзакции, цели, очереди операций.
- При отсутствии сети операции складываются в `pending_operations` с `request_id`; синк при восстановлении соединения.
- Конфликты: правило «сервер выигрывает», но UI показывает diff и позволяет принять локальную версию.

## Навигация и модули
- Отдельные модули: `auth`, `tasks`, `calendar`, `goals`, `finance`, `inbox`, `settings`.
- Common UI: `lifemerge_theme`, `AppScaffold`, `primary_button`, `sheet_header` из UI Kit.

## Тестирование
- Widget тесты для списков задач, календаря, финансовых графиков.
- Golden тесты для базовых компонентов UI Kit.
- Интеграционные тесты сценариев: онбординг, создание задачи, офлайн-режим.


========================================
FILE: ./Docs/LifeMerge/03_Technical/Architecture/Offline_Sync_Design.md
========================================

# Offline Sync Design

## Цели
- Позволить создавать/редактировать задачи, события, финоперации без сети.
- Избежать потери данных и дублей при восстановлении соединения.

## Локальные данные
- Храним в `sqflite` таблицы `tasks_local`, `events_local`, `transactions_local`, `pending_operations`.
- Каждая запись содержит `local_id`, `server_id`, `updated_at_local`, `updated_at_server`, `sync_status`.

## Очередь операций
- Формат операции: `{type, entity, payload, request_id, created_at}`.
- Синхронизатор отправляет батчами (до 20 операций) в `/sync/batch` или соответствующие модули.
- В случае конфликта сервер возвращает 409 с актуальной версией; клиент показывает diff.

## Политики конфликта
- **Last Write Wins** по `updated_at`, но если разница >24h, показываем выбор пользователю.
- Удаления помечаются `deleted=true` и синхронизируются как soft delete.

## Дополнительное
- Фоновая синхронизация при смене сети или раз в 15 минут на фоне.
- При logout очищаем локальные таблицы и pending-очередь.
- Журналируем ошибки синка и отправляем в Sentry.


========================================
FILE: ./Docs/LifeMerge/03_Technical/Architecture/Personalization_ML_Spec.md
========================================

# ML Personalization Module — Input/Output Specification

## Назначение
Модуль персонализации отвечает за подготовку признаков и вызов ML/LLM-модели, которая адаптирует планирование, подсказки и приоритеты под конкретного пользователя. Спецификация фиксирует контракт входных данных и ожидаемых выходов, чтобы бэкенд и AI-сервис были согласованы.

## Общие правила
- Все идентификаторы пользователей и устройств передаются в захешированном виде (`sha256(user_id)`).
- Часовой пояс обязателен, время — в ISO 8601 с таймзоной.
- Денежные суммы указываются в базовой валюте профиля, строки валют — по ISO 4217.
- Пустые поля не отправляются; для необязательных массивов допускается `[]`.

## Входные данные (Input)
JSON-пакет `PersonalizationContext` передается из backend в ML-сервис:

```json
{
  "user_profile": {
    "user_hash": "string",
    "locale": "ru-RU",
    "timezone": "Europe/Moscow",
    "work_pattern": "5/2",
    "focus_hours": [{"start": "09:00", "end": "12:00"}],
    "no_go_periods": [{"weekday": "sun", "reason": "rest"}]
  },
  "behavior": {
    "tasks": [
      {
        "id_hash": "string",
        "title": "string",
        "priority": "P0|P1|P2",
        "context": "home|office|mobile|travel|custom",
        "energy": "light|medium|heavy",
        "estimated_minutes": 45,
        "deadline": "2024-11-20T18:00:00+03:00",
        "status": "open|done|canceled",
        "created_at": "2024-11-10T07:00:00+03:00",
        "completed_at": "2024-11-11T09:20:00+03:00"
      }
    ],
    "events": [
      {
        "id_hash": "string",
        "type": "event|task_block|finance_event",
        "starts_at": "2024-11-14T10:00:00+03:00",
        "ends_at": "2024-11-14T11:00:00+03:00",
        "title": "string",
        "linked_task_id_hash": "string|null"
      }
    ],
    "goals": [
      {
        "id_hash": "string",
        "title": "string",
        "category": "career|health|finance|family|learning|other",
        "deadline": "2025-03-01T00:00:00+03:00",
        "progress": 0.35
      }
    ],
    "finance": {
      "currency": "RUB",
      "regular_cashflow": [{"type": "income|expense", "amount": 75000, "interval": "monthly", "next_date": "2024-12-01"}],
      "last_transactions": [{"amount": -1200, "category": "food", "ts": "2024-11-12T13:00:00+03:00"}]
    },
    "engagement": {
      "session_count_7d": 9,
      "task_completion_rate_7d": 0.62,
      "ai_plan_accept_rate": 0.74,
      "feedback_events": [{"type": "like|dislike", "subject": "ai_plan", "ts": "2024-11-11T10:00:00+03:00"}]
    }
  },
  "constraints": {
    "hard_rules": ["no_heavy_after_20:00", "min_gap_15m"],
    "max_daily_work_minutes": 480
  },
  "request": {
    "request_id": "uuid",
    "model_version": "string",
    "prompt_version": "string",
    "target_horizon": "day|week"
  }
}
```

### Поля и валидация
- `user_profile.work_pattern`: одно из `5/2`, `2/2`, `3/3`, `custom`.
- `behavior.tasks[].priority`: `P0` обязательно имеет `deadline`; `estimated_minutes` > 0.
- `behavior.events[]`: `starts_at < ends_at`; если `type == task_block`, поле `linked_task_id_hash` обязательно.
- `behavior.finance.regular_cashflow[].interval`: `daily|weekly|monthly|yearly`.
- `constraints.hard_rules`: набор строковых токенов, согласованных между backend и AI-сервисом.

## Выходные данные (Output)
Ответ ML-сервиса `PersonalizationResult` возвращается в backend:

```json
{
  "request_id": "uuid",
  "generated_at": "2024-11-13T08:00:00Z",
  "model_version": "string",
  "prompt_version": "string",
  "personalization": {
    "ranked_tasks": [
      {"task_id_hash": "string", "score": 0.87, "reason": "high priority before deadline"}
    ],
    "suggested_slots": [
      {
        "task_id_hash": "string",
        "starts_at": "2024-11-14T09:30:00+03:00",
        "ends_at": "2024-11-14T10:15:00+03:00",
        "confidence": 0.81
      }
    ],
    "nudges": [
      {"type": "habit|focus|finance|energy", "message": "Сделай тяжёлую задачу до 11:00", "priority": "high|medium|low"}
    ],
    "ab_experiment": {"cohort": "B", "features": {"tone": "direct", "slot_length": 45}},
    "profile_updates": {
      "detected_focus_hours": [{"start": "08:30", "end": "11:30"}],
      "preferred_contexts": ["office", "mobile"],
      "anomalies": ["low_completion_3d"]
    }
  },
  "constraints_applied": ["no_heavy_after_20:00", "min_gap_15m"],
  "safety": {"redacted_fields": ["title"], "tokens": 3240}
}
```

### Интерпретация выходов
- `ranked_tasks`: отсортированный список для рекомендаций и авто-планирования; `score` в диапазоне `[0,1]`.
- `suggested_slots`: кандидаты для вставки в календарь; backend валидирует конфликты перед сохранением.
- `nudges`: микро-рекомендации для уведомлений/баннеров; `priority` задаёт канал доставки.
- `ab_experiment`: выбранные параметры для текущего пользователя, чтобы фиксировать в аналитике.
- `profile_updates`: сигналы, которые можно сохранить в `user_settings` после подтверждения бизнес-логикой.
- `constraints_applied`: набор правил, учтённых при генерации, для аудита и дебага.
- `safety`: метаданные о редактировании текста и токенизации.

## Контроль качества
- Обязательные проверки на стороне backend: соответствие `request_id`, допустимость таймслотов, ограничения по рабочему времени и валюте.
- Логирование: сохраняем `request_id`, `model_version`, `prompt_version`, `hashes` сущностей, но не сохраняем исходные тексты задач/заметок.
- Метрики: точность принятия слотов, % выполненных задач из рекомендованных, CTR по `nudges`, доля пользователей с обновлёнными `focus_hours` после 7 дней.


========================================
FILE: ./Docs/LifeMerge/03_Technical/Architecture/System_Architecture.md
========================================

# System Architecture

## Компоненты
- **Mobile (Flutter):** UI, офлайн-кеш, очередь синхронизации, пуши.
- **Backend API:** Auth, Tasks, Calendar, Goals, Finance, Notifications, Feature Flags.
- **AI Service:** планирование недели, подсказки целей, резюме недели, тональная коррекция писем.
- **Data Layer:** PostgreSQL + Redis (кеш/сессии) + S3-хранилище.
- **Async:** очередь (RabbitMQ/Redis Streams) + воркеры для синхронизаций, AI, интеграций.
- **Monitoring:** Grafana/Prometheus, Sentry, Crashlytics.

## Потоки данных (упрощённо)
1. Пользователь создаёт задачу в приложении → сохраняется локально → синхронизируется на сервер через `/tasks` → фоновые воркеры пушат напоминания.
2. Импорт из Google Calendar: backend-воркер получает вебхук, обновляет события, отправляет пуш об изменениях.
3. AI-планирование: backend формирует контекст (цели, расписание), отправляет в AI сервис, получает расписание и пишет в таблицу `ai_plans` + задачи.

## Нефункциональные аспекты
- Горизонтальное масштабирование API и воркеров, sticky-сессии не требуются (stateless).
- Кеширование справочников и результатов AI на 24 часа.
- Резервное копирование БД ежедневно, тест восстановления еженедельно.


========================================
FILE: ./Docs/LifeMerge/03_Technical/DevOps/CI_CD_Pipeline.md
========================================

# CI/CD Pipeline

## CI (pull request)
1. Lint/format: `dart format --set-exit-if-changed`, `flutter analyze`, `ruff`/`eslint` для бекенда/AI.
2. Unit/widget tests: `dart test`, `pytest`, `npm test` (если фронт веб).
3. Сборка мобильного клиента в `--debug` для smoke, выгрузка артефактов в CI.
4. Генерация OpenAPI и проверка `scripts/validate_openapi.sh`.

## CD
- **Develop → Dev**: авто-деплой backend/AI через Docker + Helm, прогон миграций, загрузка демоданных.
- **Release candidate → Stage**: ручной триггер, подпись мобильных билдов (internal test), прогон регресса.
- **Prod**: мажорные релизы через change approval, канареечный rollout 10% → 50% → 100% за 24 часа.

## Артефакты
- Контейнеры собираются через BuildKit, публикуются в приватный registry.
- Мобильные `.ipa/.aab` хранятся в артефакт-репозитории с метаданными версии, commit SHA, окружения.

## Качество
- Codecov/coveralls с порогом >70% для ключевых модулей (tasks, calendar, finance).
- SAST/Dependency scan (Trivy/Snyk) обязательны перед stage/prod.


========================================
FILE: ./Docs/LifeMerge/03_Technical/DevOps/Deployment_Guide.md
========================================

# Deployment Guide

## Подготовка
- Проверить миграции БД и обратную совместимость API.
- Убедиться, что `OpenAPI.yaml` обновлён и прошёл валидацию.
- Настроить переменные окружения (см. Environments.md), обновить secrets в Vault.

## Backend/AI
1. Собрать образы `backend:<tag>` и `ai-service:<tag>`.
2. Применить Helm-чарты: `helm upgrade --install lifemerge-backend charts/backend -f values/<env>.yaml`.
3. Выполнить миграции: `alembic upgrade head` или `prisma migrate deploy` (в зависимости от стека).
4. Проверить readiness/liveness, метрики, отсутствие 5xx в логах.

## Мобильные клиенты
- iOS: `flutter build ipa --flavor <env>`; загрузить в TestFlight/App Store Connect.
- Android: `flutter build appbundle --flavor <env>`; загрузить в Play Console/внешние сторы.
- Проверить совместимость с минимальной поддерживаемой версией, обновить changelog.

## Проверки после релиза
- Smoke-тест: логин, создание задачи/события, синхронизация офлайн → онлайн, операция с финансами.
- Проверить алёрты, дашборды и crash-free; вернуть rollout, если error rate > допустимого порога.


========================================
FILE: ./Docs/LifeMerge/03_Technical/DevOps/Deployment_Plan.md
========================================

# Deployment Plan — Draft Environment CI/CD

## Цель
Описать, как черновой стенд (Draft) автоматически собирается и разворачивается из CI/CD, чтобы разработчики получали изолированные сборки для раннего тестирования без влияния на Dev/Stage/Prod.

## Триггеры и ветки
- **feature/** и **bugfix/**: авто-сборка и деплой чернового стенда по каждому push в MR/PR.
- **manual re-run**: ручной перезапуск job для восстановления стенда или проверки фиксов.
- **auto-cleanup**: тайм-аут жизни стенда 48 часов; после merge/close MR стенд уничтожается.

## Пайплайн
1. **Lint/Static Analysis**: `flutter analyze`, `dart test --coverage` для клиента; `pytest -q` и `ruff`/`eslint` для backend/AI.
2. **Сборка контейнеров**: BuildKit, теги `draft-<branch>-<sha>` публикуются в приватный registry.
3. **Деплой**: Helm-чарт в namespace `draft-<branch>` с `values/draft.yaml`; включаем mock-провайдеры внешних интеграций.
4. **Миграции**: `alembic upgrade head` / `prisma migrate deploy` против отдельной Draft-БД; обратная совместимость обязательна.
5. **Smoke-тест**: `scripts/smoke_draft.sh` — логин, создание задачи, синхронизация офлайн → онлайн.
6. **Отчёт**: URL стенда и артефакты сборки публикуются в MR/PR комментарии.

## Роллбек и очистка
- Helm rollback на предыдущий релиз (`helm rollback <release> 1`) по детекту 5xx/ошибок readiness.
- После merge/закрытия MR job `cleanup_draft` удаляет namespace, секреты и storage claims.

## Требования к секретам
- Secrets и токены берутся из Vault/KMS по пути `draft/<team>/<service>`; доступ ограничен service account CI.
- В пайплайне используются временные credentials (TTL ≤ 1 час), чтобы уборка не блокировалась утечками ключей.

## Логи и наблюдаемость
- Включен stdout/stackdriver/ELK сбор логов для всех pod в namespace `draft-*`.
- Метрики и алёрты общие с Dev, но с отдельными неймспейс-фильтрами; частота проверок раз в 5 минут.

## Передача в Dev/Stage
- Merge в `develop` переключает пайплайн на Dev по существующим правилам (см. CI_CD_Pipeline.md).
- Принятые фичи получают тег `draft-tested` в release notes, если smoke прошёл на черновом стенде.


========================================
FILE: ./Docs/LifeMerge/03_Technical/DevOps/Environments.md
========================================

# Environments

| Среда | Назначение | URL/API | Особенности |
|-------|------------|---------|-------------|
| **Dev** | Быстрая разработка | `https://api.dev.lifemerge` | Авто-сборки из `develop`, моковые интеграции, открытые тест-аккаунты |
| **Stage** | Приёмка/QA | `https://api.stage.lifemerge` | Данные приближены к прод, feature flags по умолчанию включены, нагрузочные тесты |
| **Prod** | Пользовательская | `https://api.lifemerge.app` | Полные метрики/алёрты, белые списки IP для админки |

## Управление конфигурацией
- Секреты в Vault/KMS, подключение через переменные окружения.
- Feature flags (Unleash/LaunchDarkly) для AI-функций, офлайна, платёжных интеграций.
- Версии мобильных приложений фиксируются через `min_supported_version` в конфиге backend.


========================================
FILE: ./Docs/LifeMerge/03_Technical/DevOps/Infrastructure_Spec.md
========================================

# Infrastructure Spec — Draft Environment

## Контур
- **Кластер**: K8s (managed, 3×nodes t3.medium/4vCPU/8GB), отдельный namespace `draft-*` на общем кластере с Dev.
- **Сеть**: ingress с базовой аутентификацией, IP allowlist ограничен офис/VPN; egress через NAT с ограничением к внешним API.
- **БД**: отдельный PostgreSQL instance per-branch (`draft_<branch>`), размер до 10 GB, авто-удаление с retention 2 дня.
- **Файлы**: S3 совместимое хранилище с bucket `lifemerge-draft` и prefix `branches/<branch>/`; lifecycle 7 дней.
- **Кэш/очереди**: Redis c ограничением 256MB per-namespace, RabbitMQ shared vhost `draft`.

## Конфигурация сервисов
- **Backend/AI**: деплой через Helm-чарты `charts/backend` и `charts/ai` с overlays `values/draft.yaml`.
- **Мобильные билд-серверы**: билд-агенты в CI (Linux/macOS runners) с кэшем зависимостей; артефакты в `artifacts/draft/`.
- **Secrets/Config**: `values/secrets-draft.yaml` формируются из Vault; токены интеграций заменяются на моки.

## Наблюдаемость
- Логи: stdout → Loki/ELK с label `env=draft`.
- Метрики: Prometheus scrape `draft-*`; дашборд Grafana “Draft Stand” с SLA: error rate <2%, аптайм 95%.
- Трейсинг: OpenTelemetry с экспортом в Jaeger, сэмплинг 5% для контроля нагрузки.

## Политики безопасности
- RBAC: доступ к namespace только через сервис-аккаунт CI и группу DevOps-readonly.
- Образы проходят проверку Trivy, сигнатуры Notary; pull только из приватного registry через imagePullSecrets.
- NetworkPolicy закрывает межсервисное общение, разрешает только ingress от IngressController и egress к Redis/DB.

## Интеграция с CI/CD
- Pipeline создаёт namespace, секреты и параметры БД динамически, затем применяет `helm upgrade --install`.
- После завершения MR job `cleanup_draft` удаляет namespace, PVC и префикс в S3, освобождая квоты.
- Для экономии ресурсов включена автопауза pod при простое (keda/hpa до 0 реплик) и cron на удаление старых артефактов.


========================================
FILE: ./Docs/LifeMerge/03_Technical/DevOps/Monitoring_and_Logging.md
========================================

# Monitoring & Logging

## Метрики
- Backend: latency/таймауты по эндпоинтам, ошибки 4xx/5xx, очередь задач, использование БД (CPU, connections, slow queries).
- AI сервис: время ответа, количество токенов, процент fallbacks, очередь job'ов.
- Мобильный клиент: crash-free %, время запуска, FPS на ключевых экранах.

## Логирование
- Формат JSON, обязательные поля: `timestamp`, `level`, `service`, `request_id`, `user_id`, `path`, `latency_ms`.
- PII маскируем; отключаем body для финансовых операций.
- Корреляция через `request_id` между сервисами.

## Алёрты (пример)
- API error rate >5% за 5 минут.
- Latency p95 > 400 мс на `/tasks` или `/calendar`.
- Очередь фоновых задач > 1k сообщений 10 минут.
- Crash-free mobile < 98% за сутки.

## Дашборды
- Grafana/Datadog для сервисных метрик, Sentry для ошибок, Firebase Crashlytics для мобильных.
- Общий продуктовый дашборд: MAU, удержание D1/D7, активность по модулям (календарь, задачи, финансы).


========================================
FILE: ./Docs/LifeMerge/03_Technical/Requirements/API_Requirements.md
========================================

# Требования к API

- REST/JSON, префикс `/v1`, консистентные коды ошибок и тело `{error:{code,message,details}}`.
- Авторизация через Bearer JWT, поддержка refresh; все запросы по HTTPS.
- Пагинация cursor-based (`cursor`, `limit`), ответы с `next_cursor`.
- Идемпотентность: `X-Idempotency-Key` или `request_id` для изменяющих операций.
- Все ресурсы содержат `updated_at`, `created_at`, `deleted` (soft delete) для офлайн-синхронизации.
- Локализация через `Accept-Language`, часовой пояс через `X-Timezone`.
- Rate limit по IP и пользователю; отдельные квоты для AI-вызовов.


========================================
FILE: ./Docs/LifeMerge/03_Technical/Requirements/Functional_Requirements.md
========================================

# Функциональные требования (MVP)

1. **Регистрация/логин/восстановление** по email + пароль; ограничение устройств.
2. **Задачи**: создание/редактирование/удаление, приоритет, дедлайны, подзадачи, напоминания, статусы, офлайн-режим.
3. **Календарь**: события с повторениями, привязка задач к слотам, синхронизация с Google/Apple, просмотр день/неделя/месяц.
4. **Цели**: создание целей, области жизни, прогресс, связь с задачами, краткие отчёты прогресса.
5. **Финансы**: категории доходов/расходов, транзакции, бюджеты, дашборд месяца.
6. **Inbox**: сбор идей/уведомлений, конвертация в задачи/события.
7. **AI**: планирование недели с учётом задач/календаря/предпочтений, текстовые инсайты.
8. **Уведомления**: пуши о задачах/событиях, дневной/недельный дайджест.
9. **Аналитика**: события для Mixpanel/Amplitude (активация, создание задач, удержание).


========================================
FILE: ./Docs/LifeMerge/03_Technical/Requirements/NonFunctional_Requirements.md
========================================

# Нефункциональные требования (NFR)

## Производительность
- p95 для основных API (/tasks, /calendar, /finance) ≤ 400 мс на Stage при нагрузке 200 RPS.
- Синхронизация офлайн-очереди < 5 сек для 20 операций.

## Надёжность
- Доступность прод сервисов 99.5% в месяц.
- Автоматические бэкапы БД ежедневно, RPO ≤ 24 часа, RTO ≤ 4 часа.

## Безопасность
- Все соединения по HTTPS, хранение токенов в защищённых хранилищах.
- Шифрование дисков, ротация ключей раз в 90 дней, журнал аудита для действий админов.

## Масштабируемость
- Горизонтальное масштабирование API/воркеров, stateless обработчики.
- Кеширование справочников, очереди для тяжёлых операций (AI, импорт календаря).

## Юзабилити
- Поддержка тёмной темы, шрифты и контраст в соответствии с WCAG AA.
- Время первого запуска приложения < 3 сек на устройствах уровня Pixel 6 / iPhone 12.


========================================
FILE: ./Docs/LifeMerge/03_Technical/Requirements/Technical_Specification.md
========================================

# Technical Specification (кратко)

- **Платформы:** Flutter iOS/Android, backend REST на FastAPI/Express, AI-сервис отдельный.
- **БД:** PostgreSQL, Redis для кеша и сессий.
- **Фичи MVP:** auth, задачи, календарь, цели, финансы, inbox, AI-планирование недели.
- **Интеграции:** Google/Apple Calendar, FCM/APNs, внешняя LLM API.
- **Офлайн:** локальная БД + очередь операций, конфликты по `updated_at`.
- **Обновления:** OpenAPI.yaml генерируется автоматически, мобильные клиенты через App Store/Play с feature flags.


========================================
FILE: ./Docs/LifeMerge/03_Technical/Security/Authentication.md
========================================

# Authentication & Authorization

## Флоу входа
1. Пользователь вводит email/пароль → `/auth/login`.
2. Backend возвращает `access_token` (15–30 мин), `refresh_token` (30 дней), `user_profile`.
3. Access хранится в памяти клиента, refresh — в защищённом хранилище (Keychain/Keystore).
4. При истечении access вызываем `/auth/refresh` с `refresh_token`.

## Регистрация и восстановление
- Signup: email + пароль + согласие с политиками; письмо для верификации.
- Восстановление пароля: одноразовый код/ссылка, ограничения по частоте (5 запросов/час).
- Ограничение устройств: по умолчанию до 3 активных refresh-токенов; `logout_all` отзывает остальные.

## Авторизация
- Роли: `user` (по умолчанию), `admin`, `support` (read-only). Проверка ролей в middleware.
- Доступ к объектам проверяем по `user_id` + флагам доступа (для будущего шеринг-модуля).
- Для AI-вызовов добавляем доп. лимиты и контроль объёма входного текста.

## Безопасность токенов
- Формат JWT: `sub`, `role`, `exp`, `iat`, `device_id`.
- Подпись: RS256, приватный ключ в KMS. Ключи ротируются каждые 90 дней, `kid` в заголовке.
- Чёрный список refresh-токенов в Redis/PostgreSQL (`revoked_tokens`).

## Аудит
- Логируем входы/выходы, смену пароля, подозрительные IP/гео, попытки доступа к чужим ресурсам.
- Пользователь может просмотреть последние активные сессии и отозвать их.


========================================
FILE: ./Docs/LifeMerge/03_Technical/Security/Data_Protection.md
========================================

# Data Protection

## Хранение данных
- **Бэкенд:** PostgreSQL с шифрованием томов (AES-256), резервные копии ежедневно с хранением 30 дней.
- **Файлы:** документы/изображения в S3-совместимом хранилище, шифрование на стороне сервера, приватные bucket.
- **Клиент:** локальная БД шифруется паролем ОС; чувствительные поля (токены, email) — через secure storage.

## Управление персональными данными
- Минимизация: собираем только email, имя, часовой пояс; финданные всегда привязаны к user_id.
- Пользователь может экспортировать JSON/CSV с задачами, целями, транзакциями; удаление аккаунта инициирует очистку в течение 30 дней.
- Логирование PII запрещено; используем маскировку для номеров карт и сумм.

## Передача данных
- Все соединения TLS 1.2+, HSTS, отключены слабые шифры; HTTP → HTTPS редирект.
- WebSockets (позже) только wss:// с проверкой токена на connect/refresh.
- Push-токены передаются только по HTTPS и хранятся отделенно от профилей.

## Соответствие требованиям
- Соответствие GDPR-подобным принципам: согласие, право на удаление, ограничение цели сбора.
- DPIA проводится для AI-функций; данные для обучения анонимизируются.
- Доступ разработчиков к прод-данным только через break-glass процесс с аудитом.


========================================
FILE: ./Docs/LifeMerge/03_Technical/Security/Threat_Model.md
========================================

# Threat Model (LifeMerge)

## Акторы
- **Злоумышленник без учётки:** пытается получить доступ к API, подделать трафик, подменить приложение.
- **Скомпрометированный пользователь:** пытается украсть/подменить данные других пользователей.
- **Внутренний нарушитель:** доступ к логам/базе, попытка извлечь PII и финданные.

## Основные угрозы и меры
1. **Кража токенов доступа**
   - HTTPS везде, `secure`/`HttpOnly` для refresh-cookie в web, для mobile храним в OS Keychain/Keystore.
   - Ротация refresh каждые 30 дней, отзыв токенов при logout/all-devices.
2. **Инъекции и эскалация прав**
   - Parametrized queries/ORM; входные данные валидируются схемами, лимиты длины.
   - RBAC: проверки на уровне handler и сервисов, аудит действий admin/support.
3. **Подмена/утечка данных при синхронизации**
   - Подпись ответов `ETag`, HSTS, защита от downgrade TLS, pinning сертификата в мобильном приложении.
   - Консистентность через `updated_at` и версии записей.
4. **Утечка PII и финансовых данных из логов/бэкапов**
   - Маскирование карт и сумм в логах, шифрование бэкапов и снапшотов, доступ по VPN/KMS.
5. **DDoS и rate abuse**
   - Rate limit per IP/user, капча на signup, отдельные лимиты для дорогих AI-вызовов.
6. **Loss/Corruption данных клиента**
   - Защита локальной БД паролем ОС, шифрование AES-256; периодический бэкап пользовательских настроек в облако (opt-in).

## Остаточные риски
- Социальная инженерия и фишинг вне приложения.
- Утечки на стороне сторонних интеграций (Google/Apple/банки) — минимизируются мониторингом и отзывом токенов.


========================================
FILE: ./Docs/LifeMerge/04_Development/Backlog/Bugs.md
========================================

# Known bugs

| ID | Компонент | Описание | Приоритет | Статус |
|----|-----------|----------|-----------|--------|
| BUG-1 | Calendar sync | Дублируются события при повторном импорте из Google при смене таймзоны | High | In progress |
| BUG-2 | Tasks offline | Изменённые подзадачи не уходят в очередь синхронизации при потере сети | High | To Do |
| BUG-3 | Finance charts | Некорректное округление копеек в диаграмме расходов (на iOS) | Medium | To Do |
| BUG-4 | Notifications | Пуш «Начни день» приходит в 00:00, не учитывается пользовательский часовой пояс | High | In progress |
| BUG-5 | AI Planner | При пустом описании цели возвращается 500 вместо валидационной ошибки | Medium | To Do |


========================================
FILE: ./Docs/LifeMerge/04_Development/Backlog/Features.md
========================================

# Feature backlog

1. **Смарт-планировщик недели (AI Planner v1)**
   - Ввод: цели, приоритеты, доступные слоты календаря.
   - Вывод: предложение расписания + задачи на неделю с учётом энергии/фокуса.
2. **Финансовый дашборд**
   - Визуализации расходов/доходов, бюджеты по категориям, прогноз остатка до конца месяца.
3. **Интеграции с календарями**
   - Импорт событий из Google/Apple, выбор календарей, двусторонняя синхронизация будущих 60 дней.
4. **Виджеты на главный экран**
   - iOS/Android: задачи дня, прогресс цели, баланс бюджета.
5. **Совместная работа (Pro roadmap)**
   - Шеринг задач/проектов с ролями «читатель/редактор», комментарии и упоминания.


========================================
FILE: ./Docs/LifeMerge/04_Development/Backlog/Tech_Debt.md
========================================

# Tech Debt backlog

| ID | Область | Описание | Риск | План фикса |
|----|---------|----------|------|------------|
| TD-1 | Мобильный клиент | Неполное покрытие unit-тестами use-case «планирование недели» | Средний | Добавить тесты на пересчёт расписания и синхронизацию до спринта 3 |
| TD-2 | Backend Tasks | Нет дедубликации idempotency-key для повторных POST задач | Высокий | Ввести уникальный индекс по `request_id` и фоновые задачи для очистки записей | 
| TD-3 | AI сервис | Векторизация описаний целей синхронная, блокирует запрос | Средний | Перевести в очередь Celery/BullMQ, добавить кэш по goal_id |
| TD-4 | DevOps | Отсутствует автоматика ротации ключей JWT/FCM | Высокий | Настроить KMS и cron-ротацию раз в 90 дней |
| TD-5 | Данные | Нет истории изменений задач | Низкий | Добавить audit-таблицу и soft delete в схеме v1.1 |


========================================
FILE: ./Docs/LifeMerge/04_Development/Coding_Standards/API_Usage_Guide.md
========================================

# Руководство по использованию API

## Аутентификация
- Получаем `access_token` и `refresh_token` через `/auth/login` (см. Auth_API.md).
- Добавляем `Authorization: Bearer <token>` к каждому запросу.
- При 401 с причиной `token_expired` вызываем `/auth/refresh`, повторяем оригинальный запрос с тем же `request_id`.

## Общие правила запросов
- **Базовый URL:** определяется окружением (`DEV_API_BASE`, `STAGE_API_BASE`, `PROD_API_BASE`).
- **Версионирование:** используем префикс `/v1/` для всех путей.
- **Идемпотентность:** для POST/PATCH/DELETE передаём `X-Idempotency-Key` или поле `request_id` в body.
- **Пагинация:** `?limit=50&cursor=<ts_or_id>`; получаем `next_cursor` в ответе.
- **Локализация/часовой пояс:** заголовок `X-Timezone` (IANA) и `Accept-Language`.

## Ошибки
- Формат: `{ "error": { "code": "validation_error", "message": "...", "details": {...} } }`.
- Статусы: 400 валидация, 401 auth, 403 permissions, 404 not found, 409 конфликт версии, 429 лимиты, 500/503 сервер.
- Все клиенты логируют `request_id` из ответа или заголовка.

## Практики для мобильного клиента
- Отправлять `app_version`, `platform`, `device_id` в заголовках для аналитики и feature flags.
- Кешировать справочники (категории задач/финансов) с TTL и ETag; при 304 используем локальные данные.
- Объединять небольшие изменения в батчи (например, до 20 событий календаря) для снижения сетевых вызовов.
- Использовать `If-Modified-Since`/`If-None-Match` при загрузке календаря и задач.

## Тестовые данные
- В dev/stage заведены тест-аккаунты `demo_userX@example.com` с предзаполненными задачами, целями и транзакциями.
- Для нагрузочных тестов генерируйте синтетические данные через скрипт `tools/seed_demo_data.py` (backend репозиторий).


========================================
FILE: ./Docs/LifeMerge/04_Development/Coding_Standards/Architecture_Rules.md
========================================

# Архитектурные правила LifeMerge

Документ обобщает договорённости из TECHNICAL SPECIFICATIONS и ТЗ для реализации Flutter-клиента, backend и AI-сервисов.

## Базовые принципы
- **Слойность:** презентация → application/service → domain → infrastructure. Прямых зависимостей от UI к хранилищу нет.
- **Чистые модели:** DTO для сети/БД, domain-модели для логики, мапперы обязательны.
- **Idempotency & retries:** все mutating-эндпоинты backend принимают `request_id` для безопасных повторов.
- **Трассировка:** каждый запрос несёт `X-Request-Id`; логируем путь, пользователя, время, статус.

## Интеграции
- **AI-сервис:** отдельный REST, вызывается backend-воркерами. UI не ходит к AI напрямую.
- **Платёжки/FCM/APNs:** обёрнуты адаптерами; конфиги через переменные окружения.

## Данные и офлайн
- **Единый источник истины:** серверная БД PostgreSQL. Клиент хранит кеш (sqflite) + очередь синхронизации.
- **Версионирование схемы:** миграции через `migration_version`; несовместимые изменения только по фичефлагу.
- **Конфликты:** правило «последний апдейт выигрывает» с сохранением истории изменений для задач/событий.

## Безопасность
- JWT access (15–30 мин) + refresh; все сервисы ходят только по HTTPS.
- Роли: user, admin, support; проверка авторизации на уровне handler + сервис.
- PII и финансовые суммы логируются только в хэшированном/маскированном виде.

## Производительность
- Пагинация по cursor/`updated_at`, лимит 50 записей по умолчанию.
- Индексы по `(user_id, due_date)`, `(user_id, status)` для задач, `(user_id, date)` для транзакций.
- Критичные запросы тестируются на 95‑перцентиль не более 200 мс в stage-среде.


========================================
FILE: ./Docs/LifeMerge/04_Development/Coding_Standards/Dart_Style_Guide.md
========================================

# Dart Style Guide (LifeMerge)

- Следуем официальному `dart style`; используем `dart format` без переопределения ширины строки.
- Именование: классы/enum в `PascalCase`, методы/поля/переменные в `camelCase`, константы в `lowerCamel` с `k` не используем.
- Публичные API должны иметь `///` документацию с примерами использования.
- Избегаем `dynamic` и `!`; используем null-safety, опциональные поля помечаем `?`.
- Коллекции неизменяемые по умолчанию (`UnmodifiableListView`, `const` widgets) когда это безопасно.
- Обработка ошибок через `Either<Result, Failure>` или `Result<T>` вместо выбрасывания исключений в бизнес-логике.
- Импортируем через `package:lifemerge/...`; относительные импорты только внутри модуля.
- Файлы экранов/виджетов именуем по компоненту: `tasks_list_page.dart`, `task_tile.dart`, `goal_progress_chart.dart`.
- Не добавляем `try/catch` вокруг импортов; используется автоматический анализ зависимостей pub.


========================================
FILE: ./Docs/LifeMerge/04_Development/Coding_Standards/Flutter_Best_Practices.md
========================================

# Flutter: лучшие практики

## Архитектура клиента
- Используем **MVVM + Provider/riverpod** для управления состоянием экранов.
- Навигация через `go_router`; маршруты описываем декларативно, учитывая deeplink из пушей.
- Разделяем слой данных (`repositories`), домена (`use_cases`), UI (`views/widgets`).

## Работа с сетью
- HTTP-клиент оборачиваем в `ApiClient` с перехватчиками для токенов и логов.
- Повтор запросов с backoff для сетевых ошибок, но не более 3 попыток.
- Сериализация через `json_serializable`, время передаём в ISO8601 + timezone.

## UI и доступность
- Используем дизайн-токены из `UI_Kit/Design_Tokens.json` и кастомные `ThemeExtension`.
- Минимальный размер тапа 44×44, контраст текста WCAG AA.
- Все иконки и тексты должны поддерживать тёмную тему; тестируем на эмуляторах iOS/Android.

## Офлайн
- Локальное хранилище `sqflite` + `hive` для быстрых настроек.
- Очередь синхронизации хранит pending-операции; при восстановлении сети выполняем батчами.
- Конфликты показываем пользователю (баннер) с выбором варианта или автопринятием сервера.

## Качество
- Unit-тесты для `use_cases` и мапперов, widget-тесты для ключевых экранов (календарь, задачи, финансы).
- Включаем `flutter analyze`, `dart format`, `dart test` в pre-push hook.
- Производительность проверяем `profile`-сборкой: время фрейма < 16 мс на целевых девайсах Pixel 6 / iPhone 12.


========================================
FILE: ./Docs/LifeMerge/04_Development/Sprint_Planning/Template_Sprint_Plan.md
========================================

# Sprint {{номер}} – Planning

## 1. Sprint Goals
- Цель 1  
- Цель 2  

---

## 2. Sprint Backlog
| ID | User Story | Задача | Story Points | Ответственный |
|----|------------|--------|--------------|----------------|

---

## 3. Capacity
| Член команды | Доступные часы | Комментарий |
|--------------|----------------|--------------|

---

## 4. Risks
- Риск 1  
- Риск 2  

---

## 5. Definition of Done (DoD)
| Компонент | Критерий |
|-----------|----------|

---

## 6. Retro Notes (по окончании)
- Что получилось  
- Что не получилось  
- Что улучшить  


========================================
FILE: ./Docs/LifeMerge/05_QA/Automation/CI_Test_Config.md
========================================

# CI Test Config

- Запуск `dart test` и `flutter test --tags=smoke` на каждом PR.
- Backend/AI: `pytest -q`, `npm test` (если Node), покрытие >70% для ядра.
- Lint: `dart format --set-exit-if-changed`, `flutter analyze`, `ruff`, `eslint`.
- Интеграционные тесты (эмуляторы) ночью по расписанию: онбординг, создание задачи, синк офлайн → онлайн.
- Отчёты в CI: JUnit + coverage, отправка в Codecov; уведомления в Slack/Telegram при падениях.


========================================
FILE: ./Docs/LifeMerge/05_QA/Checklists/Regression_Checklist.md
========================================

# Regression Checklist (основные блоки)

## Аутентификация
- [ ] Signup/login/logout/refresh, восстановление пароля.

## Задачи/Цели
- [ ] CRUD задач и подзадач, напоминания, статусы.
- [ ] Фильтры/сортировки, поиск.
- [ ] Связка задач с целями, обновление прогресса целей.

## Календарь
- [ ] Создание/редактирование/удаление событий, повторения.
- [ ] Синхронизация с внешними календарями, обработка вебхуков.

## Финансы
- [ ] CRUD категорий и транзакций, бюджеты.
- [ ] Корректные валюты и округление.

## Inbox/Уведомления
- [ ] Добавление элементов inbox, конвертация в задачи/события.
- [ ] Получение пушей и настройка времени отправки.

## Офлайн/Синхронизация
- [ ] Рабочие сценарии офлайн → онлайн, отсутствие дублей.

## AI
- [ ] План недели создаётся, корректно создаёт задачи/события.
- [ ] Ограничения по лимитам/ошибкам отображаются корректно.


========================================
FILE: ./Docs/LifeMerge/05_QA/Checklists/Release_Checklist.md
========================================

# Release Checklist

- [ ] Все задачи релиза в статусе Done, нет блокеров.
- [ ] Пройдены Smoke и Regression (см. отдельные чеклисты).
- [ ] Билды подписаны и загружены в TestFlight/Play Console.
- [ ] Миграции БД применены на stage и проверены.
- [ ] Алёрты/дашборды сконфигурированы для версии.
- [ ] Обновлены маркетинговые тексты и privacy policy.
- [ ] План отката согласован, проверено восстановление из бэкапа.


========================================
FILE: ./Docs/LifeMerge/05_QA/Checklists/Smoke_Test_Checklist.md
========================================

# Smoke Test Checklist

- [ ] Установка/запуск приложения (iOS/Android).
- [ ] Регистрация нового пользователя и логин существующего.
- [ ] Создание задачи, изменение статуса, удаление.
- [ ] Создание события календаря, привязка задачи, просмотр расписания.
- [ ] Добавление цели, связка задач с целью.
- [ ] Добавление расхода/дохода, просмотр дашборда.
- [ ] Получение пуша-напоминания.


========================================
FILE: ./Docs/LifeMerge/05_QA/QA_Plan.md
========================================

# 🧪 QA PLAN — LifeMerge (MVP, Pro 1.0+ Ready)

## 1. Цели QA

1. Обеспечить стабильную работу **ядра продукта**:

   * календарь,
   * задачи/цели,
   * финансы,
   * GTD Inbox,
   * AI-планировщик,
   * подписки и уведомления.
2. Минимизировать риск **потери/порчи данных** (особенно задач, целей, финансов).
3. Подтвердить, что:

   * UX соответствует дизайну,
   * логика Free/Pro соблюдается,
   * AI **не нарушает** пользовательские правила.
4. Обеспечить предсказуемое качество на каждом релизе (регрессия).

---

## 2. Область охвата (Scope)

### Входит:

* Мобильные приложения: iOS + Android.
* Все ключевые модули:

  * Регистрация/логин.
  * Календарь + рабочие графики.
  * Задачи/цели/проектная структура.
  * Финансы (доходы/расходы/регулярные).
  * Inbox (GTD).
  * AI-планировщик (Pro).
  * Уведомления.
  * Подписки/Trial.
  * Настройки (тема, уведомления, график, язык RU).
* Offline-режим (кэш + отложенная синхронизация).

### Не входит (на этап MVP, но отмечается как future):

* Web-версия.
* Полноценный конфликт-менеджмент при синхронизации.
* Сложная интеграция банков/HealthKit/Google Fit.
* Полностью автономный режим AI.

---

## 3. Типы тестирования

1. **Unit-тесты**

   * Бизнес-логика (use cases).
   * Парсинг/сериализация данных.
   * Локальные валидаторы.

2. **Integration tests**

   * Клиент ↔️ backend (через staging API).
   * Работа offline-очереди.
   * AI-запросы и обработка ответов.

3. **UI/UX (manual + automated)**

   * Отображение экранов.
   * Навигация.
   * Состояния (loading / empty / error).

4. **End-to-End (E2E)**

   * Жизненные сценарии:

     * создание цели → задач → расписание → финансы → AI-план → отчёт.

5. **Регрессионное тестирование**

   * Перед каждым релизом.

6. **Non-functional**

   * Производительность (basic).
   * Устойчивость (long-run).
   * Usability (ручное, по чек-листам).

7. **Security & Privacy (базовый уровень)**

   * Валидация auth-флоу.
   * Нет утечек чувствительных данных в логах.

---

## 4. Стратегия по уровням

### 4.1. Unit-тесты

**Цель:** поймать ошибки логики до UI/интеграции.

Покрыть:

* расчёт прогресса по целям,
* вычисление баланса бюджета,
* генерация временных интервалов в календаре,
* обработку настроек рабочего графика,
* базовую подготовку данных для AI-запроса.

**Критерий:**
для MVP — покрытие ключевых use-case модулей ≥ 70%.

---

### 4.2. Integration tests

Проверяем:

* корректность API-контрактов:

  * Auth,
  * Tasks,
  * Calendar,
  * Finance,
  * AI.
* работу локального кэша + синка:

  * создаём задачу offline → получаем её на другом устройстве после sync.

---

### 4.3. UI/UX тестирование

* Проверяем макеты Figma vs. реализация:

  * сетка,
  * типографика,
  * отступы,
  * состояния.
* Особо:

  * Тёмная тема.
  * Пустые состояния (нет задач, нет операций).
  * Ошибки (нет сети, ошибка AI, backend down).

---

### 4.4. E2E сценарии (основные)

**Сценарий 1: «Новый пользователь Free»**

1. Установка → онбординг.
2. Регистрация аккаунта.
3. Настройка рабочего графика.
4. Создание пары задач и цели.
5. Добавление финансовых записей.
6. Проверка календаря и пушей.

**Сценарий 2: «Pro с AI-планировщиком»**

1. Активация Trial (с тестовой картой).
2. Создание набора задач с приоритетами, дедлайнами, контекстами.
3. Запуск AI-планировщика на неделю.
4. Проверка:

   * AI не залез в запретные зоны (вечер, выходные, non-working).
   * расписание выглядит логично.
5. Принятие плана.
6. Проверка, что план реально применился в календаре.

**Сценарий 3: «Finance + Calendar»**

1. Добавить зарплату (регулярный доход).
2. Добавить несколько расходов (с и без привязки к событиям).
3. Привязать расход к событию в календаре (поход в кафе).
4. Проверить месячный отчёт.

**Сценарий 4: «Inbox → действие»**

1. Набросать 5–10 элементов в Inbox.
2. Превратить часть в задачи, часть в цели, часть в финансовые события.
3. Проверить, что всё корректно отобразилось в соответствующих разделах.

---

## 5. Test Matrix (что тестируется особенно тщательно)

### Модули и приоритет:

| Модуль         | Приоритет         | Уровень тестирования         |
| -------------- | ----------------- | ---------------------------- |
| Auth           | Высокий           | Unit, Integration, E2E       |
| Календарь      | Критический       | Unit, Integration, UI, E2E   |
| Задачи/цели    | Критический       | Unit, Integration, UI, E2E   |
| Финансы        | Высокий           | Unit, Integration, E2E       |
| Inbox          | Средний           | Integration, UI, E2E         |
| AI-планировщик | Критический (Pro) | Integration, E2E, спец-тесты |
| Подписки/Trial | Высокий           | Integration, E2E             |
| Уведомления    | Высокий           | Integration, device tests    |
| Настройки      | Средний           | UI, Integration              |
| Offline/sync   | Высокий           | Integration, E2E             |

---

## 6. Подход к AI-тестированию

### Особенность: AI ≠ детерминированный код.

### Что тестируем:

1. **Формат запроса/ответа**

   * структуру JSON,
   * обработку ошибок,
   * timeout.

2. **Соблюдение жёстких правил**

   * тест-кейсы:

     * Пользователь запрещает вечерние слоты → AI **не ставит** туда задачи.
     * Пользователь указывает выходной день → AI не планирует там работу.
     * Минимальный буфер между задачами → слоты не слепляются.

3. **Граничные кейсы**

   * очень много задач (AI должен часть оставить «unscheduled», а не ломать расписание),
   * очень мало свободного времени.

4. **UX-поведение**

   * если AI вернул пустой/ошибочный ответ:

     * показывается дефолтное сообщение,
     * приложение не крашится,
     * пользователь может продолжать вручную.

---

## 7. Стратегия по платформам и девайсам

### 7.1. iOS

* Минимальная версия: iOS 14
* Тестовые девайсы:

  * iPhone SE (малый экран),
  * iPhone 13/14 (основной),
  * желательно одно «старое» устройство.

### 7.2. Android

* Минимальная версия: Android 8 (API 26)
* Тестовые девайсы:

  * бюджетный (низкая мощность),
  * средний,
  * флагман (высокая частота, разные dpi).

Обязательно проверять:

* акцентные элементы (цвета/тексты) на разных DPI,
* корректность темы,
* пуши при закрытом приложении.

---

## 8. Test Environments

1. **Dev environment**

   * нестабильный,
   * использует dev-ветку,
   * данные могут очищаться.

2. **Staging environment**

   * максимально близок к продакшену:

     * та же схема БД,
     * тот же набор сервисов.
   * используется для:

     * интеграционных и E2E тестов,
     * regression перед релизом.

3. **Production**

   * только мониторинг, hotfix-проверки.

---

## 9. Test Artifacts

1. **Test Cases**

   * подробные шаги и expected results,
   * покрывают все User Stories.

2. **Checklists**

   * быстрые проверки перед релизом (smoke + sanity).

3. **Bug reports**

   * оформляются в системе тикетов (Jira/YouTrack):

     * шаги,
     * фактический результат,
     * ожидаемый результат,
     * severity (Critical/Major/Minor),
     * скриншоты/видео.

4. **Test Summary Reports**

   * после каждого спринта/релиза:

     * что тестировалось,
     * сколько тест-кейсов прошло/провалилось,
     * какие критические баги остались/исправлены.

---

## 10. Критерии начала тестирования (Entry Criteria)

* Feature/branch собран в **staging-билд**.
* Пройдены unit-тесты.
* Есть:

  * актуальные макеты,
  * описание бизнес-логики,
  * настройки тестовых аккаунтов (Free, Pro, Trial).
* Backend для нужного функционала развёрнут и доступен.

---

## 11. Критерии завершения тестирования (Exit Criteria)

* Все **критические** баги исправлены.
* **Major** — либо исправлены, либо согласованы и вынесены в backlog с пометкой.
* Регрессионные тесты пройдены по ключевым флоу:

  * логин,
  * календарь,
  * задачи,
  * финансы,
  * AI-планировщик,
  * подписки.
* Test Summary Report подготовлен и одобрен.

---

## 12. Риски и как их снижать

1. **AI непредсказуем в редких кейсах**

   * Решение:

     * жёсткие hard constraints,
     * fallback, UI-предупреждения.

2. **Разночтения между mobile и backend API**

   * Решение:

     * контрактные тесты,
     * Postman collection / OpenAPI.

3. **Баги в оффлайн-сценариях**

   * Решение:

     * отдельные E2E кейсы для offline → online,
     * тесты с выключением сети во время операций.



========================================
FILE: ./Docs/LifeMerge/06_Release/AppStore/Description.md
========================================

# App Store / Google Play Description (draft)

**LifeMerge — единое приложение для времени, целей и финансов.**

- Планируйте день и неделю в одном календаре.
- Управляйте задачами и целями, отслеживайте прогресс.
- Ведите расходы и бюджеты, получайте финансовые инсайты.
- AI-помощник предложит расписание и подскажет приоритеты.
- Работает офлайн, синхронизируется между устройствами.

**Почему LifeMerge?**
- Всё в одном: календарь, задачи, цели, финансы.
- Лёгкий старт: готовые шаблоны и умные подсказки.
- Для людей из СНГ: локализация, рубли/тенге/гривны, напоминания в нужном часовом поясе.

Поддержка: support@lifemerge.app


========================================
FILE: ./Docs/LifeMerge/06_Release/AppStore/Privacy_Policy.md
========================================

# Privacy Policy (кратко)

- Мы собираем: email, имя, часовой пояс, данные задач/целей/финансов, технические метаданные устройства.
- Используем: для оказания сервиса, персонализации, аналитики (Mixpanel/Amplitude), отправки уведомлений.
- Не продаём данные третьим лицам; передача только обработчикам (хостинг, аналитика) по договорам.
- Данные хранятся на защищённых серверах, резервируются; пользователи могут запросить выгрузку или удаление аккаунта.
- Cookies/токены применяются для аутентификации и сессий; пуш-токены хранятся отдельно.
- Контакты: privacy@lifemerge.app


========================================
FILE: ./Docs/LifeMerge/06_Release/Beta_Testing/Beta_Feedback.md
========================================

# Beta Feedback Process

## Сбор
- Форма Google/Typeform: NPS, удовлетворённость по модулям (календарь, задачи, финансы, AI), багрепорты.
- Встроенная кнопку «Сообщить об ошибке» (отправляет логи + скрин по согласию).
- Телеграм-чат с быстрыми опросами.

## Обработка
- Все фидбеки заносятся в борд: тип (bug/UX/feature), приоритет, модуль, воспроизводимость.
- Критичные баги → горячие фиксы до следующего билда; улучшения — в backlog.
- Еженедельный дайджест по метрикам: activation, crash-free, time to first value.

## Ответ пользователям
- Благодарность и статус: принято/в работе/отклонено.
- Релиз-ноты тестовых сборок с закрытыми пунктами.


========================================
FILE: ./Docs/LifeMerge/06_Release/Beta_Testing/Invitations.md
========================================

# Beta Testing Invitations

## Кого зовём
- Ранние пользователи из целевой аудитории (25–40, СНГ), существующие клиенты productivity-сообщества.
- Команда/партнёры, сотрудники компании.

## Каналы
- Email-рассылка по списку ожидания.
- Телеграм-канал/чат с инструкциями и обратной связью.
- App Store TestFlight и закрытый трек Google Play.

## Сообщение-приглашение (шаблон)
```
Привет! Запускаем бету LifeMerge — планировщик времени, целей и финансов.
1) Установи приложение по ссылке <TestFlight/Google Play>.
2) Пройди онбординг и создай минимум 3 задачи и 1 цель.
3) Поделись фидбеком в форме: <ссылка>.
Спасибо! Команда LifeMerge
```


========================================
FILE: ./Docs/LifeMerge/06_Release/Release_Plan.md
========================================

# Release Plan

## Milestones
1. **Beta (Internal)** — сбор фидбека, crash-free >95%, основные баги закрыты.
2. **Release Candidate (Stage)** — подключены платёжные/календари, регрессия пройдена.
3. **Prod Launch** — rollout 10→50→100%, мониторинг метрик, поддержка 24/7 первые 72 часа.

## Чеклист перед выкладкой
- Пройдены Smoke/Regression чек-листы (см. QA/Checklists).
- Миграции БД применены и протестированы на stage.
- Обновлены маркетинговые материалы (App Store/Google Play), privacy policy.
- Настроены алёрты и дашборды.

## Пост-релиз
- Мониторинг error rate, p95, crash-free; план обратного отката.
- Сбор фидбека от первых пользователей, быстрые фиксы.


========================================
FILE: ./Docs/Metrics Plan.md
========================================

# 📊 **METRICS PLAN — LifeMerge**

## Структура документа:

1. Принципы метрик
2. North Star Metric
3. Продуктовые метрики ядра (Time/Goals/Finance)
4. Метрики AI
5. Метрики монетизации и подписок
6. Метрики удержания и вовлеченности
7. Метрики активации
8. Финансовые метрики (финмодуль ≠ монетизация)
9. Метрики качества продукта
10. Технические метрики
11. Воронки
12. Дашборды
13. Алерты (пороговые значения)
14. Метрики по этапам Roadmap (MVP → Pro 1.0 → Pro 2.0 → Autonomy Mode)

---

# 1. Принципы метрик LifeMerge

1. Метрики должны **измерять поведение жизни пользователя**, а не абстрактные клики.
2. Система метрик отражает трио:

   * **Время**
   * **Цели**
   * **Финансы**
3. AI — отдельная критическая область, требующая своих KPI (accuracy → adoption → satisfaction).
4. Free → Pro монетизация строится на:

   * **использовании фич**,
   * **ощущении потери после Trial**,
   * **повышении ценности от AI/аналитики**.

---

# 2. North Star Metric (NSM)

## **NSM: Weekly Planned Hours + Completed Hours Rate**

Формула:

```
NSM = (Запланированные часы за неделю + выполненные часы) / всего часов задач
```

Почему это NSM:

* отражает реальное использование продукта как *жизненной операционной системы*;
* объединяет задачи, цели и календарь в общий контур;
* повышается, когда продукт реально помогает жить эффективнее.

---

# 3. Продуктовые метрики ядра (Time / Goals / Finance)

## 3.1. Time (календарь)

* **DAU (Calendar View)**
* **Weekly Active Planners (WAP)** — число пользователей, использующих календарь в течение недели
* **Event Creation Rate**
* **Task-to-Calendar Rate** (доля задач, которые в итоге были привязаны ко времени)
* **Reschedule Count per Week** — показатель стабильности планов
* **Workshift Usage** — % пользователей, использующих сменные графики

---

## 3.2. Goals

* **Goal Creation Rate**
* **Average Tasks per Goal**
* **Goal Completion Rate (quarter)**
* **Stalled Goals (нет задач > 14 дней)**
* **Goals with no progress ≥ 30 дней** (AI должен снижать этот показатель)

---

## 3.3. Tasks

* **Task Completion Rate**
* **Carry-over Rate (перенос задач)**
* **Overdue Tasks Count**
* **Daily Execution Streak**
* **Tasks with Context Assigned (%)**
* **Tasks with Energy Assigned (%)**

---

## 3.4. Finance

* **Finance Record Creation Rate**
* **Expense/Incomes Ratio**
* **% операций, привязанных к календарю**
* **Monthly Budget Accuracy**:

  ```
  accuracy = (planned - actual) / planned
  ```
* **Recurring Transactions Stickiness (операции, которые стабильно повторяются без удаления)**
* **Finance-to-Goal Link Rate** (сколько расходов направлены на цели)

---

# 4. Метрики AI

AI — ключевая зона LifeMerge. Метрики делятся на 4 слоя: adoption → usage → accuracy → satisfaction.

## 4.1. Adoption

* **% пользователей Pro, которые запустили AI хотя бы 1 раз**
* **AI Trial Activation Rate**
* **AI Planner Session Rate**
* **% задач, использованных в AI-плане**

---

## 4.2. Usage

* AI Sessions per Week
* Average tasks per session
* % пользователей, использующих AI для недельного планирования

---

## 4.3. Accuracy & Constraints Compliance

### ⚠️ критические метрики

* **Hard rules violation rate** (должно быть < 1%)
  (AI не должен ставить задачи ночью, в запретные дни, вне рабочих часов)
* **Deadline risk rate**
* **Average schedule deviation** (насколько позже человек реально выполняет задачи относительно предложенного плана)

---

## 4.4. Satisfaction

* AI Plan Acceptance Rate:

  * Accept All
  * Accept Partially
  * Reject
* NPS по AI-модулю
* Reason Tags (manual):

  * «План неудобный»
  * «Не учёл контексты»
  * «Слишком плотный день»

---

# 5. Метрики монетизации (Subscription Metrics)

### Core subscription KPIs:

* **Free → Trial Conversion Rate**
* **Trial → Paid Conversion Rate**
* **Cancel During Trial Rate**
* **Monthly Churn Rate**
* **Annual Churn Rate**
* **LTV (lifetime value)**
* **ARPU / ARPPU**

### Поведенческие предикторы:

* AI usage correlates → вероятность подписки
* Goals setup during trial → коррелирует с retention
* Number of scheduled tasks → конверсия в Pro

---

# 6. Retention & Engagement

### Основные:

* **D1, D3, D7, D14, D30 Retention**
* **WAU / MAU**
* **Sticky Factor = DAU/MAU**

### Продуктовые:

* **Planning Retention** — пользователи возвращаются планировать
* **Execution Retention** — пользователи возвращаются отмечать выполнение
* **Finance Logging Retention**

### Когортный анализ:

* Когорты по:

  * типу профессии (обычный / сменный)
  * использованию AI
  * использованию финмодуля
  * Free vs Pro
  * пользователи, которые заполнили Inbox

---

# 7. Метрики активации (AHA-moments)

### AHA-moments LifeMerge:

1. Пользователь заполнил календарь хотя бы на 24 часа вперёд
2. Создал цель + привязал к ней ≥ 3 задачи
3. Добавил > 3 финансовых операции
4. Запустил AI-планировщик хотя бы 1 раз

### Activation Metrics:

* Activation Rate = % пользователей, достигших ≥ 2 из 4 AHA
* Time to Activation (TTA)

---

# 8. Финансовые метрики продукта (не путать с подписками)

Цель: измерять финансовую грамотность и планирование пользователя.

* Monthly Net Balance Stability
* Budget Accuracy
* % изменений бюджета
* % финансовых событий, совпавших с календарём
* Spending deviation by category
* Unexpected expenses frequency

---

# 9. Метрики качества продукта

### Stability

* Crash-free sessions ≥ 99.5%
* API Error Rate < 1%
* Sync Queue Failure Rate < 2%

### Performance

* Рендеринг календаря ≤ 16ms на слот
* Время открытия приложения ≤ 1 секунда
* Ответ AI ≤ 5 секунд (95th percentile)

### UX Quality

* Average task-flow completion time
* Rage taps (Amplitude metric)
* Drop-off внутри AI-планировщика

---

# 10. Технические метрики

* Server uptime ≥ 99.8%
* API latency < 200 ms
* Background jobs error rate < 1%
* DB slow queries > 500 ms — не более 1% запросов

---

# 11. Воронки (Funnel Metrics)

## 11.1. Onboarding funnel

1. Install
2. Open App
3. Registration Start
4. Registration Success
5. Working Schedule Setup
6. Reached Calendar
7. Reached Tasks
8. Activation event

---

## 11.2. Trial funnel

1. Free User
2. Open Paywall
3. Add Payment Method
4. Start Trial
5. AI Planner Usage
6. Trial End
7. Paid User

---

## 11.3. AI usage funnel

1. Open AI planner
2. Select period
3. Generate plan
4. Review plan
5. Accept plan
6. Follow schedule (optional metric)

---

## 11.4. Retention funnel

1. Week 1: opened app ≥ 3 раза
2. Week 2: заполнил календарь
3. Week 3: использовал задачи
4. Week 4: использовал финансы
5. Month 2: AI usage (если Pro)

---

# 12. Дашборды (Amplitude / Mixpanel)

## Dashboard 1 — Executive

* DAU / WAU / MAU
* NSM
* Trial → Paid
* AI Acceptance Rate
* Task Completion Rate
* Calendar Activity
* Finance Logging Rate

## Dashboard 2 — AI Quality

* Hard rule violations
* AI accuracy
* AI acceptance rate
* AI session count
* User rules usage
* Time-to-first-plan

## Dashboard 3 — Subscription

* Free → Trial
* Trial → Paid
* Monthly churn
* Cohort revenue
* Price sensitivity

## Dashboard 4 — Retention

* Stickiness
* D1/D7/D30
* Cohort retention curves

---

# 13. Алерты (alerting system)

| Метрика                            | Порог         | Действие                   |
| ---------------------------------- | ------------- | -------------------------- |
| Crash-free < 98%                   | критично      | блокируем релиз            |
| API error rate > 3%                | критично      | investigate backend        |
| AI rule violation > 2%             | критично      | отключение AI-feature flag |
| D1 retention падает на 20%         | риск          | анализ onboarding          |
| Trial → Paid < 10%                 | риск          | изменить ценность Pro      |
| AI acceptance < 40%                | риск          | улучшить plan heuristics   |
| Calendar usage падает 3 дня подряд | ранний сигнал | UX-проверка                |

---

# 14. Метрики по Roadmap этапам

## MVP

* D7 retention ≥ 25%
* Calendar usage ≥ 60% DAU
* Task creation ≥ 40% DAU
* Finance usage ≥ 20% DAU
* Crash-free ≥ 99.5%

## Pro 1.0

* AI sessions ≥ 15% всех активных пользователей
* AI acceptance ≥ 60%
* Trial → Paid ≥ 25%

## Pro 2.0

* Inter-sphere analytics usage ≥ 35% Pro
* Web-weekly active ≥ 20% всех пользователей

## Autonomy Mode

* Users using semi-auto mode ≥ 10%
* AI zone violation < 0.5%
* Productivity uplift score (опросник) ≥ +15%

North Star Metric – WPAR (Weekly Planning Activity Rate): доля активных пользователей за неделю, которые составили интегрированный план – связали задачу с событием календаря и целью.
Формула: WPAR = (число пользователей с ≥1 связкой «задача+событие+цель» за неделю) / (общее число Weekly Active Users) × 100%.
Обоснование: этот показатель отражает основную ценность продукта – активное еженедельное планирование. Чем выше WPAR, тем больше пользователей полноценно используют приложение для планирования времени, задач и целей, что коррелирует с долгосрочным удержанием.

Удержание на 7-й день (Retention D7): процент новых пользователей, которые возвращаются в приложение через 7 дней после регистрации. Используется для оценки удержания аудитории; целевой уровень – >30% возвращений на 7-й день. <br/>События: отслеживается по повторным визитам пользователя (например, событие App_Open на 7-й день после Signup).

Task-to-Calendar Attachment Rate: доля задач, которые были привязаны к событиям календаря. Формула: (задачи, добавленные в календарь) / (все созданные задачи) × 100%. Показатель демонстрирует, насколько активно пользователи планируют задачи во времени (в календаре). Стремимся повышать этот процент, так как привязка задач к расписанию свидетельствует о глубоком использовании продукта. <br/>События: отслеживается по событиям Task_Created и Task_Scheduled (сколько задач создано и сколько из них размещено на календаре).

Конверсия онбординга и настройки календаря: доля новых пользователей, которые завершили онбординг и создали первую задачу/событие (A1), а также подключили календарь (настроили расписание, этап A2) после регистрации. Важный показатель активации новых пользователей; целевой уровень A1-конверсии – >70%, при времени до достижения A1 < 5 минут. <br/>События: фиксируется событиями Onboarding_Complete (успешное прохождение onboarding) и Calendar_Connected (подключение внешнего календаря) у каждого нового пользователя.

========================================
FILE: ./Docs/TECHNICAL SPECIFICATIONS.md
========================================

# 🧩 **TECHNICAL SPECIFICATIONS — LifeMerge**

---

# 1. Архитектура системы

## 1.1. Общая архитектура

LifeMerge — это **клиент-серверная** система:

* **Frontend:** Flutter-приложение (iOS + Android)
* **Backend API:** REST / JSON
* **AI-модуль:** отдельный сервис (может быть Python/Node), вызываемый через REST
* **База данных:** PostgreSQL
* **Сервис фоновых задач:** Celery / Sidekiq / BullMQ (зависит от backend stack)
* **Push-уведомления:** Firebase Cloud Messaging (Android), APNs (iOS)
* **Аналитика:** Mixpanel/Amplitude + серверные события

Архитектура уровня продукта:

```
┌───────────────────────────┐
│         Flutter App        │
│  (Presentation + Logic)    │
└──────────────┬────────────┘
               │ REST / WebSocket (later)
┌──────────────┴────────────┐
│         Backend API        │
│  Auth, Calendar, Tasks,    │
│  Finance, Goals, Billing   │
└──────────────┬────────────┘
               │
      ┌────────┴─────────┐
      │    AI Service     │
      │ (Planner, Insights)│
      └────────┬──────────┘
               │
      ┌────────┴──────────┐
      │   PostgreSQL DB    │
      └────────────────────┘
```

---

# 2. Архитектура Flutter-клиента

## 2.1. Структура приложения

Используем слоистую архитектуру:

### **1) Presentation Layer**

* UI (Flutter Widgets / Material 3 / Custom components)
* State management: **Riverpod** (Providers + Notifiers)

### **2) Domain Layer**

* Entities (Task, Goal, Event, FinanceRecord, UserSettings)
* UseCases (например: CreateTask, GenerateAIPlan)

### **3) Data Layer**

* Repositories (abstract → implement: remote + local)
* Data sources:

  * RemoteDataSource (Dio)
  * LocalDataSource (Hive/sqflite)
  * SyncQueue (offline)

### **4) Core**

* Exceptions
* Helpers
* Constants
* Logging
* Env variables

---

## 2.2. Папочная структура

```
lib/
  core/
    errors/
    utils/
    theme/
    localization/
  features/
    auth/
    calendar/
    tasks/
    goals/
    finance/
    inbox/
    ai_planner/
    settings/
  data/
    repositories/
    datasources/
    models/
  domain/
    entities/
    usecases/
  app.dart
  main.dart
```

---

# 3. Технологический стек

## Flutter (Frontend)

* **Language:** Dart 3.x
* **Framework:** Flutter 3.x
* **State:** Riverpod
* **Networking:** Dio
* **Local storage:** Hive или sqflite
* **Background tasks:** Workmanager (Android) + BGTasks (iOS) для синхронизации
* **Push:** Firebase Messaging
* **Crash reports:** Sentry или Firebase Crashlytics
* **Analytics:** Amplitude / Mixpanel

## Backend

* Language: **Node.js (NestJS)** или **Python (FastAPI)**
  (рекомендация — FastAPI для AI-интеграций или NestJS для структурности)
* Database: PostgreSQL
* ORM: Prisma / SQLAlchemy
* Queue: Redis + BullMQ / Celery
* AI service: Python (LangChain + OpenAI API / Local models)

---

# 4. Модель данных (DB Schema)

## 4.1. Таблица Users

| Поле          | Тип      | Описание       |
| ------------- | -------- | -------------- |
| id            | UUID     | PK             |
| email         | string   | уникальный     |
| password_hash | string   |                |
| timezone      | string   |                |
| currency      | string   |                |
| is_pro        | boolean  | подписка       |
| trial_end     | datetime | дата окончания |
| created_at    | datetime |                |
| updated_at    | datetime |                |

---

## 4.2. Goals (цели)

| Поле        | Тип       |
| ----------- | --------- |
| id          | UUID      |
| user_id     | FK        |
| title       | string    |
| description | text      |
| category    | string    |
| deadline    | datetime? |
| progress    | float     |
| created_at  | datetime  |

---

## 4.3. Tasks

| Поле               | Тип                        |
| ------------------ | -------------------------- |
| id                 | UUID                       |
| user_id            | FK                         |
| goal_id            | FK?                        |
| title              | string                     |
| description        | text?                      |
| priority           | enum(P0,P1,P2)             |
| context            | string                     |
| energy             | enum(light,medium,heavy)   |
| estimated_duration | int (min)                  |
| deadline           | datetime?                  |
| is_recurring       | boolean                    |
| recurrence_rule    | string (RRULE)             |
| status             | enum(open, done, canceled) |
| created_at         | datetime                   |

---

## 4.4. CalendarEvents

| Поле              | Тип                                    |
| ----------------- | -------------------------------------- |
| id                | UUID                                   |
| user_id           | FK                                     |
| type              | enum(event, task_block, finance_event) |
| title             | string                                 |
| start_time        | datetime                               |
| end_time          | datetime                               |
| linked_task_id    | FK?                                    |
| linked_finance_id | FK?                                    |
| category          | string                                 |
| created_at        | datetime                               |

---

## 4.5. FinanceRecords

| Поле            | Тип                   |
| --------------- | --------------------- |
| id              | UUID                  |
| user_id         | FK                    |
| type            | enum(income, expense) |
| category        | string                |
| amount          | decimal               |
| currency        | string                |
| linked_event_id | FK?                   |
| is_recurring    | boolean               |
| recurrence_rule | string                |
| date            | datetime              |
| created_at      | datetime              |

---

## 4.6. InboxItems

| Поле       | Тип                             |
| ---------- | ------------------------------- |
| id         | UUID                            |
| user_id    | FK                              |
| text       | string                          |
| type       | enum(idea, task, goal, finance) |
| status     | enum(active, processed)         |
| created_at | datetime                        |

---

# 5. API Specification (REST)

Ниже — укрупнённая спецификация.

---

## 5.1. Auth API

### POST `/auth/register`

### POST `/auth/login`

### POST `/auth/refresh`

### POST `/auth/reset-password-request`

### POST `/auth/reset-password-confirm`

---

## 5.2. Calendar API

### GET `/calendar?from=&to=`

Возвращает события периода.

### POST `/calendar/event`

Создать событие.

### PATCH `/calendar/event/{id}`

### DELETE `/calendar/event/{id}`

---

## 5.3. Tasks API

### GET `/tasks`

### POST `/tasks`

### PATCH `/tasks/{id}`

### DELETE `/tasks/{id}`

### POST `/tasks/{id}/schedule`

Привязывает задачу к календарю.

---

## 5.4. Goals API

### GET `/goals`

### POST `/goals`

### PATCH `/goals/{id}`

### DELETE `/goals/{id}`

---

## 5.5. Finance API

### GET `/finance?from=&to=`

### POST `/finance`

### PATCH `/finance/{id}`

### DELETE `/finance/{id}`

---

## 5.6. Inbox API

### GET `/inbox`

### POST `/inbox`

### POST `/inbox/{id}/convert-to-task`

### POST `/inbox/{id}/convert-to-goal`

### POST `/inbox/{id}/convert-to-finance`

---

## 5.7. AI Planner API

### POST `/ai/plan`

**Body:**

```
{
  "tasks": [...],
  "calendar": [...],
  "rules": {...},
  "period_start": "...",
  "period_end": "..."
}
```

**Response:**

```
{
  "suggestions": [
    {
      "task_id": "...",
      "action": "schedule" | "move" | "unscheduled",
      "start_time": "...",
      "end_time": "..."
    }
  ]
}
```

---

# 6. Offline & Sync Architecture

## 6.1. Local cache

* Хранит:

  * события,
  * задачи,
  * цели,
  * финансы,
  * inbox.

## 6.2. Sync Queue (очередь синхронизации)

Каждое offline-действие создаёт **SyncEntry**:

```
{
  id,
  endpoint,
  method,
  payload,
  timestamp,
  status: pending/sent
}
```

При восстановлении сети:

* очередь проходит по FIFO;
* в случае конфликта → стратегия MVP:
  **последний апдейт побеждает (Last Write Wins)**.

---

# 7. Push Notifications

## iOS

* APNs через Firebase Messaging
* background notification handler

## Android

* Firebase Messaging

Типы пушей:

1. Начало события
2. Дедлайны задач
3. Финансовые события

---

# 8. AI Module Architecture

AI сервис — отдельное приложение:

### Input:

* список задач,
* расписание,
* пользовательские правила,
* ограничения (контексты, energy),
* желаемый период.

### Output:

* предложения расписания

### Методы:

* LLM-assisted reasoning
* Hard constraints engine
* Soft scoring heuristics

### Контроль ошибок:

* если AI не смог спланировать → вернуть пустой список
* клиент покажет сообщение
* fallback: "Распределите задачи вручную"

---

# 9. Analytics Specification

### Все события отправляются:

* через Firebase → BigQuery
  или
* напрямую в Amplitude / Mixpanel

### События:

* `task_created`
* `task_completed`
* `goal_created`
* `finance_record_created`
* `ai_plan_requested`
* `ai_plan_accepted`
* `ai_plan_rejected`
* `subscription_trial_started`
* `subscription_upgraded`
* `retention_login`

### Параметры:

* user_id
* timestamp
* device
* platform
* type (для задач/финансов/целей)

---

# 10. Security Requirements

1. Все запросы — **HTTPS**
2. JWT access + refresh
3. Пароли — **bcrypt**
4. Защита от:

   * brute force,
   * replay attacks,
   * rate limiting API
5. Доступ к AI API — только через backend (приложение не получает ключ напрямую).

---

# 11. API Versioning

Версионирование всегда через URL:

```
/api/v1/tasks
/api/v1/calendar
/api/v1/ai/plan
```

v2 появится при изменении структур данных.

---

# 12. CI/CD

## Mobile

* Codemagic или GitHub Actions
* Сборки:

  * dev build,
  * staging build,
  * production build.

## Backend

* GitHub Actions
* Автотесты
* Deploy в Docker/Kubernetes
* Blue-Green / Rolling updates



========================================
FILE: ./Docs/ДИЗАЙН-ПРОТОТИПЫ.md
========================================

# 🎨 **ДИЗАЙН-ПРОТОТИПЫ / UI-KIT (ОПИСАНИЯ + СПЕЦИФИКАЦИИ)**

*LifeMerge — минималистичная Life OS с премиальной эстетикой.*

---

# 1. ДИЗАЙН-ПРИНЦИПЫ ПРОДУКТА

## 1.1. Стиль: 70% Notion + 30% Apple

### **Notion (B-часть)**

* Пространство, дыхание, нейтральная цветовая палитра.
* Монохромные поверхности без лишних градиентов.
* Чёткая модульность интерфейса, предсказуемость поведения.
* Осознанность: интерфейс не отвлекает от содержания.

### **Apple (A-часть)**

* Мягкие тени и глубины → создают премиальное ощущение.
* Мягкие micro-gradients (едва видимые), создающие тактильность.
* Плавные переходы и физичная анимация.
* Акцентные элементы (кнопки, выделения) — аккуратные, но выразительные.

### Мета-принцип:

> **«Интерфейс — это спокойная комната для ваших мыслей.»**

---

# 2. СТРУКТУРА ПРОСТРАНСТВА И СЕТКА

## 2.1. Основная сетка

* Колонки: **4 колонки** мобильная сетка (iOS/Android).
* Гаттер: **16 pt**.
* Внутренний контейнер: **16 pt слева и справа**.
* Межсекции на экранах: **24–32 pt**.

## 2.2. Вертикальные ритмы

* Основной ритм: **8 pt** (кратно).
* Основное расстояние между карточками: **12–16 pt**.
* Между элементами в карточках: **6–8 pt**.

## 2.3. Радиусы

* Карточки: **12 pt**
* Интерактивные элементы (кнопки): **10 pt**
* Поля ввода: **12 pt**
* Чипы: **8 pt**

## 2.4. Тени (Apple-style)

Используем две тени:

* Shadow 1 (lift): `rgba(0,0,0,0.08)` / offset 0, 2 / blur 6
* Shadow 2 (depth): `rgba(0,0,0,0.04)` / offset 0, 4 / blur 12

Тени **не должны быть жёсткими**, всегда мягкие, размытые.

---

# 3. ТИПОГРАФИКА

## 3.1. Основной шрифт

**SF Pro Text / SF Pro Display** (iOS)
**Roboto / Inter** (Android)
Идеальная межплатформенная альтернатива: **Inter**.

## 3.2. Стиль текста

| Название | Размер | Толщина  | Использование          |
| -------- | ------ | -------- | ---------------------- |
| H1       | 28 pt  | SemiBold | Заголовки экранов      |
| H2       | 22 pt  | SemiBold | Разделы                |
| H3       | 18 pt  | Medium   | Подзаголовки           |
| Body 1   | 16 pt  | Regular  | Основной текст         |
| Body 2   | 14 pt  | Regular  | Подписи                |
| Caption  | 12 pt  | Regular  | Метки, системный текст |
| Button   | 16 pt  | Medium   | Текст на кнопках       |

Высота строки: +2–4 pt сверху.

---

# 4. ЦВЕТОВАЯ ПАЛИТРА (LIGHT & DARK)

## 4.1. Базовые цвета (Light Theme)

* **Фон**: `#FFFFFF`
* **Фон вторичный**: `#F7F7F8` (почти Notion)
* **Текст первичный**: `#111111`
* **Текст вторичный**: `#6A6A6A`
* **Границы**: `#E5E5E5`

## 4.2. Акценты

* **Primary (акцент)**: `#4A68F1` (спокойный синий, Apple-style)
* **Success**: `#4BB543`
* **Warning**: `#F3A93C`
* **Danger**: `#DD3E4D`

## 4.3. Цвета задач и сфер

* Работа — `#4A68F1`
* Личное — `#7A57D1`
* Здоровье — `#2CB67D`
* Финансы — `#F4CE5C`
* Учёба — `#FF9B6E`

## 4.4. Тёмная тема (Dark Theme)

* **Фон**: `#0D0E10`
* **Карточки**: `#17181B`
* **Границы**: `#2A2B2E`
* **Текст первичный**: `#FFFFFF`
* **Текст вторичный**: `#C5C5C5`
* Акцент остаётся, но затемняется на ~15%.

Правило:

> Не инвертировать цвета напрямую. Каждый цвет адаптируется вручную под dark environment.

---

# 5. UI-КОМПОНЕНТЫ

---

# 5.1. Кнопки

## Primary Button

* Высота: **48 pt**
* Радиус: **10 pt**
* Цвет: primary `#4A68F1`
* Текст: белый
* Тень: Shadow 1

## Secondary Button

* Высота: **48 pt**
* Обводка: `1 pt #D0D0D0`
* Текст: primary
* Без тени

## Tertiary Button (text)

* Цвет текста: primary
* Без фона

---

# 5.2. Поля ввода (Input Fields)

* Высота: **48 pt**
* Радиус: **12 pt**
* Фон: `#F7F7F8`
* Бордер: `#E5E4E7`
* Плейсхолдер: `#A2A2A2`
* Отступы:

  * горизонтальные: **14 pt**
  * вертикальные: **12 pt**

---

# 5.3. Чипы (фильтры, контексты)

* Высота: **28 pt**
* Радиус: **8 pt**
* Padding: 8pt / 12pt
* Варианты:

  * Default: серый фон
  * Selected: primary soft background + текст primary

---

# 5.4. Карточки (Tasks / Events / Finance)

### Карточка задачи:

* Радиус: **12 pt**
* Тени: Shadow 1 + Shadow 2 (очень слабые)
* Структура:

  * Заголовок (16 pt)
  * Иконка контекста слева
  * Приоритет (P0/P1/P2 — маленький цветовой индикатор 6 pt)
  * Дедлайн (Body 2)
  * Иконка привязки к цели (если есть)
  * Чипы контекстов

### Карточка события (календарь):

* Цветная полоска слева (3 pt, цвет сферы)
* Радиус внутри календарного блока: 8 pt
* Текст: Body 2
* Высота зависит от длительности

### Карточка финансов:

* Иконка категории
* Сумма (вес → medium)
* Цвет суммы:

  * Расход — красный
  * Доход — зелёный

---

# 5.5. Bottom Navigation (Mobile)

* 4–5 иконок
* Активная вкладка → primary-иконка + подпись
* Неактивная → `#8A8A8A`

Вкладки:

1. Календарь
2. Задачи
3. Финансы
4. Inbox
5. Профиль (опционально)

---

# 5.6. AppBar

* Высота: **56 pt**
* Текст: H2
* Иконки справа:

  * поиск
  * фильтр
  * быстрый доступ (опционально)

---

# 5.7. Модальные окна и Bottom Sheets

* Высота: 50–90% экрана
* Радиус верхних углов: 24 pt
* Чёткая «ручка» сверху (3x40 pt)

---

# 6. СПЕЦИФИКАЦИЯ ЭКРАНОВ

---

# 6.1. Календарь — День

Основной экран приложения.

### Структура:

* AppBar: дата / кнопка переключения режима / «Сегодня»
* Вертикальный таймлайн (00:00–24:00)
* Рабочие часы подчёркнуты серым фоном
* Смены (например, ночная) → заштрихованная зона
* События:

  * цветная метка слева
  * скруглённая карточка
* Задачи в календаре:

  * Отображаются аналогично событиям, но с другим стилем:

    * серый фон
    * иконка задачи

---

# 6.2. Неделя

* 7 колонок
* В центре подсвечен текущий день
* События растягиваются по таймлайну
* Упрощённые карточки задач

---

# 6.3. Список задач

Элемент: карточка задачи.

Фильтры сверху в виде чипов:

* Приоритет
* Контекст
* Цели/Проекты

Поиск: иконка в AppBar.

---

# 6.4. Цель → экран цели

Секции:

* Заголовок цели
* Прогресс-бар (%)
* Дедлайн
* Задачи цели (списком)
* Кнопка: «Добавить задачу»

---

# 6.5. Финансы

TabView:

1. Операции
2. Категории
3. Баланс месяца

Операции формируются карточками.

---

# 6.6. Inbox

* Пустое состояние: текстовые подсказки (минимализм, без иллюстраций)
* Элементы: простые строки со стрелкой
* Экран обработки:

  * Большой заголовок элемента
  * Кнопки действий: «Создать задачу», «Создать цель», «Создать финансовое событие»

---

# 6.7. AI-планировщик

Один из главных премиальных экранов.

### Вариант UX:

1. Выбор периода (3 чипа: Сегодня / Завтра / Неделя)
2. Список доступных задач:

   * приоритет
   * длительность
   * дедлайн
3. Кнопка: «Сгенерировать план»
4. Экран предложений:

   * бок о бок календарь + список изменений, подсвеченных цветом
   * элементы с пометкой:

     * «добавлено»
     * «перемещено»
     * «не удалось расписать»
5. Управление:

   * Принять всё
   * Принять частично
   * Отклонить

---

# 7. АДАПТАЦИЯ ПОД ТЁМНУЮ ТЕМУ

Правила:

* Уменьшить контраст, но не жертвовать читаемостью.
* Цветовые полосы событий остаются яркими.
* Карточки имеют фон `#17181B` и лёгкую внутреннюю тень.
* Граница карточек — `#2A2B2E`.
* Primary-синий затемняется на 15% → `#3D59D8`.

---

# 8. UI-СПЕЦИФИКАЦИИ (ФИНАЛЬНЫЕ ЧЕК-ЛИСТЫ)

---

## 8.1. Карточки задач — спецификация

* Высота: auto
* Padding: 12 pt
* Заголовок: 16 pt Medium
* Контексты: чипы 12–14 pt
* Цветовые индикаторы:

  * P0 → красный кружок 6 pt
  * P1 → жёлтый
  * P2 → серый

---

## 8.2. Календарный слот

* Минимальная высота: **30 мин = 50–60 pt**
* Фон рабочей зоны: `#FAFAFB`
* Нерабочее время: чисто белый фон
* Разделители: 1 pt `#E5E5E5`
* Событие:

  * min height: 40 pt
  * radius: 8 pt
  * left bar: 3 pt цвет сферы

---

## 8.3. Финансовая операция

* Сумма — 18 pt Medium
* Иконка категории — 24 pt
* Цвет суммы:

  * Расход → `#DD3E4D`
  * Доход → `#4BB543`

---

## 8.4. AI-планировщик

* Цвет предложенных изменений:

  * добавлено → зелёный контур
  * перемещено → синий контур
  * не удалось → оранжевый текст
* Анимация «переезда» задачи — 150–250 ms

---

# 9. ОБЩИЕ ПРАВИЛА ФОРМАЛИЗАЦИИ

* Все размеры кратны **4 pt**.
* Переходы между экранами — **240 ms**, cubic easing.
* Отсутствие «визуального шума» — минимум линий, максимум пространства.
* Акцентрирование на данных (время, задачи, деньги).
* Иллюстрации используются только в onboarding (минималистические).

========================================
FILE: ./Docs/Техническое задание.md
========================================

# 🧾 Техническое задание (ТЗ)

**Приложение LifeMerge (рабочее название)**
Кросс-платформенное мобильное приложение (Flutter) для Android и iOS

---

## 1. Общая информация

### 1.1. Назначение системы

LifeMerge — кросс-платформенное мобильное приложение для **управления временем, целями и финансами** с элементами GTD и AI-помощником. Цель — дать пользователю из СНГ единую систему планирования жизни: календарь, задачи, цели, финансовые потоки и аналитику.

### 1.2. Платформы

* **Мобильные приложения:**

  * Android (Google Play / RuStore — публикация отдельно, но архитектура должна быть совместима).
  * iOS (App Store).
* **Web / iPad / Desktop** — **вне MVP**, но учитываются в архитектуре (дальше: в Technical Specifications).

### 1.3. Целевая аудитория

* Возраст: **25–40 лет**.
* Регион: **страны СНГ**.
* Профиль: специалисты, менеджеры, ИТ, медики, фрилансеры, предприниматели, работники сменных графиков.
* Потребность: управлять многими сферами жизни в одной системе, видеть связку «время–цели–деньги».

---

## 2. Границы и состав MVP

### 2.1. Входит в MVP

1. **Регистрация / авторизация**

   * Регистрация по email + пароль.
   * Вход по email + пароль.
   * Восстановление пароля по email.
   * Привязка устройства к аккаунту (до N устройств, N задаётся бизнесом).

2. **Онбординг**

   * Краткое объяснение ценности продукта (3–5 экранов).
   * Запрос минимальных данных:

     * Часовой пояс.
     * Базовый рабочий график (5/2, 2/2, 3/3, пользовательский).
     * Основные сферы интересов (работа, здоровье, финансы, семья …).
   * Предложение активировать **Pro Trial** (с объяснением условий).

3. **Главная структура приложения**

   * Нижняя/боковая навигация:

     * **Календарь**.
     * **Задачи / Цели**.
     * **Финансы**.
     * **Inbox (GTD)**.
     * **Профиль / Настройки**.

4. **Календарь и расписание**

   * Режимы:

     * День / Неделя (MVP).
     * Месяц — упрощённый обзор (без детальных операций).
   * Поддержка рабочих графиков:

     * Стандартный 5/2.
     * Сменные: 2/2, 3/3.
     * Ночные смены.
     * Пользовательский цикл (простая конфигурация).
   * Учёт времени на дорогу (как отдельный тип блока или атрибут события).
   * Возможность:

     * Создавать события и задачи с привязкой ко времени.
     * Редактировать и перемещать (drag & drop).
     * Создавать повторяющиеся события/задачи.
     * Отображать параллельные активности (несколько событий в одно время).

5. **Задачи и цели**

   * Иерархия:

     * Цель → Проект (опционально) → Задачи.
   * Типы задач:

     * Разовые.
     * Регулярные.
     * Дробимые (можно разнести по нескольким дням/слотам).
   * Атрибуты задачи:

     * Название.
     * Описание (опционально).
     * Связь с целью / проектом.
     * Приоритет (P0, P1, P2).
     * Контекст (например, Дом, Офис, Дорога, @Компьютер, @Телефон).
     * Оценка длительности.
     * Тип энергии: лёгкая / средняя / тяжёлая (минимально для Pro и AI).
     * Дедлайн (дата).
   * Операции:

     * Создание / редактирование / удаление.
     * Привязка к календарю (конкретный слот).
     * Перенос между днями.
     * Завершение / отмена.
   * Цели:

     * Название.
     * Описание.
     * Категория (сфера жизни).
     * Горизонт (краткосрочная / среднесрочная / долгосрочная).
     * Дедлайн (опционально).
     * Прогресс (на основе завершённых задач).

6. **Финансовый модуль (MVP)**

   * Валюта профиля (основная).
   * Типы записей:

     * Доход.
     * Расход.
   * Категории (предзаданный набор для СНГ + пользовательские).
   * Регулярные операции (зарплата, аренда, подписки и т.д.).
   * Финансовые события, связанные с календарём:

     * Привязка записи к конкретному дню/событию.
   * Непривязанные записи (просто расходы/доходы).
   * Просмотр:

     * Список операций за период (день/неделя/месяц).
     * Итоги по месяцам: доход / расход / баланс.
   * Прогноз бюджета (базовый):

     * На основе регулярных операций и текущего месяца.

7. **GTD: Inbox**

   * Единый список «Входящих».
   * Элементы:

     * Тип: идея / задача / потенциальная цель / финансовое событие (задаётся вручную).
     * Название + заметка.
   * Сценарий обработки:

     * Пользователь открывает элемент и может:

       * Превратить его в задачу.

       * Привязать к цели или создать новую цель.

       * Превратить в финансовое событие.

       * Отметить как «не актуально» / удалить.

   > AI-подсказки при обработке — **не входят в MVP**, но архитектура должна допускать их добавление.

8. **AI в Pro-тарифе (MVP)**
   **Ключевая функция MVP: Умный планировщик задач**

   * Входные данные:

     * Список задач (с приоритетами, контекстами, оценкой длительности, дедлайнами).
     * Текущее расписание (в т.ч. рабочий график, забитые слоты, дорога).
     * Пользовательские правила (см. ниже).
   * Результат:

     * Предложенный план распределения задач по слотам календаря на выбранный период (например, день/неделя).
   * Базовые пользовательские правила для MVP:

     * Часы работы/отдыха.
     * Неприкосновенные дни (например, воскресенье).
     * Запрет тяжёлых задач вечером.
     * Минимальный буфер между задачами.
   * Требования к UX:

     * Пользователь видит «предложенный план», может:

       * Принять все.
       * Принять частично (по отдельным задачам).
       * Отменить или перераспределить вручную.
     * AI не изменяет расписание без явного подтверждения пользователя.

   **Дополнительные AI-функции (после MVP, но учесть в архитектуре):**

   * Советы по продуктивности.
   * Финансовые рекомендации.
   * Генерация структуры целей.

9. **Подписки, биллинг и Trial**

   * Тарифы:

     * Free.
     * Pro (месяц / год).
   * Trial:

     * Полный доступ к Pro-функциям **на 7–14 дней** (точное число — конфиг на сервере).
     * Условие активации: привязка банковской карты через App Store / Google Play Billing.
     * Авто-продление после окончания Trial, если не отключено.
   * Ограничения Free (примерно, для MVP):

     * Нет AI-планировщика.
     * Ограниченное количество:

       * целей,
       * активных проектов,
       * правил планирования,
       * финансовых счетов (в будущем).
     * Базовая аналитика без детальных графиков.
   * Требование: Подписка **сквозная для всех платформ** (Android/iOS/Web в будущем).
     Управление правами на уровне backend-флага `is_pro`.

10. **Уведомления (Push)**
    Обязательные для MVP:

* Напоминания о начале событий/задач:

  * По умолчанию за 15 минут.
  * Возможность настройки (0 / 5 / 15 / 30 мин, 1 час).
* Напоминания о дедлайнах:

  * За день.
  * За неделю (для важных целей/задач).
* Финансовые события:

  * Плановые расходы/доходы (например, «Завтра зарплата», «Через 2 часа плановый платёж»).
* Канал уведомлений (категории) — минимальный набор, но с разделением:

  * Планирование (задачи/события).
  * Финансы.
    В MVP **нет**:
* Поведенческой аналитики в пушах.
* AI-рекомендаций в пушах.

11. **Настройки и профиль**

* Профиль пользователя:

  * Имя / аватар (опционально).
  * Основная временная зона.
  * Основная валюта.
* Настройки:

  * Рабочий график.
  * Формат даты/времени (24/12, формат даты дд.мм.гг).
  * Первый день недели (по умолчанию — понедельник).
  * Настройки уведомлений (вкл/выкл по категориям).
  * Язык интерфейса:

    * В MVP: только **Русский**, но с инфраструктурой i18n.
* Управление подпиской:

  * Просмотр статуса Pro/Free.
  * Дата следующего списания.
  * Ссылка на управление подпиской в App Store / Google Play.

---

## 3. Пользовательские роли и доступы

1. **Гость (неавторизованный)**

   * Может просмотреть onboarding.
   * Может создать аккаунт / войти.
   * Не имеет доступа к основному функционалу (календарь и т.п.).

2. **Пользователь Free**

   * Доступ к:

     * календарю,
     * задачам и целям,
     * базовому финансовому учёту,
     * Inbox и GTD-процессу (без AI),
     * базовым отчётам.
   * Ограничения по объёму данных и функциям (конкретные лимиты — бизнес-решение, описывается дополнительно).

3. **Пользователь Pro**

   * Всё из Free плюс:

     * AI-планировщик задач.
     * Расширенная аналитика времени/финансов.
     * Расширенные шаблоны, правила планирования.
     * Приоритетная поддержка (маркер для backend/CRM).

4. **Администратор / Support (backend/Admin панель)**

   * В ТЗ фиксируется только необходимость:

     * просматривать пользователей, их тариф и активность,
     * управлять флагом Pro в исключительных случаях.
   * Детали Админ-панели — в отдельном документе.

---

## 4. Основные пользовательские сценарии (High-level)

1. **Новый пользователь**

   * Устанавливает приложение → проходит onboarding → создаёт аккаунт → настраивает рабочий график и базовые параметры → получает предложение включить Pro Trial → попадает на экран Календаря.

2. **Планирование недели (Free)**

   * Пользователь создаёт цели и задачи → распределяет задачи по календарю → вносит регулярные события (работа, спорт, семья) → видит общий план.

3. **Использование AI-планировщика (Pro)**

   * Пользователь создаёт задачи (с дедлайнами и приоритетами) → открывает режим «Умный планировщик» → выбирает период (например, «Следующая неделя») → получает предложенный план → принимает/корректирует → сохраняет расписание.

4. **Управление финансами**

   * Вносит регулярный доход (зарплата) и обязательные расходы → привязывает часть расходов к событиям (например, встреча в кафе) → в конце недели/месяца смотрит баланс и прогноз.

5. **Работа с Inbox (GTD)**

   * Фиксирует идеи, задачи, мысли в Inbox → раз в день/неделю открывает и обрабатывает → превращает элементы в задачи/цели/финансовые события.

---

## 5. Функциональные требования (детализация модулей)

### 5.1. Регистрация и авторизация

* Формы:

  * Регистрация: email, пароль, подтверждение пароля.
  * Логин: email + пароль.
* Требования к паролю:

  * Минимальная длина (например, 8 символов).
* Подтверждение email:

  * Может быть реализовано позже (опционально для MVP; фиксируем в архитектуре).
* Восстановление пароля:

  * Ввод email → отправка ссылки на восстановление.
* Сессии:

  * Хранение токена доступа на устройстве.
  * Автоматический логин до истечения срока токена.

### 5.2. Календарь

* Форматы отображения:

  * День, неделя — с таймлайном (часовые слоты).
  * Месяц — обзор (без плотной интерактивности).
* Операции:

  * Создание / редактирование / удаление событий.
  * Привязка событий к типам (работа, личное, финансы, здоровье и т.д.).
  * Привязка задачи (из списка задач) к конкретному времени.
* Логика рабочих графиков:

  * Настройка шаблонов (5/2, 2/2, 3/3 и т.д.).
  * Для сменных графиков:

    * задаётся последовательность смен (например, День → Ночь → Отдых).
* Визуальные требования:

  * Ночные смены визуально отличимы (темный фон/тон).
  * Время дороги может отображаться как отдельный блок между событиями.

### 5.3. Модуль задач/целей

* Список задач:

  * Фильтры:

    * по приоритету,
    * по контексту,
    * по проекту/цели,
    * по статусу.
* Карточка задачи:

  * Отображает все атрибуты.
  * Действия: завершить, перенести, привязать к календарю.
* Цели:

  * Создание/редактирование.
  * Просмотр прогресса:

    * % завершённых задач, связанных с целью.
* Возможно создание задач прямо из календаря (с автопривязкой к времени).

### 5.4. Финансы

* Ввод операций:

  * Сумма, дата, категория, описание (опционально), тип (доход/расход).
  * Признак регулярности: период (месяц/неделя/год, и т.д.).
* Просмотр:

  * Список операций с фильтрами (по категории, типу, периоду).
  * Сводка:

    * Суммарный доход/расход/баланс за период.
* Прогноз бюджета:

  * На основе регулярных операций и уже внесённых данных до конца месяца.
* Курсы валют:

  * В MVP можно использовать статическую основную валюту.
  * Поддержка нескольких валют и инфляции — закладывается в будущие версии (указать как «future feature» в технических спецификациях).

### 5.5. Inbox (GTD)

* Базовый список с быстрым добавлением элементов.
* Экран обработки:

  * Просмотр по одному элементу.
  * Кнопки действий:

    * создать задачу,
    * создать цель,
    * создать финансовое событие,
    * удалить / пометить «не актуально».

### 5.6. AI-планировщик (Pro)

* Отдельный экран/режим:

  * Выбор периода (от 1 дня до 1 недели).
  * Список задач, доступных для планирования (фильтрация по статусу и дедлайну).
* Отображение результата:

  * Предпросмотр предложенного плана:

    * выделены добавленные/перемещённые слоты.
* Валидация:

  * Не нарушать явные пользовательские правила (режимы работы/отдыха).
  * Не ставить задачу в слоты, занятые обязательными событиями (работа, сон и т.д.).

### 5.7. Уведомления

* Реализация пушей через:

  * Firebase Cloud Messaging (Android).
  * APNs (iOS).
* Местная логика:

  * Возможность использовать локальные уведомления (например, если событие создано на ближайшее время).
* Управление правами:

  * Системный запрос разрешения на уведомления.
  * Экран настроек, где пользователь может отключить определённые категории.

### 5.8. Аналитика (пользовательская, в интерфейсе)

MVP-уровень:

* Время:

  * Сколько часов занято задачами/событиями за период.
  * Разбивка по сферам (работа, здоровье, финансы и т.д.).
* Финансы:

  * Круговая диаграмма / список категорий расходов.
  * Итоговый баланс.
* Pro:

  * Более детальные графики (почасовая продуктивность, глубина категорий и т.п.) — можно отложить на релиз Pro 1.1, но предусмотреть зоны для их отображения.

---

## 6. Нефункциональные требования

### 6.1. UX/UI

* Стиль:

  * 70% Notion (минимализм, модульность, много воздуха).
  * 30% Apple (гладкость, микроградиенты, мягкие тени).
* Тёмная тема:

  * Должна быть реализована **в MVP**.
  * Цвета — продуманы, не тупое инвертирование.
* Минимум иллюстраций, максимум данных и графиков.

### 6.2. Производительность

* Приложение должно комфортно работать на:

  * Android: от Android 8.0 (API 26).
  * iOS: от iOS 14.
* Время первого запуска (cold start): до 3 секунд на средних устройствах.
* Открытие календаря / задач — не более 1 секунды при типичной нагрузке (десятки/сотни задач).

### 6.3. Offline / синхронизация

* MVP-поведение:

  * При отсутствии сети:

    * действия сохраняются в локальном кэше;
    * отображается ненавязчивый баннер/тост «Синхронизация отложена».
  * При восстановлении сети:

    * очередь операций отправляется на сервер.
* Конфликты:

  * Полноценное разрешение конфликтов между устройствами **вне MVP**.
  * Для MVP допустима стратегия «последний апдейт побеждает» (в бэкенде), с минимальными проверками.

### 6.4. Безопасность и конфиденциальность

* Передача данных:

  * Только по HTTPS.
* Хранение:

  * Минимизация чувствительных данных на устройстве (без хранения пароля, только токены).
  * Локальный кэш зашифрован штатными механизмами платформы (по возможности, минимум — недоступен для других приложений).
* Политика конфиденциальности:

  * Чёткое разделение:

    * какие данные хранятся,
    * как используются для аналитики и AI.

### 6.5. Локализация (i18n)

* Весь UI-текст вынесен в локализуемые ресурсы (intl/ARB).
* В MVP включён только русский язык (`ru-RU`).
* Техническая возможность добавить другие языки без изменения логики.

### 6.6. Логирование и аналитика (внутренняя)

* События для продуктовой аналитики (отправка на backend/аналитическую систему):

  * Регистрация, активация Trial, покупка Pro.
  * Создание/редактирование/удаление задач/целей/финансовых записей.
  * Использование AI-планировщика (запуск/принятие/отмена плана).
  * Открытие ключевых экранов (календарь, финансы, аналитика).
* Логи ошибок:

  * Отправка на сервис crash-репортинга (например, Sentry/Firebase Crashlytics — конкретика в Technical Specifications).

---

## 7. Требования к архитектуре (верхнеуровневые, без деталей реализации)

> Подробно стек, паттерны, схемы данных и API будут в документе **Technical Specifications**, но в ТЗ фиксируем ключевые принципы.

* Клиент:

  * Flutter, архитектура с разделением слоёв:

    * слой представления (UI),
    * слой состояния (state management),
    * слой данных (репозитории).
  * Поддержка локального кэша (sqflite/hive).
  * Поддержка очереди запросов для отложенной синхронизации.
* Сервер:

  * REST/GraphQL API (будет уточнено в Technical Specifications).
  * Централизованная модель подписок и прав (флаг `is_pro`, дата окончания trial и подписки).
* Расширяемость:

  * Возможность подключить Web-клиент без изменений в логике backend API.
  * Возможность добавлять новые типы событий (например, здоровье, привычки) без ломки модели.

---

## 8. Требования к качеству, тестированию и релизу

### 8.1. Качество

* Приложение не должно содержать критических багов:

  * краши при базовых сценариях (логин, просмотр календаря, создание задач и т.д.) — недопустимы.
* Отсутствие потери данных при типовых сценариях.

### 8.2. Тестирование

Для MVP:

* Unit-тесты для ключевой бизнес-логики (планирование, создание задач, финансовые операции).
* Интеграционные тесты для:

  * синхронизации,
  * AI-планировщика (на уровне корректности запросов/ответов).
* UI-тесты для критичных флоу:

  * онбординг → регистрация,
  * создание задачи/цели → планирование в календаре,
  * создание финансового события,
  * запуск AI-планировщика.

### 8.3. Релиз

* Подготовка билдов для:

  * Google Play (internal / closed testing).
  * App Store (TestFlight).
* Минимальный комплект:

  * иконка приложения,
  * скриншоты (календарь, задачи, финансы, AI-планировщик),
  * краткое и полное описание на русском.

========================================
FILE: ./Flutter/analysis_options.yaml
========================================

include: package:flutter_lints/flutter.yaml

analyzer:
  exclude:
    - "**/*.g.dart"
    - "**/*.freezed.dart"

linter:
  rules:
    prefer_single_quotes: true
    always_declare_return_types: true
    avoid_print: true


========================================
FILE: ./Flutter/docs/ARCHITECTURE.md
========================================

# Flutter Architecture Skeleton

- `lib/core` contains shared infrastructure (DI, routing, theme).
- `lib/features/<feature>/{presentation,application,domain,data}` is the default feature layout.
- Feature modules must not import each other directly. Shared code goes to `core/`.

Routing:
- `go_router` with a shell route for main navigation.

State management:
- `flutter_riverpod`.

Theme:
- `AppTheme` uses UI Kit tokens.


========================================
FILE: ./Flutter/docs/Sprint01_Skeleton.md
========================================

# LifeMerge Flutter Skeleton

This PR adds the initial Flutter codebase skeleton for Sprint 01 (foundation + A1).

## Included
- Clean-ish module layout: `core/` and `features/<feature>/{presentation,application,domain,data}`
- Riverpod DI container bootstrap
- go_router `AppRouter` with shell navigation
- `AppTheme` based on UI Kit v1.0 tokens (Colors.md, Typography.md)

## Next
- Generate full Flutter platform scaffolds (android/ios/etc.) in a dedicated PR
- Replace placeholder screens with feature implementations


========================================
FILE: ./Flutter/.gitignore
========================================

# Misc
.DS_Store
.idea/
.vscode/
*.iml

# Dart/Flutter
.dart_tool/
.packages
.pub/
build/

# Platform folders will be added when we generate a full Flutter project scaffold.
android/
ios/
macos/
windows/
linux/
web/

# Generated
**/*.g.dart
**/*.freezed.dart
lifemerge-flutter.txt
combine_md.sh

========================================
FILE: ./Flutter/lib/app/app.dart
========================================

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

import '../core/routing/app_router.dart';
import '../core/theme/app_theme.dart';
import '../core/l10n/app_localizations.dart';

class LifeMergeApp extends ConsumerWidget {
  const LifeMergeApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final router = ref.watch(appRouterProvider);

    return MaterialApp.router(
      debugShowCheckedModeBanner: false,
      routerConfig: router,
      theme: AppTheme.light,
      darkTheme: AppTheme.dark,
      themeMode: ThemeMode.system,
      localizationsDelegates: const <LocalizationsDelegate<dynamic>>[
        AppLocalizations.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: AppLocalizations.supportedLocales,
    );
  }
}


========================================
FILE: ./Flutter/lib/app/bootstrap.dart
========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../core/di/providers.dart';
import '../features/auth/application/auth_controller.dart';
import '../features/auth/data/session_storage.dart';

/// App bootstrap point.
///
/// Keep synchronous work minimal; do not perform feature initialization here.
Future<ProviderContainer> bootstrap() async {
  final prefs = await SharedPreferences.getInstance();
  final overrides = <Override>[
    ...appOverrides,
    sessionStorageProvider.overrideWithValue(SessionStorage(prefs)),
  ];

  final container = ProviderContainer(overrides: overrides);

  await container.read(authControllerProvider.notifier).restoreSession();

  // Placeholders for future: hydration, remote config, crash reporting initialization.
  return container;
}


========================================
FILE: ./Flutter/lib/core/analytics/analytics_service.dart
========================================

import 'dart:developer';

import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Lightweight analytics service that wraps future integrations
/// (e.g., Firebase Analytics). For now it simply logs events.
class AnalyticsService {
  const AnalyticsService();

  Future<void> logEvent(String name, {Map<String, dynamic>? parameters}) async {
    log('Analytics event: $name ${parameters ?? {}}');
  }
}

/// Global provider for the analytics service.
final analyticsProvider = Provider<AnalyticsService>((ref) {
  return const AnalyticsService();
});


========================================
FILE: ./Flutter/lib/core/di/providers.dart
========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Place to override providers for different flavors (dev/stage/prod).
/// Keep empty for now.
final List<Override> appOverrides = <Override>[];


========================================
FILE: ./Flutter/lib/core/l10n/app_localizations.dart
========================================

import 'package:flutter/material.dart';

/// Minimal localization layer for the auth flow.
class AppLocalizations {
  AppLocalizations(this.locale);

  final Locale locale;

  static const LocalizationsDelegate<AppLocalizations> delegate =
      _AppLocalizationsDelegate();

  static const List<Locale> supportedLocales = <Locale>[
    Locale('en'),
    Locale('ru'),
  ];

  static AppLocalizations of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations)!;
  }

  String get languageCode => locale.languageCode;

  bool get isRu => languageCode == 'ru';

  String get appName => isRu ? 'LifeMerge' : 'LifeMerge';
  String get loginTitle => isRu ? 'Вход' : 'Sign in';
  String get loginSubtitle =>
      isRu ? 'Продолжайте с того места, где остановились' : 'Pick up where you left off';
  String get emailLabel => isRu ? 'Электронная почта' : 'Email';
  String get passwordLabel => isRu ? 'Пароль' : 'Password';
  String get continueButton => isRu ? 'Продолжить' : 'Continue';
  String get noAccountYet =>
      isRu ? 'Нет аккаунта?' : "Don't have an account yet?";
  String get createAccount => isRu ? 'Создать' : 'Create one';
  String get haveAccount => isRu ? 'Уже с нами?' : 'Already with us?';
  String get signIn => isRu ? 'Войти' : 'Sign in';
  String get nameLabel => isRu ? 'Имя' : 'Name';
  String get confirmPasswordLabel => isRu ? 'Повторите пароль' : 'Confirm password';
  String get registerTitle => isRu ? 'Регистрация' : 'Sign up';
  String get registerSubtitle =>
      isRu ? 'Создайте аккаунт, чтобы начать' : 'Create an account to start';
  String get passwordsDoNotMatch =>
      isRu ? 'Пароли не совпадают' : 'Passwords do not match';
  String get fieldRequired => isRu ? 'Обязательное поле' : 'Required field';
  String get invalidEmail => isRu ? 'Неверный email' : 'Invalid email';
  String get passwordTooShort =>
      isRu ? 'Минимум 8 символов' : 'Minimum 8 characters';
  String get forgotPassword => isRu ? 'Забыли пароль?' : 'Forgot password?';
  String get resetPassword => isRu ? 'Восстановить доступ' : 'Reset access';
  String get resetPasswordSent =>
      isRu ? 'Письмо для восстановления отправлено' : 'Recovery email sent';
  String get incorrectCredentials =>
      isRu ? 'Неправильный логин или пароль' : 'Incorrect email or password';
  String get accountExists =>
      isRu ? 'Аккаунт с этим email уже существует' : 'Account already exists for this email';
  String get userNotFound =>
      isRu ? 'Пользователь не найден' : 'User not found';
  String get errorTitle => isRu ? 'Ошибка' : 'Error';
  String get genericError =>
      isRu ? 'Что-то пошло не так. Попробуйте позже.' : 'Something went wrong. Try again later.';
  String get continueToApp =>
      isRu ? 'Перейти к приложению' : 'Go to the app';
  String get loading => isRu ? 'Загрузка…' : 'Loading…';
  String get signUpSuccess =>
      isRu ? 'Аккаунт создан! Проверьте почту.' : 'Account created! Check your inbox.';
  String get logout => isRu ? 'Выйти' : 'Log out';
  String get logoutDescription =>
      isRu ? 'Очистить сессию и вернуться на экран входа' : 'Clear your session and return to sign in';
}

class _AppLocalizationsDelegate
    extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) =>
      AppLocalizations.supportedLocales.any(
        (supported) => supported.languageCode == locale.languageCode,
      );

  @override
  Future<AppLocalizations> load(Locale locale) async {
    return AppLocalizations(locale);
  }

  @override
  bool shouldReload(covariant LocalizationsDelegate<AppLocalizations> old) =>
      false;
}


========================================
FILE: ./Flutter/lib/core/routing/app_router.dart
========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../features/shell/presentation/app_shell.dart';
import '../../features/auth/presentation/login_screen.dart';
import '../../features/auth/presentation/register_screen.dart';
import '../../features/auth/application/auth_controller.dart';
import '../../features/onboarding/presentation/onboarding_screen.dart';
import '../../features/calendar/presentation/calendar_day_screen.dart';
import '../../features/tasks/presentation/tasks_screen.dart';
import '../../features/inbox/presentation/inbox_screen.dart';
import '../../features/settings/presentation/settings_screen.dart';
import '../../features/pro/presentation/pro_screen.dart';
import 'routes.dart';

final appRouterProvider = Provider<GoRouter>((ref) {
  final authNotifier = ref.read(authControllerProvider.notifier);
  final authState = ref.watch(authControllerProvider);

  return GoRouter(
    initialLocation: Routes.login,
    refreshListenable: GoRouterRefreshStream(authNotifier.stream),
    redirect: (context, state) {
      final isAuthRoute =
          state.matchedLocation == Routes.login || state.matchedLocation == Routes.register;
      final isAuthenticated = authState.isAuthenticated;

      if (!isAuthenticated && !isAuthRoute) {
        return Routes.login;
      }

      if (isAuthenticated && isAuthRoute) {
        return Routes.tasks;
      }

      return null;
    },
    routes: <RouteBase>[
      GoRoute(
        path: Routes.login,
        builder: (context, state) => const LoginScreen(),
      ),
      GoRoute(
        path: Routes.register,
        builder: (context, state) => const RegisterScreen(),
      ),
      GoRoute(
        path: Routes.onboarding,
        builder: (context, state) => const OnboardingScreen(),
      ),
      ShellRoute(
        builder: (context, state, child) => AppShell(child: child),
        routes: <RouteBase>[
          GoRoute(
            path: Routes.calendarDay,
            builder: (context, state) => const CalendarDayScreen(),
          ),
          GoRoute(
            path: Routes.tasks,
            builder: (context, state) => const TasksScreen(),
          ),
          GoRoute(
            path: Routes.inbox,
            builder: (context, state) => const InboxScreen(),
          ),
          GoRoute(
            path: Routes.settings,
            builder: (context, state) => const SettingsScreen(),
          ),
          GoRoute(
            path: Routes.pro,
            builder: (context, state) => const ProScreen(),
          ),
        ],
      ),
    ],
  );
});


========================================
FILE: ./Flutter/lib/core/routing/routes.dart
========================================

abstract final class Routes {
  static const String login = '/auth/login';
  static const String register = '/auth/register';
  static const String onboarding = '/onboarding';

  static const String calendarDay = '/calendar/day';
  static const String tasks = '/tasks';
  static const String inbox = '/inbox';
  static const String settings = '/settings';
  static const String pro = '/pro';
}


========================================
FILE: ./Flutter/lib/core/theme/app_colors.dart
========================================

import 'package:flutter/material.dart';

/// UI Kit v1.0 color tokens.
/// Source of truth: Colors.md
///
/// Do not use raw Color(...) values in UI.
abstract final class AppColors {
  static const Color primary = Color(0xFF5B8DEF);
  static const Color primaryDark = Color(0xFF3562C2);

  static const Color background = Color(0xFF0F1115);
  static const Color surface = Color(0xFF181C22);

  static const Color textPrimary = Color(0xFFFFFFFF);
  static const Color textSecondary = Color(0xFFB8C2D1);

  static const Color error = Color(0xFFFF3B30);
  static const Color success = Color(0xFF34C759);
  static const Color accent = Color(0xFFFF9F1C);
}


========================================
FILE: ./Flutter/lib/core/theme/app_theme.dart
========================================

import 'package:flutter/material.dart';

import 'app_colors.dart';
import 'app_typography.dart';

abstract final class AppTheme {
  static ThemeData get light {
    final colorScheme = ColorScheme.light(
      primary: AppColors.primary,
      onPrimary: Colors.white,
      surface: Colors.white,
      onSurface: const Color(0xFF0F1115),
      error: AppColors.error,
      onError: Colors.white,
    );

    return ThemeData(
      useMaterial3: true,
      fontFamily: AppTypography.fontFamily,
      colorScheme: colorScheme,
      scaffoldBackgroundColor: Colors.white,
      textTheme: _textTheme(isDark: false),
    );
  }

  static ThemeData get dark {
    final colorScheme = ColorScheme.dark(
      primary: AppColors.primary,
      onPrimary: Colors.white,
      surface: AppColors.surface,
      onSurface: AppColors.textPrimary,
      error: AppColors.error,
      onError: Colors.white,
    );

    return ThemeData(
      useMaterial3: true,
      fontFamily: AppTypography.fontFamily,
      colorScheme: colorScheme,
      scaffoldBackgroundColor: AppColors.background,
      textTheme: _textTheme(isDark: true),
    );
  }

  static TextTheme _textTheme({required bool isDark}) {
    final primary = isDark ? AppColors.textPrimary : const Color(0xFF0F1115);
    final secondary = isDark ? AppColors.textSecondary : const Color(0xFF3C4657);

    return TextTheme(
      headlineLarge: AppTypography.h1.copyWith(color: primary),
      headlineMedium: AppTypography.h2.copyWith(color: primary),
      titleLarge: AppTypography.h3.copyWith(color: primary),
      bodyLarge: AppTypography.body.copyWith(color: primary),
      bodyMedium: AppTypography.bodyMedium.copyWith(color: primary),
      bodySmall: AppTypography.caption.copyWith(color: secondary),
    );
  }
}


========================================
FILE: ./Flutter/lib/core/theme/app_typography.dart
========================================

import 'package:flutter/material.dart';

/// Typography scale from UI Kit v1.0 (Typography.md)
abstract final class AppTypography {
  static const String fontFamily = 'Inter';

  static const TextStyle h1 = TextStyle(
    fontFamily: fontFamily,
    fontSize: 26,
    fontWeight: FontWeight.w700,
    height: 1.2,
    letterSpacing: -0.2,
  );

  static const TextStyle h2 = TextStyle(
    fontFamily: fontFamily,
    fontSize: 22,
    fontWeight: FontWeight.w700,
    height: 1.2,
    letterSpacing: -0.2,
  );

  static const TextStyle h3 = TextStyle(
    fontFamily: fontFamily,
    fontSize: 18,
    fontWeight: FontWeight.w600,
    height: 1.25,
  );

  static const TextStyle body = TextStyle(
    fontFamily: fontFamily,
    fontSize: 15,
    fontWeight: FontWeight.w400,
    height: 1.35,
  );

  static const TextStyle bodyMedium = TextStyle(
    fontFamily: fontFamily,
    fontSize: 15,
    fontWeight: FontWeight.w500,
    height: 1.35,
  );

  static const TextStyle caption = TextStyle(
    fontFamily: fontFamily,
    fontSize: 13,
    fontWeight: FontWeight.w400,
    height: 1.3,
  );
}


========================================
FILE: ./Flutter/lib/features/auth/application/auth_controller.dart
========================================

import 'dart:async';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/analytics/analytics_service.dart';
import '../data/auth_api_service.dart';
import '../data/auth_repository.dart';
import '../domain/auth_error_code.dart';
import 'auth_state.dart';

class AuthController extends StateNotifier<AuthState> {
  AuthController(this._analytics, this._repository) : super(const AuthState());

  final AnalyticsService _analytics;
  final AuthRepository _repository;

  Future<bool> signIn({required String email, required String password}) async {
    state = state.copyWith(isLoading: true, clearError: true);
    try {
      final session = await _repository.login(email: email, password: password);
      state = state.copyWith(
        isLoading: false,
        errorMessage: null,
        isAuthenticated: true,
        email: session.email,
        token: session.token,
        errorCode: null,
      );
      return true;
    } on AuthApiException catch (error) {
      state = state.copyWith(
        isLoading: false,
        isAuthenticated: false,
        errorMessage: error.toString(),
        errorCode: error.code,
      );
      return false;
    } catch (error) {
      state = state.copyWith(
        isLoading: false,
        isAuthenticated: false,
        errorMessage: error.toString(),
        errorCode: AuthErrorCode.unknown,
      );
      return false;
    }
  }

  Future<bool> signUp({required String email, required String password}) async {
    state = state.copyWith(isLoading: true, clearError: true);
    try {
      final session = await _repository.signUp(email: email, password: password);
      await _analytics.logEvent('User_SignUp', parameters: <String, dynamic>{'email': email});
      state = state.copyWith(
        isLoading: false,
        errorMessage: null,
        isAuthenticated: true,
        email: session.email,
        token: session.token,
        errorCode: null,
      );
      return true;
    } on AuthApiException catch (error) {
      state = state.copyWith(
        isLoading: false,
        isAuthenticated: false,
        errorMessage: error.toString(),
        errorCode: error.code,
      );
      return false;
    } catch (error) {
      state = state.copyWith(
        isLoading: false,
        isAuthenticated: false,
        errorMessage: error.toString(),
        errorCode: AuthErrorCode.unknown,
      );
      return false;
    }
  }

  Future<bool> requestPasswordReset(String email) async {
    state = state.copyWith(isLoading: true, clearError: true);
    try {
      await _repository.requestPasswordReset(email);
      state = state.copyWith(isLoading: false, clearError: true);
      return true;
    } on AuthApiException catch (error) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: error.toString(),
        errorCode: error.code,
      );
      return false;
    } catch (error) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: error.toString(),
        errorCode: AuthErrorCode.unknown,
      );
      return false;
    }
  }

  Future<void> signOut() async {
    final token = state.token;
    state = state.copyWith(isLoading: true, clearError: true);
    if (token != null) {
      await _repository.logout(token);
    }
    state = const AuthState();
  }

  Future<void> restoreSession() async {
    final session = await _repository.restore();
    if (session != null) {
      state = state.copyWith(
        isAuthenticated: true,
        email: session.email,
        token: session.token,
        clearError: true,
      );
    }
  }

  void clearError() {
    if (state.errorMessage != null) {
      state = state.copyWith(clearError: true);
    }
  }
}

final authControllerProvider = StateNotifierProvider<AuthController, AuthState>((ref) {
  final analytics = ref.read(analyticsProvider);
  final repository = ref.read(authRepositoryProvider);
  return AuthController(analytics, repository);
});


========================================
FILE: ./Flutter/lib/features/auth/application/auth_state.dart
========================================

import '../domain/auth_error_code.dart';

class AuthState {
  const AuthState({
    this.isLoading = false,
    this.isAuthenticated = false,
    this.email,
    this.token,
    this.errorMessage,
    this.errorCode,
  });

  final bool isLoading;
  final bool isAuthenticated;
  final String? email;
  final String? token;
  final String? errorMessage;
  final AuthErrorCode? errorCode;

  AuthState copyWith({
    bool? isLoading,
    bool? isAuthenticated,
    String? email,
    String? token,
    String? errorMessage,
    AuthErrorCode? errorCode,
    bool clearError = false,
  }) {
    return AuthState(
      isLoading: isLoading ?? this.isLoading,
      isAuthenticated: isAuthenticated ?? this.isAuthenticated,
      email: email ?? this.email,
      token: token ?? this.token,
      errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
      errorCode: clearError ? null : (errorCode ?? this.errorCode),
    );
  }
}


========================================
FILE: ./Flutter/lib/features/auth/data/auth_api_service.dart
========================================

import 'dart:async';

class AuthApiService {
  final Map<String, String> _users = <String, String>{
    'demo@lifemerge.app': 'demo1234',
  };

  Future<String> signUp({required String email, required String password}) async {
    await Future<void>.delayed(const Duration(milliseconds: 650));
    if (_users.containsKey(email)) {
      throw AuthApiException(
        AuthErrorCode.accountExists,
        'Account already exists for this email',
      );
    }
    _users[email] = password;
    return _issueToken(email);
  }

  Future<String> login({required String email, required String password}) async {
    await Future<void>.delayed(const Duration(milliseconds: 450));
    final stored = _users[email];
    if (stored == null || stored != password) {
      throw AuthApiException(
        AuthErrorCode.incorrectCredentials,
        'Incorrect email or password',
      );
    }
    return _issueToken(email);
  }

  Future<void> requestPasswordReset(String email) async {
    await Future<void>.delayed(const Duration(milliseconds: 500));
    if (!_users.containsKey(email)) {
      throw AuthApiException(
        AuthErrorCode.userNotFound,
        'No account found for $email',
      );
    }
  }

  Future<void> logout(String token) async {
    await Future<void>.delayed(const Duration(milliseconds: 200));
  }

  String _issueToken(String email) => 'token-${email.hashCode}-${DateTime.now().millisecondsSinceEpoch}';
}

class AuthApiException implements Exception {
  AuthApiException(this.code, this.message);

  final AuthErrorCode code;
  final String message;

  @override
  String toString() => message;
}
import '../domain/auth_error_code.dart';


========================================
FILE: ./Flutter/lib/features/auth/data/auth_repository.dart
========================================

import 'dart:async';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'auth_api_service.dart';
import 'session_storage.dart';

class AuthRepository {
  AuthRepository(this._api, this._storage);

  final AuthApiService _api;
  final SessionStorage _storage;

  Future<AuthSession> signUp({required String email, required String password}) async {
    final token = await _api.signUp(email: email, password: password);
    final session = AuthSession(email: email, token: token);
    await _storage.saveSession(session);
    return session;
  }

  Future<AuthSession> login({required String email, required String password}) async {
    final token = await _api.login(email: email, password: password);
    final session = AuthSession(email: email, token: token);
    await _storage.saveSession(session);
    return session;
  }

  Future<void> requestPasswordReset(String email) => _api.requestPasswordReset(email);

  Future<void> logout(String token) async {
    await _api.logout(token);
    await _storage.clear();
  }

  Future<AuthSession?> restore() => _storage.readSession();
}

class AuthSession {
  const AuthSession({required this.email, required this.token});

  final String email;
  final String token;
}

final authApiServiceProvider = Provider<AuthApiService>((ref) {
  return AuthApiService();
});

final authRepositoryProvider = Provider<AuthRepository>((ref) {
  final api = ref.read(authApiServiceProvider);
  final storage = ref.read(sessionStorageProvider);
  return AuthRepository(api, storage);
});


========================================
FILE: ./Flutter/lib/features/auth/data/session_storage.dart
========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

import 'auth_repository.dart';

class SessionStorage {
  SessionStorage(this._prefs);

  final SharedPreferences _prefs;

  static const String _keyEmail = 'auth_email';
  static const String _keyToken = 'auth_token';

  Future<void> saveSession(AuthSession session) async {
    await _prefs.setString(_keyEmail, session.email);
    await _prefs.setString(_keyToken, session.token);
  }

  Future<AuthSession?> readSession() async {
    final email = _prefs.getString(_keyEmail);
    final token = _prefs.getString(_keyToken);
    if (email == null || token == null) {
      return null;
    }
    return AuthSession(email: email, token: token);
  }

  Future<void> clear() async {
    await _prefs.remove(_keyEmail);
    await _prefs.remove(_keyToken);
  }
}

final sessionStorageProvider = Provider<SessionStorage>((ref) {
  throw UnimplementedError('SessionStorage must be overridden during bootstrap');
});


========================================
FILE: ./Flutter/lib/features/auth/domain/auth_error_code.dart
========================================

enum AuthErrorCode { incorrectCredentials, accountExists, userNotFound, unknown }


========================================
FILE: ./Flutter/lib/features/auth/presentation/login_screen.dart
========================================

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/app_localizations.dart';
import '../../../core/routing/routes.dart';
import '../../../core/theme/app_colors.dart';
import '../../../core/theme/app_typography.dart';
import '../application/auth_controller.dart';
import '../application/auth_state.dart';
import '../domain/auth_error_code.dart';
import 'widgets/auth_text_field.dart';
import 'widgets/primary_button.dart';

class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  late final TextEditingController _emailController;
  late final TextEditingController _passwordController;
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();

  @override
  void initState() {
    super.initState();
    _emailController = TextEditingController();
    _passwordController = TextEditingController();
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  String? _validateEmail(String? value, AppLocalizations l10n) {
    if (value == null || value.isEmpty) {
      return l10n.fieldRequired;
    }
    final isValid = RegExp(r'^[^@]+@[^@]+\.[^@]+$').hasMatch(value.trim());
    if (!isValid) {
      return l10n.invalidEmail;
    }
    return null;
  }

  String _resolveError(AuthState state, AppLocalizations l10n) {
    switch (state.errorCode) {
      case AuthErrorCode.incorrectCredentials:
        return l10n.incorrectCredentials;
      case AuthErrorCode.accountExists:
        return l10n.accountExists;
      case AuthErrorCode.userNotFound:
        return l10n.userNotFound;
      case AuthErrorCode.unknown:
      case null:
        return state.errorMessage ?? l10n.genericError;
    }
  }

  String? _validatePassword(String? value, AppLocalizations l10n) {
    if (value == null || value.isEmpty) {
      return l10n.fieldRequired;
    }
    if (value.length < 8) {
      return l10n.passwordTooShort;
    }
    return null;
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context);
    final theme = Theme.of(context);
    final isLight = theme.brightness == Brightness.light;
    final AuthState state = ref.watch(authControllerProvider);
    final authController = ref.read(authControllerProvider.notifier);

    void clearError(String value) {
      if (state.errorMessage != null) {
        authController.clearError();
      }
    }

    Future<void> handlePasswordReset() async {
      final emailError = _validateEmail(_emailController.text.trim(), l10n);
      if (emailError != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(emailError)),
        );
        return;
      }

      final success = await authController.requestPasswordReset(_emailController.text.trim());
      if (!mounted) return;
      final updatedState = ref.read(authControllerProvider);
      final message = success ? l10n.resetPasswordSent : _resolveError(updatedState, l10n);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(message)),
      );
    }

    return Scaffold(
      body: SafeArea(
        child: Container(
          decoration: BoxDecoration(
            color: theme.scaffoldBackgroundColor,
            gradient: isLight
                ? const LinearGradient(
                    colors: <Color>[Color(0xFFF7F9FC), Color(0xFFE7ECF6)],
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                  )
                : null,
          ),
          child: Center(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
              child: ConstrainedBox(
                constraints: const BoxConstraints(maxWidth: 480),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: <Widget>[
                    Align(
                      alignment: Alignment.centerLeft,
                      child: Text(
                        l10n.appName,
                        style: AppTypography.h1.copyWith(color: AppColors.primary),
                      ),
                    ),
                    const SizedBox(height: 32),
                    Text(
                      l10n.loginTitle,
                      style: AppTypography.h2.copyWith(color: theme.colorScheme.onSurface),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      l10n.loginSubtitle,
                      style: AppTypography.body.copyWith(color: theme.colorScheme.onSurface.withOpacity(0.7)),
                    ),
                    const SizedBox(height: 32),
                    Form(
                      key: _formKey,
                      child: Column(
                        children: <Widget>[
                          AuthTextField(
                            label: l10n.emailLabel,
                            controller: _emailController,
                            keyboardType: TextInputType.emailAddress,
                            validator: (value) => _validateEmail(value, l10n),
                            onChanged: clearError,
                          ),
                          const SizedBox(height: 16),
                          AuthTextField(
                            label: l10n.passwordLabel,
                            controller: _passwordController,
                            obscureText: true,
                            validator: (value) => _validatePassword(value, l10n),
                            onChanged: clearError,
                          ),
                          const SizedBox(height: 12),
                          Align(
                            alignment: Alignment.centerRight,
                            child: TextButton(
                              onPressed: state.isLoading ? null : handlePasswordReset,
                              child: Text(l10n.forgotPassword),
                            ),
                          ),
                          const SizedBox(height: 12),
                          PrimaryButton(
                            label: l10n.continueButton,
                            isLoading: state.isLoading,
                            onPressed: () async {
                              if (!_formKey.currentState!.validate()) {
                                return;
                              }
                              final success = await authController.signIn(
                                email: _emailController.text.trim(),
                                password: _passwordController.text,
                              );
                              if (!mounted) return;
                              if (success) {
                                context.go(Routes.onboarding);
                              } else {
                                final updatedState =
                                    ref.read(authControllerProvider);
                                if (updatedState.errorMessage != null || updatedState.errorCode != null) {
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    SnackBar(
                                      content: Text(_resolveError(updatedState, l10n)),
                                    ),
                                  );
                                }
                              }
                            },
                          ),
                          if (state.errorMessage != null || state.errorCode != null) ...<Widget>[
                            const SizedBox(height: 12),
                            Container(
                              width: double.infinity,
                              padding: const EdgeInsets.all(12),
                              decoration: BoxDecoration(
                                color: theme.colorScheme.error.withOpacity(0.08),
                                borderRadius: BorderRadius.circular(12),
                              ),
                              child: Row(
                                children: <Widget>[
                                  Icon(Icons.error_outline, color: theme.colorScheme.error),
                                  const SizedBox(width: 8),
                                  Expanded(
                                    child: Text(
                                      _resolveError(state, l10n),
                                      style: AppTypography.body.copyWith(
                                        color: theme.colorScheme.error,
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ],
                      ),
                    ),
                    const SizedBox(height: 24),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: <Widget>[
                        Text(
                          l10n.noAccountYet,
                          style: AppTypography.body.copyWith(
                            color: theme.colorScheme.onSurface.withOpacity(0.8),
                          ),
                        ),
                        TextButton(
                          onPressed: state.isLoading ? null : () => context.go(Routes.register),
                          child: Text(l10n.createAccount),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}


========================================
FILE: ./Flutter/lib/features/auth/presentation/register_screen.dart
========================================

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/app_localizations.dart';
import '../../../core/routing/routes.dart';
import '../../../core/theme/app_colors.dart';
import '../../../core/theme/app_typography.dart';
import '../application/auth_controller.dart';
import '../application/auth_state.dart';
import '../domain/auth_error_code.dart';
import 'widgets/auth_text_field.dart';
import 'widgets/primary_button.dart';

class RegisterScreen extends ConsumerStatefulWidget {
  const RegisterScreen({super.key});

  @override
  ConsumerState<RegisterScreen> createState() => _RegisterScreenState();
}

class _RegisterScreenState extends ConsumerState<RegisterScreen> {
  late final TextEditingController _nameController;
  late final TextEditingController _emailController;
  late final TextEditingController _passwordController;
  late final TextEditingController _confirmController;
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();

  @override
  void initState() {
    super.initState();
    _nameController = TextEditingController();
    _emailController = TextEditingController();
    _passwordController = TextEditingController();
    _confirmController = TextEditingController();
  }

  @override
  void dispose() {
    _nameController.dispose();
    _emailController.dispose();
    _passwordController.dispose();
    _confirmController.dispose();
    super.dispose();
  }

  String? _validateEmail(String? value, AppLocalizations l10n) {
    if (value == null || value.isEmpty) {
      return l10n.fieldRequired;
    }
    final isValid = RegExp(r'^[^@]+@[^@]+\.[^@]+$').hasMatch(value.trim());
    if (!isValid) {
      return l10n.invalidEmail;
    }
    return null;
  }

  String? _validatePassword(String? value, AppLocalizations l10n) {
    if (value == null || value.isEmpty) {
      return l10n.fieldRequired;
    }
    if (value.length < 8) {
      return l10n.passwordTooShort;
    }
    return null;
  }

  String? _validateConfirm(String? value, AppLocalizations l10n) {
    if (value == null || value.isEmpty) {
      return l10n.fieldRequired;
    }
    if (value != _passwordController.text) {
      return l10n.passwordsDoNotMatch;
    }
    return null;
  }

  String _resolveError(AuthState state, AppLocalizations l10n) {
    switch (state.errorCode) {
      case AuthErrorCode.incorrectCredentials:
        return l10n.incorrectCredentials;
      case AuthErrorCode.accountExists:
        return l10n.accountExists;
      case AuthErrorCode.userNotFound:
        return l10n.userNotFound;
      case AuthErrorCode.unknown:
      case null:
        return state.errorMessage ?? l10n.genericError;
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context);
    final theme = Theme.of(context);
    final isLight = theme.brightness == Brightness.light;
    final AuthState state = ref.watch(authControllerProvider);
    final authController = ref.read(authControllerProvider.notifier);

    void clearError(String value) {
      if (state.errorMessage != null || state.errorCode != null) {
        authController.clearError();
      }
    }

    return Scaffold(
      body: SafeArea(
        child: Container(
          decoration: BoxDecoration(
            color: theme.scaffoldBackgroundColor,
            gradient: isLight
                ? const LinearGradient(
                    colors: <Color>[Color(0xFFF7F9FC), Color(0xFFE7ECF6)],
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                  )
                : null,
          ),
          child: Center(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
              child: ConstrainedBox(
                constraints: const BoxConstraints(maxWidth: 480),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: <Widget>[
                    Align(
                      alignment: Alignment.centerLeft,
                      child: Text(
                        l10n.appName,
                        style: AppTypography.h1.copyWith(color: AppColors.primary),
                      ),
                    ),
                    const SizedBox(height: 32),
                    Text(
                      l10n.registerTitle,
                      style: AppTypography.h2.copyWith(color: theme.colorScheme.onSurface),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      l10n.registerSubtitle,
                      style: AppTypography.body.copyWith(color: theme.colorScheme.onSurface.withOpacity(0.7)),
                    ),
                    const SizedBox(height: 32),
                    Form(
                      key: _formKey,
                      child: Column(
                        children: <Widget>[
                          AuthTextField(
                            label: l10n.nameLabel,
                            controller: _nameController,
                            onChanged: clearError,
                          ),
                          const SizedBox(height: 16),
                          AuthTextField(
                            label: l10n.emailLabel,
                            controller: _emailController,
                            keyboardType: TextInputType.emailAddress,
                            validator: (value) => _validateEmail(value, l10n),
                            onChanged: clearError,
                          ),
                          const SizedBox(height: 16),
                          AuthTextField(
                            label: l10n.passwordLabel,
                            controller: _passwordController,
                            obscureText: true,
                            validator: (value) => _validatePassword(value, l10n),
                            onChanged: clearError,
                          ),
                          const SizedBox(height: 16),
                          AuthTextField(
                            label: l10n.confirmPasswordLabel,
                            controller: _confirmController,
                            obscureText: true,
                            validator: (value) => _validateConfirm(value, l10n),
                            onChanged: clearError,
                          ),
                          const SizedBox(height: 16),
                          PrimaryButton(
                            label: l10n.continueButton,
                            isLoading: state.isLoading,
                            onPressed: () async {
                              if (!_formKey.currentState!.validate()) {
                                return;
                              }
                              final success = await authController.signUp(
                                email: _emailController.text.trim(),
                                password: _passwordController.text,
                              );
                              if (!mounted) return;
                              if (success) {
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(content: Text(l10n.signUpSuccess)),
                                );
                                context.go(Routes.onboarding);
                              } else {
                                final updatedState =
                                    ref.read(authControllerProvider);
                                if (updatedState.errorMessage != null || updatedState.errorCode != null) {
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    SnackBar(
                                      content: Text(_resolveError(updatedState, l10n)),
                                    ),
                                  );
                                }
                              }
                            },
                          ),
                          if (state.errorMessage != null || state.errorCode != null) ...<Widget>[
                            const SizedBox(height: 12),
                            Container(
                              width: double.infinity,
                              padding: const EdgeInsets.all(12),
                              decoration: BoxDecoration(
                                color: theme.colorScheme.error.withOpacity(0.08),
                                borderRadius: BorderRadius.circular(12),
                              ),
                              child: Row(
                                children: <Widget>[
                                  Icon(Icons.error_outline, color: theme.colorScheme.error),
                                  const SizedBox(width: 8),
                                  Expanded(
                                    child: Text(
                                      _resolveError(state, l10n),
                                      style: AppTypography.body.copyWith(
                                        color: theme.colorScheme.error,
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ],
                      ),
                    ),
                    const SizedBox(height: 24),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: <Widget>[
                        Text(
                          l10n.haveAccount,
                          style: AppTypography.body.copyWith(
                            color: theme.colorScheme.onSurface.withOpacity(0.8),
                          ),
                        ),
                        TextButton(
                          onPressed: state.isLoading ? null : () => context.go(Routes.login),
                          child: Text(l10n.signIn),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}


========================================
FILE: ./Flutter/lib/features/auth/presentation/widgets/auth_text_field.dart
========================================

import 'package:flutter/material.dart';

import '../../../../core/theme/app_colors.dart';
import '../../../../core/theme/app_typography.dart';

class AuthTextField extends StatelessWidget {
  const AuthTextField({
    super.key,
    required this.label,
    required this.controller,
    this.keyboardType,
    this.obscureText = false,
    this.validator,
    this.onChanged,
  });

  final String label;
  final TextEditingController controller;
  final TextInputType? keyboardType;
  final bool obscureText;
  final String? Function(String?)? validator;
  final ValueChanged<String>? onChanged;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final textColor = theme.colorScheme.onSurface;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: <Widget>[
        Text(
          label,
          style: AppTypography.bodyMedium.copyWith(color: textColor),
        ),
        const SizedBox(height: 8),
        TextFormField(
          controller: controller,
          keyboardType: keyboardType,
          obscureText: obscureText,
          onChanged: onChanged,
          validator: validator,
          style: AppTypography.body.copyWith(color: textColor),
          decoration: InputDecoration(
            filled: true,
            fillColor: theme.colorScheme.surface.withOpacity(0.6),
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14),
              borderSide: BorderSide(color: AppColors.primary.withOpacity(0.15)),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14),
              borderSide: const BorderSide(color: AppColors.primary, width: 1.4),
            ),
            errorBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14),
              borderSide: BorderSide(color: theme.colorScheme.error),
            ),
            focusedErrorBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14),
              borderSide: BorderSide(color: theme.colorScheme.error),
            ),
          ),
        ),
      ],
    );
  }
}


========================================
FILE: ./Flutter/lib/features/auth/presentation/widgets/primary_button.dart
========================================

import 'package:flutter/material.dart';

import '../../../../core/theme/app_colors.dart';
import '../../../../core/theme/app_typography.dart';

class PrimaryButton extends StatelessWidget {
  const PrimaryButton({
    super.key,
    required this.label,
    required this.onPressed,
    this.isLoading = false,
  });

  final String label;
  final VoidCallback? onPressed;
  final bool isLoading;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return SizedBox(
      width: double.infinity,
      child: FilledButton(
        style: FilledButton.styleFrom(
          backgroundColor: AppColors.primary,
          foregroundColor: Colors.white,
          padding: const EdgeInsets.symmetric(vertical: 16),
          textStyle: AppTypography.bodyMedium.copyWith(
            color: Colors.white,
            fontWeight: FontWeight.w600,
          ),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
        ),
        onPressed: isLoading ? null : onPressed,
        child: isLoading
            ? SizedBox(
                height: 22,
                width: 22,
                child: CircularProgressIndicator(
                  strokeWidth: 2.4,
                  valueColor: AlwaysStoppedAnimation<Color>(theme.colorScheme.onPrimary),
                ),
              )
            : Text(label),
      ),
    );
  }
}


========================================
FILE: ./Flutter/lib/features/calendar/application/calendar_controller.dart
========================================

import 'dart:async';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../data/calendar_repository.dart';
import '../domain/calendar_event.dart';
import 'calendar_state.dart';

class CalendarController extends StateNotifier<CalendarState> {
  CalendarController(this._repository) : super(const CalendarState()) {
    _loadEvents();
  }

  final CalendarRepository _repository;
  Timer? _retryTimer;

  Future<void> _loadEvents() async {
    state = state.copyWith(isLoading: true, clearError: true);
    await _flushQueue(force: true);
    try {
      final events = await _repository.fetchEvents();
      state = state.copyWith(events: events, isLoading: false, clearError: true);
    } catch (error) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: error.toString(),
      );
    }
  }

  Future<void> refresh() => _loadEvents();

  Future<void> syncPending() => _flushQueue(force: true);

  Future<void> addEvent(CalendarEventDraft draft) async {
    final now = DateTime.now();
    final pending = CalendarEvent(
      id: _generateRequestId(prefix: 'local'),
      title: draft.title,
      description: draft.description,
      startAt: draft.startAt,
      endAt: draft.endAt,
      taskId: draft.taskId,
      status: CalendarEventStatus.scheduled,
      createdAt: now,
      updatedAt: now,
    );

    if (state.isOffline) {
      _enqueueOperation(CalendarOperationType.create, pending);
      _applyLocalChange(pending);
      return;
    }

    await _executeCreate(pending);
  }

  Future<void> updateEvent(CalendarEvent event, CalendarEventDraft draft) async {
    final updated = event.copyWith(
      title: draft.title,
      description: draft.description,
      startAt: draft.startAt,
      endAt: draft.endAt,
      taskId: draft.taskId ?? event.taskId,
      updatedAt: DateTime.now(),
    );

    if (state.isOffline) {
      _enqueueOperation(CalendarOperationType.update, updated);
      _replaceEvent(event.id, updated);
      return;
    }

    await _executeUpdate(updated);
  }

  Future<void> deleteEvent(CalendarEvent event) async {
    final deleted = event.copyWith(deleted: true, updatedAt: DateTime.now());
    if (state.isOffline) {
      _enqueueOperation(CalendarOperationType.delete, deleted);
      _removeEvent(event.id);
      return;
    }

    await _executeDelete(deleted);
  }

  void toggleOfflineMode() {
    final wasOffline = state.isOffline;
    state = state.copyWith(isOffline: !state.isOffline);
    if (wasOffline && !state.isOffline) {
      unawaited(_flushQueue(force: true));
    }
  }

  void clearError() {
    if (state.errorMessage != null) {
      state = state.copyWith(clearError: true);
    }
  }

  void _applyLocalChange(CalendarEvent event) {
    state = state.copyWith(events: <CalendarEvent>[...state.events, event]);
  }

  void _replaceEvent(String originalId, CalendarEvent updated) {
    final events = state.events.map((event) => event.id == originalId ? updated : event).toList();
    state = state.copyWith(events: events);
  }

  void _removeEvent(String id) {
    state = state.copyWith(events: state.events.where((event) => event.id != id).toList());
  }

  void _enqueueOperation(CalendarOperationType type, CalendarEvent event) {
    final operation = PendingCalendarOperation(
      type: type,
      event: event,
      requestId: _generateRequestId(),
      enqueuedAt: DateTime.now(),
    );
    state = state.copyWith(
      pendingOperations: <PendingCalendarOperation>[...state.pendingOperations, operation],
    );
    _scheduleRetry();
  }

  Future<void> _flushQueue({bool force = false}) async {
    if (state.pendingOperations.isEmpty) {
      _cancelRetry();
      return;
    }

    if (state.isOffline && !force) {
      _scheduleRetry();
      return;
    }

    final List<PendingCalendarOperation> remaining = <PendingCalendarOperation>[];
    var hadError = false;

    for (final operation in state.pendingOperations) {
      try {
        switch (operation.type) {
          case CalendarOperationType.create:
            final created = await _repository.createEvent(operation.event);
            _replaceEvent(operation.event.id, created);
            break;
          case CalendarOperationType.update:
            final updated = await _repository.updateEvent(operation.event);
            _replaceEvent(operation.event.id, updated);
            break;
          case CalendarOperationType.delete:
            await _repository.deleteEvent(operation.event.id);
            _removeEvent(operation.event.id);
            break;
        }
      } catch (error) {
        hadError = true;
        remaining.add(operation);
      }
    }

    state = state.copyWith(
      pendingOperations: remaining,
      isOffline: hadError && remaining.isNotEmpty,
    );

    if (remaining.isEmpty) {
      _cancelRetry();
    } else {
      _scheduleRetry();
    }
  }

  Future<void> _executeCreate(CalendarEvent event) async {
    try {
      final created = await _repository.createEvent(event);
      _applyOrInsert(created);
    } catch (error) {
      _enqueueOperation(CalendarOperationType.create, event);
      state = state.copyWith(errorMessage: error.toString(), isOffline: true);
    }
  }

  Future<void> _executeUpdate(CalendarEvent event) async {
    try {
      final updated = await _repository.updateEvent(event);
      _replaceEvent(event.id, updated);
    } catch (error) {
      _enqueueOperation(CalendarOperationType.update, event);
      state = state.copyWith(errorMessage: error.toString(), isOffline: true);
    }
  }

  Future<void> _executeDelete(CalendarEvent event) async {
    try {
      await _repository.deleteEvent(event.id);
      _removeEvent(event.id);
    } catch (error) {
      _enqueueOperation(CalendarOperationType.delete, event);
      state = state.copyWith(errorMessage: error.toString(), isOffline: true);
    }
  }

  void _applyOrInsert(CalendarEvent event) {
    final events = [...state.events];
    final index = events.indexWhere((element) => element.id == event.id);
    if (index == -1) {
      events.add(event);
    } else {
      events[index] = event;
    }
    state = state.copyWith(events: events);
  }

  String _generateRequestId({String prefix = 'req'}) {
    final timestamp = DateTime.now().microsecondsSinceEpoch;
    return '$prefix-$timestamp';
  }

  void _scheduleRetry() {
    _retryTimer ??= Timer.periodic(const Duration(seconds: 4), (_) {
      unawaited(_flushQueue(force: true));
    });
  }

  void _cancelRetry() {
    _retryTimer?.cancel();
    _retryTimer = null;
  }
}

final calendarControllerProvider =
    StateNotifierProvider<CalendarController, CalendarState>((ref) {
  final repository = ref.read(calendarRepositoryProvider);
  return CalendarController(repository);
});


========================================
FILE: ./Flutter/lib/features/calendar/application/calendar_state.dart
========================================

import '../domain/calendar_event.dart';

enum CalendarOperationType { create, update, delete }

class PendingCalendarOperation {
  PendingCalendarOperation({
    required this.type,
    required this.event,
    required this.requestId,
    required this.enqueuedAt,
  });

  final CalendarOperationType type;
  final CalendarEvent event;
  final String requestId;
  final DateTime enqueuedAt;
}

class CalendarState {
  const CalendarState({
    this.events = const <CalendarEvent>[],
    this.pendingOperations = const <PendingCalendarOperation>[],
    this.isLoading = false,
    this.isOffline = false,
    this.errorMessage,
  });

  final List<CalendarEvent> events;
  final List<PendingCalendarOperation> pendingOperations;
  final bool isLoading;
  final bool isOffline;
  final String? errorMessage;

  CalendarState copyWith({
    List<CalendarEvent>? events,
    List<PendingCalendarOperation>? pendingOperations,
    bool? isLoading,
    bool? isOffline,
    String? errorMessage,
    bool clearError = false,
  }) {
    return CalendarState(
      events: events ?? this.events,
      pendingOperations: pendingOperations ?? this.pendingOperations,
      isLoading: isLoading ?? this.isLoading,
      isOffline: isOffline ?? this.isOffline,
      errorMessage: clearError ? null : errorMessage,
    );
  }
}


========================================
FILE: ./Flutter/lib/features/calendar/data/calendar_api_service.dart
========================================

import 'dart:async';

import '../domain/calendar_event.dart';

class CalendarApiService {
  CalendarApiService() {
    final now = DateTime.now();
    _remoteEvents.addAll(<CalendarEvent>[
      CalendarEvent(
        id: _generateId(),
        title: 'Product sync',
        startAt: DateTime(now.year, now.month, now.day, 10, 0),
        endAt: DateTime(now.year, now.month, now.day, 11, 0),
        description: 'Weekly priorities review',
        createdAt: now.subtract(const Duration(days: 1)),
        updatedAt: now.subtract(const Duration(days: 1)),
      ),
      CalendarEvent(
        id: _generateId(),
        title: 'Coffee with Alex',
        startAt: DateTime(now.year, now.month, now.day, 15, 0),
        endAt: DateTime(now.year, now.month, now.day, 15, 30),
        description: 'Catch up on side project',
        createdAt: now.subtract(const Duration(hours: 2)),
        updatedAt: now.subtract(const Duration(hours: 2)),
      ),
    ]);
  }

  final List<CalendarEvent> _remoteEvents = <CalendarEvent>[];

  Future<List<CalendarEvent>> fetchEvents() async {
    await Future<void>.delayed(const Duration(milliseconds: 500));
    return List<CalendarEvent>.unmodifiable(_remoteEvents.where((event) => !event.deleted));
  }

  Future<CalendarEvent> createEvent(CalendarEvent event) async {
    await Future<void>.delayed(const Duration(milliseconds: 400));
    final now = DateTime.now();
    final created = event.copyWith(
      id: event.id.isEmpty || event.id.startsWith('local') ? _generateId() : event.id,
      createdAt: event.createdAt == event.updatedAt ? now : event.createdAt,
      updatedAt: now,
      taskId: event.taskId,
      deleted: false,
    );
    _remoteEvents.removeWhere((existing) => existing.id == created.id);
    _remoteEvents.add(created);
    return created;
  }

  Future<CalendarEvent> updateEvent(CalendarEvent event) async {
    await Future<void>.delayed(const Duration(milliseconds: 400));
    final current = _remoteEvents.firstWhere((item) => item.id == event.id, orElse: () => event);
    final updated = current.copyWith(
      title: event.title,
      description: event.description,
      startAt: event.startAt,
      endAt: event.endAt,
      taskId: event.taskId,
      status: event.status,
      updatedAt: DateTime.now(),
    );
    _remoteEvents.removeWhere((existing) => existing.id == updated.id);
    _remoteEvents.add(updated);
    return updated;
  }

  Future<void> deleteEvent(String id) async {
    await Future<void>.delayed(const Duration(milliseconds: 300));
    final currentIndex = _remoteEvents.indexWhere((event) => event.id == id);
    if (currentIndex != -1) {
      final current = _remoteEvents[currentIndex];
      _remoteEvents[currentIndex] = current.copyWith(
        deleted: true,
        updatedAt: DateTime.now(),
      );
    }
  }

  String _generateId() => DateTime.now().microsecondsSinceEpoch.toString();
}


========================================
FILE: ./Flutter/lib/features/calendar/data/calendar_repository.dart
========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../domain/calendar_event.dart';
import 'calendar_api_service.dart';

class CalendarRepository {
  CalendarRepository(this._apiService);

  final CalendarApiService _apiService;

  Future<List<CalendarEvent>> fetchEvents() => _apiService.fetchEvents();

  Future<CalendarEvent> createEvent(CalendarEvent event) => _apiService.createEvent(event);

  Future<CalendarEvent> updateEvent(CalendarEvent event) => _apiService.updateEvent(event);

  Future<void> deleteEvent(String id) => _apiService.deleteEvent(id);
}

final calendarApiServiceProvider = Provider<CalendarApiService>((ref) {
  return CalendarApiService();
});

final calendarRepositoryProvider = Provider<CalendarRepository>((ref) {
  final api = ref.read(calendarApiServiceProvider);
  return CalendarRepository(api);
});


========================================
FILE: ./Flutter/lib/features/calendar/domain/calendar_event.dart
========================================

import 'package:flutter/foundation.dart';

enum CalendarEventStatus { scheduled, done, canceled }

@immutable
class CalendarEvent {
  const CalendarEvent({
    required this.id,
    required this.title,
    required this.startAt,
    this.endAt,
    this.description,
    this.taskId,
    this.status = CalendarEventStatus.scheduled,
    required this.createdAt,
    required this.updatedAt,
    this.deleted = false,
  });

  final String id;
  final String title;
  final DateTime startAt;
  final DateTime? endAt;
  final String? description;
  final String? taskId;
  final CalendarEventStatus status;
  final DateTime createdAt;
  final DateTime updatedAt;
  final bool deleted;

  CalendarEvent copyWith({
    String? id,
    String? title,
    DateTime? startAt,
    DateTime? endAt,
    String? description,
    String? taskId,
    CalendarEventStatus? status,
    DateTime? createdAt,
    DateTime? updatedAt,
    bool? deleted,
  }) {
    return CalendarEvent(
      id: id ?? this.id,
      title: title ?? this.title,
      startAt: startAt ?? this.startAt,
      endAt: endAt ?? this.endAt,
      description: description ?? this.description,
      taskId: taskId ?? this.taskId,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deleted: deleted ?? this.deleted,
    );
  }
}

class CalendarEventDraft {
  const CalendarEventDraft({
    required this.title,
    required this.startAt,
    this.endAt,
    this.description,
    this.taskId,
  });

  final String title;
  final DateTime startAt;
  final DateTime? endAt;
  final String? description;
  final String? taskId;
}


========================================
FILE: ./Flutter/lib/features/calendar/presentation/calendar_day_screen.dart
========================================

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../tasks/application/tasks_controller.dart';
import '../../tasks/domain/task.dart';
import '../application/calendar_controller.dart';
import '../domain/calendar_event.dart';
import 'widgets/event_form_sheet.dart';

class CalendarDayScreen extends ConsumerStatefulWidget {
  const CalendarDayScreen({super.key});

  @override
  ConsumerState<CalendarDayScreen> createState() => _CalendarDayScreenState();
}

class _CalendarDayScreenState extends ConsumerState<CalendarDayScreen> {
  DateTime _selectedDay = DateTime.now();
  final ScrollController _timelineController = ScrollController();

  @override
  void dispose() {
    _timelineController.dispose();
    super.dispose();
  }

  void _changeDay(int offset) {
    setState(() {
      _selectedDay = _selectedDay.add(Duration(days: offset));
    });
  }

  void _openForm(
    BuildContext context,
    WidgetRef ref, {
    CalendarEvent? event,
    DateTime? startAt,
    DateTime? endAt,
    String? taskId,
    String? taskTitle,
  }) {
    showModalBottomSheet<void>(
      context: context,
      isScrollControlled: true,
      builder: (_) => EventFormSheet(
        initialEvent: event,
        initialStartAt: startAt,
        initialEndAt: endAt,
        initialTaskId: taskId,
        initialTaskTitle: taskTitle,
        onSubmit: (draft) {
          final controller = ref.read(calendarControllerProvider.notifier);
          if (event == null) {
            controller.addEvent(draft);
          } else {
            controller.updateEvent(event, draft);
          }
        },
      ),
    );
  }

  void _scheduleTaskOnSlot(Task task, DateTime slotStart) {
    final durationMinutes = task.estimatedMinutes ?? 60;
    final end = slotStart.add(Duration(minutes: durationMinutes));
    final calendarController = ref.read(calendarControllerProvider.notifier);
    final tasksController = ref.read(tasksControllerProvider.notifier);

    final draft = CalendarEventDraft(
      title: task.title,
      description: task.description,
      startAt: slotStart,
      endAt: end,
      taskId: task.id,
    );

    calendarController.addEvent(draft);

    final updateDraft = TaskDraft(
      title: task.title,
      description: task.description,
      dueAt: slotStart,
      priority: task.priority,
      estimatedMinutes: task.estimatedMinutes,
      energyLevel: task.energyLevel,
      status: TaskStatus.inProgress,
    );

    unawaited(tasksController.updateTask(task, updateDraft));

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(
          'Scheduled "${task.title}" at ${TimeOfDay.fromDateTime(slotStart).format(context)}',
        ),
        behavior: SnackBarBehavior.floating,
      ),
    );
  }

  List<CalendarEvent> _eventsForDay(List<CalendarEvent> events) {
    return events
        .where((event) => _isSameDay(event.startAt, _selectedDay) && !event.deleted)
        .toList()
      ..sort((a, b) => a.startAt.compareTo(b.startAt));
  }

  bool _isSameDay(DateTime a, DateTime b) {
    return a.year == b.year && a.month == b.month && a.day == b.day;
  }

  DateTime _roundedStart(DateTime base) {
    final minute = base.minute;
    final remainder = minute % 30;
    final delta = remainder == 0 ? 0 : 30 - remainder;
    return DateTime(base.year, base.month, base.day, base.hour, minute + delta);
  }

  @override
  Widget build(BuildContext context) {
    final calendarState = ref.watch(calendarControllerProvider);
    final calendarController = ref.read(calendarControllerProvider.notifier);
    final tasksState = ref.watch(tasksControllerProvider);

    final events = _eventsForDay([...calendarState.events]);
    final tasks = tasksState.tasks
        .where((task) => !task.deleted && task.status != TaskStatus.done)
        .toList();
    final linkedEventsCount = events.where((event) => event.taskId != null).length;
    final tasksById = <String, Task>{for (final task in tasksState.tasks) task.id: task};

    final isWideLayout = MediaQuery.of(context).size.width >= 900;
    final today = DateTime.now();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Calendar'),
        actions: <Widget>[
          IconButton(
            tooltip: calendarState.isOffline ? 'Offline mode' : 'Go offline',
            icon: Stack(
              children: <Widget>[
                Icon(calendarState.isOffline ? Icons.cloud_off : Icons.cloud_queue),
                if (calendarState.pendingOperations.isNotEmpty)
                  Positioned(
                    right: 0,
                    top: 0,
                    child: CircleAvatar(
                      radius: 8,
                      backgroundColor: Theme.of(context).colorScheme.error,
                      child: Text(
                        calendarState.pendingOperations.length.toString(),
                        style: const TextStyle(fontSize: 10, color: Colors.white),
                      ),
                    ),
                  ),
              ],
            ),
            onPressed: calendarController.toggleOfflineMode,
          ),
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () {
              calendarController.refresh();
              ref.read(tasksControllerProvider.notifier).refresh();
            },
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        icon: const Icon(Icons.event),
        label: const Text('New event'),
        onPressed: () {
          final base = _isSameDay(today, _selectedDay)
              ? _roundedStart(DateTime.now())
              : DateTime(_selectedDay.year, _selectedDay.month, _selectedDay.day, 9);
          _openForm(context, ref, startAt: base, endAt: base.add(const Duration(hours: 1)));
        },
      ),
      body: Column(
        children: <Widget>[
          _DayHeader(
            selectedDay: _selectedDay,
            totalEvents: events.length,
            linkedEvents: linkedEventsCount,
            unscheduledTasks: tasks.length,
            onPrevious: () => _changeDay(-1),
            onNext: () => _changeDay(1),
          ),
          if (calendarState.errorMessage != null)
            MaterialBanner(
              content: Text(calendarState.errorMessage!),
              leading: const Icon(Icons.error_outline),
              actions: <Widget>[
                TextButton(
                  onPressed: calendarController.clearError,
                  child: const Text('Dismiss'),
                ),
              ],
            ),
          if (calendarState.pendingOperations.isNotEmpty)
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              child: Row(
                children: <Widget>[
                  const Icon(Icons.sync_problem_outlined),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'Queued: ${calendarState.pendingOperations.length} changes waiting for connection',
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ),
                  if (!calendarState.isOffline)
                    TextButton(
                      onPressed: calendarController.syncPending,
                      child: const Text('Sync now'),
                    ),
                ],
              ),
            ),
          Expanded(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              child: isWideLayout
                  ? Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        SizedBox(
                          width: 320,
                          child: _TaskBoard(
                            tasks: tasks,
                            isLoading: tasksState.isLoading,
                            onTaskTap: (task) => _openForm(
                              context,
                              ref,
                              startAt: _roundedStart(DateTime.now()),
                              endAt: _roundedStart(DateTime.now()).add(const Duration(hours: 1)),
                              taskId: task.id,
                              taskTitle: task.title,
                            ),
                          ),
                        ),
                        const SizedBox(width: 16),
                        Expanded(
                          child: _DayTimeline(
                            day: _selectedDay,
                            controller: _timelineController,
                            events: events,
                            tasksById: tasksById,
                            onSlotTap: (slot) => _openForm(
                              context,
                              ref,
                              startAt: slot,
                              endAt: slot.add(const Duration(minutes: 45)),
                            ),
                            onTaskDropped: _scheduleTaskOnSlot,
                            onEdit: (event) => _openForm(
                              context,
                              ref,
                              event: event,
                              taskId: event.taskId,
                              taskTitle: tasksById[event.taskId]?.title,
                            ),
                            onDelete: calendarController.deleteEvent,
                          ),
                        ),
                      ],
                    )
                  : Column(
                      children: [
                        _TaskBoard(
                          tasks: tasks,
                          isLoading: tasksState.isLoading,
                          onTaskTap: (task) => _openForm(
                            context,
                            ref,
                            startAt: _roundedStart(DateTime.now()),
                            endAt: _roundedStart(DateTime.now()).add(const Duration(hours: 1)),
                            taskId: task.id,
                            taskTitle: task.title,
                          ),
                        ),
                        const SizedBox(height: 12),
                        Expanded(
                          child: _DayTimeline(
                            day: _selectedDay,
                            controller: _timelineController,
                            events: events,
                            tasksById: tasksById,
                            onSlotTap: (slot) => _openForm(
                              context,
                              ref,
                              startAt: slot,
                              endAt: slot.add(const Duration(minutes: 45)),
                            ),
                            onTaskDropped: _scheduleTaskOnSlot,
                            onEdit: (event) => _openForm(
                              context,
                              ref,
                              event: event,
                              taskId: event.taskId,
                              taskTitle: tasksById[event.taskId]?.title,
                            ),
                            onDelete: calendarController.deleteEvent,
                          ),
                        ),
                      ],
                    ),
            ),
          ),
        ],
      ),
    );
  }
}

class _DayHeader extends StatelessWidget {
  const _DayHeader({
    required this.selectedDay,
    required this.totalEvents,
    required this.linkedEvents,
    required this.unscheduledTasks,
    required this.onPrevious,
    required this.onNext,
  });

  final DateTime selectedDay;
  final int totalEvents;
  final int linkedEvents;
  final int unscheduledTasks;
  final VoidCallback onPrevious;
  final VoidCallback onNext;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final weekday = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'][selectedDay.weekday - 1];
    final isToday = DateTime.now().year == selectedDay.year &&
        DateTime.now().month == selectedDay.month &&
        DateTime.now().day == selectedDay.day;
    final dateLabel = '${selectedDay.year}-${selectedDay.month.toString().padLeft(2, '0')}-${selectedDay.day.toString().padLeft(2, '0')}';

    return Container(
      width: double.infinity,
      margin: const EdgeInsets.all(12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            theme.colorScheme.primary.withOpacity(0.12),
            theme.colorScheme.secondary.withOpacity(0.1),
          ],
        ),
        borderRadius: BorderRadius.circular(18),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              IconButton(onPressed: onPrevious, icon: const Icon(Icons.chevron_left)),
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('$weekday ${isToday ? '(today)' : ''}', style: theme.textTheme.titleMedium),
                  const SizedBox(height: 4),
                  Text(dateLabel, style: theme.textTheme.headlineSmall),
                ],
              ),
              IconButton(onPressed: onNext, icon: const Icon(Icons.chevron_right)),
              const Spacer(),
              FilledButton.icon(
                onPressed: onNext,
                icon: const Icon(Icons.navigate_next),
                label: const Text('Jump to next'),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Wrap(
            spacing: 12,
            runSpacing: 8,
            children: [
              _StatChip(icon: Icons.event_available, label: 'Events', value: '$totalEvents'),
              _StatChip(icon: Icons.link, label: 'Linked tasks', value: '$linkedEvents'),
              _StatChip(icon: Icons.pending_actions, label: 'Inbox tasks', value: '$unscheduledTasks'),
            ],
          ),
        ],
      ),
    );
  }
}

class _StatChip extends StatelessWidget {
  const _StatChip({required this.icon, required this.label, required this.value});

  final IconData icon;
  final String label;
  final String value;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.dividerColor),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 18),
          const SizedBox(width: 8),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(label, style: theme.textTheme.labelSmall),
              Text(value, style: theme.textTheme.titleMedium),
            ],
          ),
        ],
      ),
    );
  }
}

class _TaskBoard extends StatelessWidget {
  const _TaskBoard({
    required this.tasks,
    required this.isLoading,
    required this.onTaskTap,
  });

  final List<Task> tasks;
  final bool isLoading;
  final ValueChanged<Task> onTaskTap;

  Color _priorityColor(TaskPriority priority, ThemeData theme) {
    switch (priority) {
      case TaskPriority.high:
        return theme.colorScheme.errorContainer;
      case TaskPriority.medium:
        return theme.colorScheme.tertiaryContainer;
      case TaskPriority.low:
        return theme.colorScheme.secondaryContainer;
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Card(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Icon(Icons.check_circle_outline),
                const SizedBox(width: 8),
                Text('Tasks to schedule', style: theme.textTheme.titleMedium),
                const Spacer(),
                if (isLoading) const SizedBox(height: 18, width: 18, child: CircularProgressIndicator(strokeWidth: 2)),
              ],
            ),
            const SizedBox(height: 12),
            if (tasks.isEmpty && !isLoading)
              Text(
                'Drag tasks into the timeline to book a slot.',
                style: theme.textTheme.bodyMedium,
              ),
            if (tasks.isNotEmpty)
              ...tasks.map(
                (task) => Padding(
                  padding: const EdgeInsets.only(bottom: 8),
                  child: Draggable<Task>(
                    data: task,
                    feedback: Material(
                      elevation: 6,
                      color: Colors.transparent,
                      child: _TaskCard(
                        task: task,
                        priorityColor: _priorityColor(task.priority, theme),
                        compact: true,
                      ),
                    ),
                    childWhenDragging: Opacity(
                      opacity: 0.5,
                      child: _TaskCard(
                        task: task,
                        priorityColor: _priorityColor(task.priority, theme),
                      ),
                    ),
                    child: GestureDetector(
                      onTap: () => onTaskTap(task),
                      child: _TaskCard(
                        task: task,
                        priorityColor: _priorityColor(task.priority, theme),
                      ),
                    ),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}

class _TaskCard extends StatelessWidget {
  const _TaskCard({
    required this.task,
    required this.priorityColor,
    this.compact = false,
  });

  final Task task;
  final Color priorityColor;
  final bool compact;

  String _statusLabel(TaskStatus status) {
    switch (status) {
      case TaskStatus.todo:
        return 'To do';
      case TaskStatus.inProgress:
        return 'In progress';
      case TaskStatus.done:
        return 'Done';
      case TaskStatus.deferred:
        return 'Deferred';
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceVariant,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: priorityColor.withOpacity(0.6)),
      ),
      width: compact ? 260 : double.infinity,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Container(
                width: 10,
                height: 10,
                decoration: BoxDecoration(color: priorityColor, shape: BoxShape.circle),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  task.title,
                  style: theme.textTheme.titleSmall,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              Text(_statusLabel(task.status), style: theme.textTheme.labelSmall),
            ],
          ),
          if (task.description != null && task.description!.isNotEmpty) ...[
            const SizedBox(height: 6),
            Text(task.description!, maxLines: 2, overflow: TextOverflow.ellipsis),
          ],
          if (task.estimatedMinutes != null)
            Padding(
              padding: const EdgeInsets.only(top: 6),
              child: Text('${task.estimatedMinutes} min', style: theme.textTheme.labelMedium),
            ),
        ],
      ),
    );
  }
}

class _DayTimeline extends StatelessWidget {
  const _DayTimeline({
    required this.day,
    required this.controller,
    required this.events,
    required this.tasksById,
    required this.onSlotTap,
    required this.onTaskDropped,
    required this.onEdit,
    required this.onDelete,
  });

  final DateTime day;
  final ScrollController controller;
  final List<CalendarEvent> events;
  final Map<String, Task> tasksById;
  final ValueChanged<DateTime> onSlotTap;
  final void Function(Task, DateTime) onTaskDropped;
  final ValueChanged<CalendarEvent> onEdit;
  final ValueChanged<CalendarEvent> onDelete;

  List<DateTime> _slots() {
    final start = DateTime(day.year, day.month, day.day);
    return List<DateTime>.generate(48, (index) => start.add(Duration(minutes: 30 * index)));
  }

  List<CalendarEvent> _eventsForSlot(DateTime slotStart) {
    final slotEnd = slotStart.add(const Duration(minutes: 30));
    return events.where((event) {
      final start = event.startAt;
      final end = event.endAt ?? event.startAt.add(const Duration(minutes: 45));
      return start.isBefore(slotEnd) && end.isAfter(slotStart);
    }).toList();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final slots = _slots();

    return Card(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: ListView.builder(
        controller: controller,
        itemCount: slots.length,
        itemBuilder: (context, index) {
          final slot = slots[index];
          final slotEvents = _eventsForSlot(slot);
          return DragTarget<Task>(
            onWillAccept: (_) => true,
            onAcceptWithDetails: (details) => onTaskDropped(details.data, slot),
            builder: (context, candidateData, rejectedData) {
              final isActive = candidateData.isNotEmpty;
              return InkWell(
                onTap: () => onSlotTap(slot),
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                  decoration: BoxDecoration(
                    color: isActive
                        ? theme.colorScheme.primaryContainer.withOpacity(0.35)
                        : theme.colorScheme.surface,
                    border: Border(
                      bottom: BorderSide(color: theme.dividerColor.withOpacity(0.4)),
                    ),
                  ),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      SizedBox(
                        width: 64,
                        child: Text(
                          TimeOfDay.fromDateTime(slot).format(context),
                          style: theme.textTheme.labelMedium,
                        ),
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            if (slotEvents.isEmpty && !isActive)
                              Text(
                                'Drop a task or tap to add',
                                style: theme.textTheme.bodySmall,
                              ),
                            if (isActive)
                              Padding(
                                padding: const EdgeInsets.only(bottom: 4),
                                child: Row(
                                  children: [
                                    const Icon(Icons.downloading, size: 16),
                                    const SizedBox(width: 6),
                                    Text('Release to schedule task', style: theme.textTheme.labelMedium),
                                  ],
                                ),
                              ),
                            ...slotEvents.map(
                              (event) => Padding(
                                padding: const EdgeInsets.only(bottom: 6),
                                child: _EventCard(
                                  event: event,
                                  linkedTask: event.taskId != null ? tasksById[event.taskId] : null,
                                  onEdit: () => onEdit(event),
                                  onDelete: () => onDelete(event),
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          );
        },
      ),
    );
  }
}

class _EventCard extends StatelessWidget {
  const _EventCard({
    required this.event,
    this.linkedTask,
    required this.onEdit,
    required this.onDelete,
  });

  final CalendarEvent event;
  final Task? linkedTask;
  final VoidCallback onEdit;
  final VoidCallback onDelete;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final rangeLabel = _rangeLabel(context);
    return Container(
      decoration: BoxDecoration(
        color: linkedTask != null
            ? theme.colorScheme.secondaryContainer
            : theme.colorScheme.surfaceVariant,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.dividerColor.withOpacity(0.4)),
      ),
      child: ListTile(
        dense: true,
        title: Text(event.title, style: theme.textTheme.titleSmall),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(rangeLabel),
            if (event.description != null && event.description!.isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(top: 4),
                child: Text(event.description!, maxLines: 2, overflow: TextOverflow.ellipsis),
              ),
            if (linkedTask != null)
              Padding(
                padding: const EdgeInsets.only(top: 4),
                child: Row(
                  children: [
                    const Icon(Icons.link, size: 16),
                    const SizedBox(width: 6),
                    Expanded(
                      child: Text(
                        'Task: ${linkedTask!.title}',
                        style: theme.textTheme.labelMedium,
                      ),
                    ),
                  ],
                ),
              ),
          ],
        ),
        trailing: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            IconButton(
              tooltip: 'Edit',
              icon: const Icon(Icons.edit_outlined),
              onPressed: onEdit,
            ),
            IconButton(
              tooltip: 'Delete',
              icon: const Icon(Icons.delete_outline),
              onPressed: onDelete,
            ),
          ],
        ),
      ),
    );
  }

  String _rangeLabel(BuildContext context) {
    final start = TimeOfDay.fromDateTime(event.startAt.toLocal()).format(context);
    final end = TimeOfDay.fromDateTime((event.endAt ?? event.startAt).toLocal()).format(context);
    return '$start - $end';
  }
}


========================================
FILE: ./Flutter/lib/features/calendar/presentation/widgets/event_form_sheet.dart
========================================

import 'package:flutter/material.dart';

import '../../domain/calendar_event.dart';

class EventFormSheet extends StatefulWidget {
  const EventFormSheet({
    super.key,
    this.initialEvent,
    this.initialStartAt,
    this.initialEndAt,
    this.initialTaskId,
    this.initialTaskTitle,
    required this.onSubmit,
  });

  final CalendarEvent? initialEvent;
  final DateTime? initialStartAt;
  final DateTime? initialEndAt;
  final String? initialTaskId;
  final String? initialTaskTitle;
  final void Function(CalendarEventDraft) onSubmit;

  @override
  State<EventFormSheet> createState() => _EventFormSheetState();
}

class _EventFormSheetState extends State<EventFormSheet> {
  late final TextEditingController _titleController;
  late final TextEditingController _descriptionController;
  late DateTime _startAt;
  DateTime? _endAt;
  String? _taskId;
  String? _taskTitle;
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();

  @override
  void initState() {
    super.initState();
    _titleController = TextEditingController(text: widget.initialEvent?.title ?? '');
    _descriptionController =
        TextEditingController(text: widget.initialEvent?.description ?? '');
    _startAt =
        widget.initialEvent?.startAt ?? widget.initialStartAt ?? DateTime.now();
    _endAt = widget.initialEvent?.endAt ?? widget.initialEndAt;
    _taskId = widget.initialEvent?.taskId ?? widget.initialTaskId;
    _taskTitle = widget.initialTaskTitle;
  }

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  Future<void> _pickStartDateTime() async {
    final pickedDate = await showDatePicker(
      context: context,
      initialDate: _startAt,
      firstDate: DateTime.now().subtract(const Duration(days: 365)),
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );
    if (pickedDate == null) return;

    final pickedTime = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(_startAt),
    );
    if (pickedTime == null) return;

    setState(() {
      _startAt = DateTime(
        pickedDate.year,
        pickedDate.month,
        pickedDate.day,
        pickedTime.hour,
        pickedTime.minute,
      );
    });
  }

  Future<void> _pickEndDateTime() async {
    final pickedDate = await showDatePicker(
      context: context,
      initialDate: _endAt ?? _startAt,
      firstDate: _startAt,
      lastDate: _startAt.add(const Duration(days: 2)),
    );
    if (pickedDate == null) return;

    final pickedTime = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(_endAt ?? _startAt.add(const Duration(hours: 1))),
    );
    if (pickedTime == null) return;

    setState(() {
      _endAt = DateTime(
        pickedDate.year,
        pickedDate.month,
        pickedDate.day,
        pickedTime.hour,
        pickedTime.minute,
      );
    });
  }

  void _submit() {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    final draft = CalendarEventDraft(
      title: _titleController.text.trim(),
      startAt: _startAt,
      endAt: _endAt,
      description: _descriptionController.text.trim().isEmpty
          ? null
          : _descriptionController.text.trim(),
      taskId: _taskId,
    );
    widget.onSubmit(draft);
    Navigator.of(context).pop();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: EdgeInsets.only(
        left: 16,
        right: 16,
        bottom: MediaQuery.of(context).viewInsets.bottom + 16,
        top: 16,
      ),
      child: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: <Widget>[
            Text(
              widget.initialEvent == null ? 'New event' : 'Edit event',
              style: theme.textTheme.titleLarge,
            ),
            const SizedBox(height: 12),
            if (_taskId != null)
              Container(
                width: double.infinity,
                margin: const EdgeInsets.only(bottom: 12),
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: theme.colorScheme.secondaryContainer,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: <Widget>[
                    const Icon(Icons.link, size: 20),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            'Linked task',
                            style: theme.textTheme.labelLarge,
                          ),
                          const SizedBox(height: 4),
                          Text(
                            _taskTitle ?? _taskId!,
                            style: theme.textTheme.bodyMedium,
                          ),
                        ],
                      ),
                    ),
                    IconButton(
                      onPressed: () => setState(() => _taskId = null),
                      tooltip: 'Remove link',
                      icon: const Icon(Icons.close),
                    ),
                  ],
                ),
              ),
            TextFormField(
              controller: _titleController,
              decoration: const InputDecoration(labelText: 'Title'),
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'Required';
                }
                return null;
              },
            ),
            const SizedBox(height: 12),
            TextFormField(
              controller: _descriptionController,
              decoration: const InputDecoration(labelText: 'Description (optional)'),
              minLines: 1,
              maxLines: 3,
            ),
            const SizedBox(height: 12),
            ListTile(
              leading: const Icon(Icons.schedule),
              title: const Text('Start'),
              subtitle: Text('${_startAt.toLocal()}'),
              onTap: _pickStartDateTime,
            ),
            ListTile(
              leading: const Icon(Icons.event_available),
              title: const Text('End (optional)'),
              subtitle: Text(_endAt != null ? '${_endAt!.toLocal()}' : 'Not set'),
              onTap: _pickEndDateTime,
            ),
            const SizedBox(height: 8),
            Align(
              alignment: Alignment.centerRight,
              child: FilledButton.icon(
                icon: const Icon(Icons.save_outlined),
                label: Text(widget.initialEvent == null ? 'Save event' : 'Update event'),
                onPressed: _submit,
              ),
            ),
          ],
        ),
      ),
    );
  }
}


========================================
FILE: ./Flutter/lib/features/inbox/presentation/inbox_screen.dart
========================================

import 'package:flutter/material.dart';

class InboxScreen extends StatelessWidget {
  const InboxScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return const Scaffold(
      body: Center(child: Text('Inbox (placeholder)')),
    );
  }
}


========================================
FILE: ./Flutter/lib/features/onboarding/presentation/onboarding_screen.dart
========================================

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../../../core/routing/routes.dart';

class OnboardingScreen extends StatelessWidget {
  const OnboardingScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Onboarding')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: <Widget>[
            const Text('Onboarding placeholder'),
            const SizedBox(height: 16),
            FilledButton(
              onPressed: () => context.go(Routes.calendarDay),
              child: const Text('Finish onboarding'),
            ),
          ],
        ),
      ),
    );
  }
}


========================================
FILE: ./Flutter/lib/features/pro/presentation/pro_screen.dart
========================================

import 'package:flutter/material.dart';

class ProScreen extends StatelessWidget {
  const ProScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return const Scaffold(
      body: Center(child: Text('Pro (placeholder)')),
    );
  }
}


========================================
FILE: ./Flutter/lib/features/settings/presentation/settings_screen.dart
========================================

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/app_localizations.dart';
import '../../../core/routing/routes.dart';
import '../../auth/application/auth_controller.dart';

class SettingsScreen extends ConsumerWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context);
    final authState = ref.watch(authControllerProvider);
    final authController = ref.read(authControllerProvider.notifier);

    return Scaffold(
      appBar: AppBar(title: Text(l10n.logout)),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: <Widget>[
            Card(
              child: ListTile(
                leading: const Icon(Icons.person_outline),
                title: Text(authState.email ?? 'Guest'),
                subtitle: Text(l10n.logoutDescription),
              ),
            ),
            const SizedBox(height: 24),
            ElevatedButton.icon(
              onPressed: authState.isLoading
                  ? null
                  : () async {
                      await authController.signOut();
                      if (!context.mounted) return;
                      context.go(Routes.login);
                    },
              icon: const Icon(Icons.logout),
              label: Text(l10n.logout),
            ),
          ],
        ),
      ),
    );
  }
}


========================================
FILE: ./Flutter/lib/features/shell/presentation/app_shell.dart
========================================

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../../../core/routing/routes.dart';

class AppShell extends StatelessWidget {
  const AppShell({required this.child, super.key});

  final Widget child;

  int _indexForLocation(String location) {
    if (location.startsWith(Routes.calendarDay)) return 0;
    if (location.startsWith(Routes.tasks)) return 1;
    if (location.startsWith(Routes.inbox)) return 2;
    if (location.startsWith(Routes.settings)) return 3;
    if (location.startsWith(Routes.pro)) return 4;
    return 0;
  }

  void _onTap(BuildContext context, int index) {
    switch (index) {
      case 0:
        context.go(Routes.calendarDay);
      case 1:
        context.go(Routes.tasks);
      case 2:
        context.go(Routes.inbox);
      case 3:
        context.go(Routes.settings);
      case 4:
        context.go(Routes.pro);
    }
  }

  @override
  Widget build(BuildContext context) {
    final location = GoRouterState.of(context).uri.toString();
    final currentIndex = _indexForLocation(location);

    return Scaffold(
      body: SafeArea(child: child),
      bottomNavigationBar: NavigationBar(
        selectedIndex: currentIndex,
        onDestinationSelected: (i) => _onTap(context, i),
        destinations: const <NavigationDestination>[
          NavigationDestination(icon: Icon(Icons.calendar_today), label: 'Calendar'),
          NavigationDestination(icon: Icon(Icons.check_circle_outline), label: 'Tasks'),
          NavigationDestination(icon: Icon(Icons.inbox_outlined), label: 'Inbox'),
          NavigationDestination(icon: Icon(Icons.settings_outlined), label: 'Settings'),
          NavigationDestination(icon: Icon(Icons.workspace_premium_outlined), label: 'Pro'),
        ],
      ),
    );
  }
}


========================================
FILE: ./Flutter/lib/features/tasks/application/tasks_controller.dart
========================================

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../data/tasks_repository.dart';
import '../domain/task.dart';
import 'tasks_state.dart';

class TasksController extends StateNotifier<TasksState> {
  TasksController(this._repository) : super(const TasksState()) {
    _loadTasks();
  }

  final TasksRepository _repository;
  Timer? _retryTimer;

  Future<void> _loadTasks() async {
    state = state.copyWith(isLoading: true, clearError: true);
    await _flushQueue(force: true);
    try {
      final tasks = await _repository.fetchTasks();
      state = state.copyWith(tasks: tasks, isLoading: false, clearError: true);
    } catch (error) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: error.toString(),
      );
    }
  }

  Future<void> refresh() => _loadTasks();

  Future<void> syncPending() async {
    await _flushQueue(force: true);
  }

  Future<void> addTask(TaskDraft draft) async {
    final now = DateTime.now();
    final pendingTask = Task(
      id: _generateRequestId(prefix: 'local'),
      title: draft.title,
      description: draft.description,
      dueAt: draft.dueAt,
      priority: draft.priority,
      estimatedMinutes: draft.estimatedMinutes,
      energyLevel: draft.energyLevel,
      status: draft.status,
      createdAt: now,
      updatedAt: now,
    );

    if (state.isOffline) {
      _enqueueOperation(TaskOperationType.create, pendingTask);
      _applyLocalChange(pendingTask);
      return;
    }

    await _executeCreate(pendingTask);
  }

  Future<void> updateTask(Task task, TaskDraft draft) async {
    final updatedTask = task.copyWith(
      title: draft.title,
      description: draft.description,
      dueAt: draft.dueAt,
      priority: draft.priority,
      estimatedMinutes: draft.estimatedMinutes,
      energyLevel: draft.energyLevel,
      status: draft.status,
      updatedAt: DateTime.now(),
    );

    if (state.isOffline) {
      _enqueueOperation(TaskOperationType.update, updatedTask);
      _replaceTask(task.id, updatedTask);
      return;
    }

    await _executeUpdate(updatedTask);
  }

  Future<void> deleteTask(Task task) async {
    final deletedTask = task.copyWith(deleted: true, updatedAt: DateTime.now());
    if (state.isOffline) {
      _enqueueOperation(TaskOperationType.delete, deletedTask);
      _removeTask(task.id);
      return;
    }

    await _executeDelete(deletedTask);
  }

  void toggleOfflineMode() {
    final wasOffline = state.isOffline;
    state = state.copyWith(isOffline: !state.isOffline);
    if (wasOffline && !state.isOffline) {
      unawaited(_flushQueue(force: true));
    }
  }

  void clearError() {
    if (state.errorMessage != null) {
      state = state.copyWith(clearError: true);
    }
  }

  void _applyLocalChange(Task task) {
    state = state.copyWith(tasks: <Task>[...state.tasks, task]);
  }

  void _replaceTask(String originalId, Task updated) {
    final tasks = state.tasks.map((task) {
      if (task.id == originalId) {
        return updated;
      }
      return task;
    }).toList();
    state = state.copyWith(tasks: tasks);
  }

  void _removeTask(String id) {
    state = state.copyWith(tasks: state.tasks.where((task) => task.id != id).toList());
  }

  void _enqueueOperation(TaskOperationType type, Task task) {
    final operation = PendingTaskOperation(
      type: type,
      task: task,
      requestId: _generateRequestId(),
      enqueuedAt: DateTime.now(),
    );
    state = state.copyWith(
      pendingOperations: <PendingTaskOperation>[...state.pendingOperations, operation],
    );
    _scheduleRetry();
  }

  Future<void> _flushQueue({bool force = false}) async {
    if (state.pendingOperations.isEmpty) {
      _cancelRetry();
      return;
    }

    if (state.isOffline && !force) {
      _scheduleRetry();
      return;
    }

    final List<PendingTaskOperation> remaining = <PendingTaskOperation>[];
    var hadError = false;
    for (final operation in state.pendingOperations) {
      try {
        switch (operation.type) {
          case TaskOperationType.create:
            final created = await _repository.createTask(operation.task);
            _replaceTask(operation.task.id, created);
            break;
          case TaskOperationType.update:
            final updated = await _repository.updateTask(operation.task);
            _replaceTask(operation.task.id, updated);
            break;
          case TaskOperationType.delete:
            await _repository.deleteTask(operation.task.id);
            _removeTask(operation.task.id);
            break;
        }
      } catch (error) {
        hadError = true;
        remaining.add(operation);
      }
    }

    state = state.copyWith(
      pendingOperations: remaining,
      isOffline: hadError && remaining.isNotEmpty,
    );

    if (remaining.isEmpty) {
      _cancelRetry();
    } else {
      _scheduleRetry();
    }
  }

  Future<void> _executeCreate(Task pendingTask) async {
    try {
      final created = await _repository.createTask(pendingTask);
      _applyOrInsert(created);
    } catch (error) {
      _enqueueOperation(TaskOperationType.create, pendingTask);
      state = state.copyWith(errorMessage: error.toString(), isOffline: true);
    }
  }

  Future<void> _executeUpdate(Task updatedTask) async {
    try {
      final updated = await _repository.updateTask(updatedTask);
      _replaceTask(updatedTask.id, updated);
    } catch (error) {
      _enqueueOperation(TaskOperationType.update, updatedTask);
      state = state.copyWith(errorMessage: error.toString(), isOffline: true);
    }
  }

  Future<void> _executeDelete(Task deletedTask) async {
    try {
      await _repository.deleteTask(deletedTask.id);
      _removeTask(deletedTask.id);
    } catch (error) {
      _enqueueOperation(TaskOperationType.delete, deletedTask);
      state = state.copyWith(errorMessage: error.toString(), isOffline: true);
    }
  }

  void _applyOrInsert(Task task) {
    final tasks = [...state.tasks];
    final index = tasks.indexWhere((element) => element.id == task.id);
    if (index == -1) {
      tasks.add(task);
    } else {
      tasks[index] = task;
    }
    state = state.copyWith(tasks: tasks);
  }

  String _generateRequestId({String prefix = 'req'}) {
    final timestamp = DateTime.now().microsecondsSinceEpoch;
    return '$prefix-$timestamp';
  }

  void _scheduleRetry() {
    _retryTimer ??= Timer.periodic(const Duration(seconds: 4), (_) {
      unawaited(_flushQueue(force: true));
    });
  }

  void _cancelRetry() {
    _retryTimer?.cancel();
    _retryTimer = null;
  }
}

final tasksControllerProvider = StateNotifierProvider<TasksController, TasksState>((ref) {
  final repository = ref.read(tasksRepositoryProvider);
  return TasksController(repository);
});


========================================
FILE: ./Flutter/lib/features/tasks/application/tasks_state.dart
========================================

import '../domain/task.dart';

enum TaskOperationType { create, update, delete }

class PendingTaskOperation {
  PendingTaskOperation({
    required this.type,
    required this.task,
    required this.requestId,
    required this.enqueuedAt,
  });

  final TaskOperationType type;
  final Task task;
  final String requestId;
  final DateTime enqueuedAt;
}

class TasksState {
  const TasksState({
    this.tasks = const <Task>[],
    this.isLoading = false,
    this.isOffline = false,
    this.pendingOperations = const <PendingTaskOperation>[],
    this.errorMessage,
  });

  final List<Task> tasks;
  final bool isLoading;
  final bool isOffline;
  final List<PendingTaskOperation> pendingOperations;
  final String? errorMessage;

  TasksState copyWith({
    List<Task>? tasks,
    bool? isLoading,
    bool? isOffline,
    List<PendingTaskOperation>? pendingOperations,
    String? errorMessage,
    bool clearError = false,
  }) {
    return TasksState(
      tasks: tasks ?? this.tasks,
      isLoading: isLoading ?? this.isLoading,
      isOffline: isOffline ?? this.isOffline,
      pendingOperations: pendingOperations ?? this.pendingOperations,
      errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
    );
  }
}


========================================
FILE: ./Flutter/lib/features/tasks/data/tasks_api_service.dart
========================================

import 'dart:async';

import '../domain/task.dart';

class TasksApiService {
  TasksApiService() {
    final now = DateTime.now();
    _remoteTasks.addAll(<Task>[
      Task(
        id: _generateId(),
        title: 'Write planning doc',
        description: 'Draft sprint backlog and share with the team',
        dueAt: now.add(const Duration(days: 1)),
        priority: TaskPriority.high,
        estimatedMinutes: 90,
        status: TaskStatus.inProgress,
        createdAt: now.subtract(const Duration(days: 1)),
        updatedAt: now,
      ),
      Task(
        id: _generateId(),
        title: 'Review Tasks API',
        description: 'Double-check idempotency rules before release',
        dueAt: now.add(const Duration(days: 2)),
        priority: TaskPriority.medium,
        estimatedMinutes: 60,
        status: TaskStatus.todo,
        createdAt: now.subtract(const Duration(days: 2)),
        updatedAt: now,
      ),
    ]);
  }

  final List<Task> _remoteTasks = <Task>[];

  Future<List<Task>> fetchTasks() async {
    await Future<void>.delayed(const Duration(milliseconds: 500));
    return List<Task>.unmodifiable(_remoteTasks.where((task) => !task.deleted));
  }

  Future<Task> createTask(Task task) async {
    await Future<void>.delayed(const Duration(milliseconds: 400));
    final now = DateTime.now();
    final createdTask = task.copyWith(
      id: task.id.isEmpty || task.id.startsWith('local') ? _generateId() : task.id,
      createdAt: task.createdAt == task.updatedAt ? now : task.createdAt,
      updatedAt: now,
      deleted: false,
    );
    _remoteTasks.removeWhere((existing) => existing.id == createdTask.id);
    _remoteTasks.add(createdTask);
    return createdTask;
  }

  Future<Task> updateTask(Task task) async {
    await Future<void>.delayed(const Duration(milliseconds: 400));
    final current = _remoteTasks.firstWhere((item) => item.id == task.id, orElse: () => task);
    final updated = current.copyWith(
      title: task.title,
      description: task.description,
      dueAt: task.dueAt,
      priority: task.priority,
      estimatedMinutes: task.estimatedMinutes,
      energyLevel: task.energyLevel,
      status: task.status,
      updatedAt: DateTime.now(),
    );
    _remoteTasks.removeWhere((existing) => existing.id == updated.id);
    _remoteTasks.add(updated);
    return updated;
  }

  Future<void> deleteTask(String id) async {
    await Future<void>.delayed(const Duration(milliseconds: 300));
    final currentIndex = _remoteTasks.indexWhere((task) => task.id == id);
    if (currentIndex != -1) {
      final current = _remoteTasks[currentIndex];
      _remoteTasks[currentIndex] = current.copyWith(
        deleted: true,
        updatedAt: DateTime.now(),
      );
    }
  }

  String _generateId() => DateTime.now().microsecondsSinceEpoch.toString();
}


========================================
FILE: ./Flutter/lib/features/tasks/data/tasks_repository.dart
========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../domain/task.dart';
import 'tasks_api_service.dart';

class TasksRepository {
  TasksRepository(this._apiService);

  final TasksApiService _apiService;

  Future<List<Task>> fetchTasks() => _apiService.fetchTasks();

  Future<Task> createTask(Task task) => _apiService.createTask(task);

  Future<Task> updateTask(Task task) => _apiService.updateTask(task);

  Future<void> deleteTask(String id) => _apiService.deleteTask(id);
}

final tasksApiServiceProvider = Provider<TasksApiService>((ref) {
  return TasksApiService();
});

final tasksRepositoryProvider = Provider<TasksRepository>((ref) {
  final api = ref.read(tasksApiServiceProvider);
  return TasksRepository(api);
});


========================================
FILE: ./Flutter/lib/features/tasks/domain/task.dart
========================================

import 'package:flutter/foundation.dart';

enum TaskStatus { todo, inProgress, done, deferred }

enum TaskPriority { low, medium, high }

@immutable
class Task {
  const Task({
    required this.id,
    required this.title,
    this.description,
    this.dueAt,
    this.priority = TaskPriority.medium,
    this.estimatedMinutes,
    this.energyLevel,
    this.status = TaskStatus.todo,
    required this.createdAt,
    required this.updatedAt,
    this.deleted = false,
  });

  final String id;
  final String title;
  final String? description;
  final DateTime? dueAt;
  final TaskPriority priority;
  final int? estimatedMinutes;
  final String? energyLevel;
  final TaskStatus status;
  final DateTime createdAt;
  final DateTime updatedAt;
  final bool deleted;

  Task copyWith({
    String? id,
    String? title,
    String? description,
    DateTime? dueAt,
    TaskPriority? priority,
    int? estimatedMinutes,
    String? energyLevel,
    TaskStatus? status,
    DateTime? createdAt,
    DateTime? updatedAt,
    bool? deleted,
  }) {
    return Task(
      id: id ?? this.id,
      title: title ?? this.title,
      description: description ?? this.description,
      dueAt: dueAt ?? this.dueAt,
      priority: priority ?? this.priority,
      estimatedMinutes: estimatedMinutes ?? this.estimatedMinutes,
      energyLevel: energyLevel ?? this.energyLevel,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deleted: deleted ?? this.deleted,
    );
  }

  factory Task.fromJson(Map<String, dynamic> json) {
    return Task(
      id: json['id'] as String,
      title: json['title'] as String,
      description: json['description'] as String?,
      dueAt: json['due_at'] != null ? DateTime.parse(json['due_at'] as String) : null,
      priority: TaskPriority.values.firstWhere(
        (priority) => describeEnum(priority) == json['priority'],
        orElse: () => TaskPriority.medium,
      ),
      estimatedMinutes: json['estimated_minutes'] as int?,
      energyLevel: json['energy_level'] as String?,
      status: TaskStatus.values.firstWhere(
        (status) => describeEnum(status) == json['status'],
        orElse: () => TaskStatus.todo,
      ),
      createdAt: DateTime.parse(json['created_at'] as String),
      updatedAt: DateTime.parse(json['updated_at'] as String),
      deleted: json['deleted'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return <String, dynamic>{
      'id': id,
      'title': title,
      'description': description,
      'due_at': dueAt?.toIso8601String(),
      'priority': describeEnum(priority),
      'estimated_minutes': estimatedMinutes,
      'energy_level': energyLevel,
      'status': describeEnum(status),
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
      'deleted': deleted,
    };
  }
}

class TaskDraft {
  const TaskDraft({
    required this.title,
    this.description,
    this.dueAt,
    this.priority = TaskPriority.medium,
    this.estimatedMinutes,
    this.energyLevel,
    this.status = TaskStatus.todo,
  });

  final String title;
  final String? description;
  final DateTime? dueAt;
  final TaskPriority priority;
  final int? estimatedMinutes;
  final String? energyLevel;
  final TaskStatus status;
}


========================================
FILE: ./Flutter/lib/features/tasks/presentation/tasks_screen.dart
========================================

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../application/tasks_controller.dart';
import '../domain/task.dart';
import 'widgets/task_form_sheet.dart';
import 'widgets/task_list_item.dart';

class TasksScreen extends ConsumerWidget {
  const TasksScreen({super.key});

  void _openForm(BuildContext context, WidgetRef ref, {Task? task}) {
    showModalBottomSheet<void>(
      context: context,
      isScrollControlled: true,
      builder: (_) => TaskFormSheet(
        initialTask: task,
        onSubmit: (draft) {
          final controller = ref.read(tasksControllerProvider.notifier);
          if (task == null) {
            controller.addTask(draft);
          } else {
            controller.updateTask(task, draft);
          }
        },
      ),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(tasksControllerProvider);
    final controller = ref.read(tasksControllerProvider.notifier);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Tasks'),
        actions: <Widget>[
          IconButton(
            tooltip: state.isOffline ? 'Offline mode' : 'Go offline',
            icon: Stack(
              children: <Widget>[
                Icon(state.isOffline ? Icons.cloud_off : Icons.cloud_queue),
                if (state.pendingOperations.isNotEmpty)
                  Positioned(
                    right: 0,
                    top: 0,
                    child: CircleAvatar(
                      radius: 8,
                      backgroundColor: Theme.of(context).colorScheme.error,
                      child: Text(
                        state.pendingOperations.length.toString(),
                        style: const TextStyle(fontSize: 10, color: Colors.white),
                      ),
                    ),
                  ),
              ],
            ),
            onPressed: controller.toggleOfflineMode,
          ),
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: controller.refresh,
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        icon: const Icon(Icons.add_task),
        label: const Text('New task'),
        onPressed: () => _openForm(context, ref),
      ),
      body: Column(
        children: <Widget>[
          if (state.errorMessage != null)
            MaterialBanner(
              content: Text(state.errorMessage!),
              leading: const Icon(Icons.error_outline),
              actions: <Widget>[
                TextButton(
                  onPressed: controller.clearError,
                  child: const Text('Dismiss'),
                ),
              ],
            ),
          if (state.pendingOperations.isNotEmpty)
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              child: Row(
                children: <Widget>[
                  const Icon(Icons.sync_problem_outlined),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'Queued: ${state.pendingOperations.length} ops waiting for connection',
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ),
                  if (!state.isOffline)
                    TextButton(
                      onPressed: controller.syncPending,
                      child: const Text('Sync now'),
                    ),
                ],
              ),
            ),
          Expanded(
            child: state.isLoading
                ? const Center(child: CircularProgressIndicator())
                : state.tasks.isEmpty
                    ? const _EmptyTasks()
                    : ListView.builder(
                        itemCount: state.tasks.length,
                        itemBuilder: (context, index) {
                          final task = state.tasks[index];
                          return TaskListItem(
                            task: task,
                            onTap: () => _openForm(context, ref, task: task),
                            onDelete: () => controller.deleteTask(task),
                          );
                        },
                      ),
          ),
        ],
      ),
    );
  }
}

class _EmptyTasks extends StatelessWidget {
  const _EmptyTasks();

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: <Widget>[
          const Icon(Icons.check_circle_outline, size: 64),
          const SizedBox(height: 12),
          Text(
            'No tasks yet',
            style: Theme.of(context).textTheme.titleMedium,
          ),
          const SizedBox(height: 4),
          Text(
            'Create your first task to start planning',
            style: Theme.of(context).textTheme.bodyMedium,
          ),
        ],
      ),
    );
  }
}


========================================
FILE: ./Flutter/lib/features/tasks/presentation/widgets/task_form_sheet.dart
========================================

import 'package:flutter/material.dart';

import '../../domain/task.dart';

class TaskFormSheet extends StatefulWidget {
  const TaskFormSheet({
    super.key,
    this.initialTask,
    required this.onSubmit,
  });

  final Task? initialTask;
  final void Function(TaskDraft) onSubmit;

  @override
  State<TaskFormSheet> createState() => _TaskFormSheetState();
}

class _TaskFormSheetState extends State<TaskFormSheet> {
  final _formKey = GlobalKey<FormState>();
  late String _title;
  String? _description;
  DateTime? _dueAt;
  TaskPriority _priority = TaskPriority.medium;
  TaskStatus _status = TaskStatus.todo;
  int? _estimatedMinutes;

  @override
  void initState() {
    super.initState();
    final task = widget.initialTask;
    if (task != null) {
      _title = task.title;
      _description = task.description;
      _dueAt = task.dueAt;
      _priority = task.priority;
      _status = task.status;
      _estimatedMinutes = task.estimatedMinutes;
    } else {
      _title = '';
    }
  }

  Future<void> _pickDueDate() async {
    final now = DateTime.now();
    final picked = await showDatePicker(
      context: context,
      initialDate: _dueAt ?? now,
      firstDate: now.subtract(const Duration(days: 365)),
      lastDate: now.add(const Duration(days: 365)),
    );
    if (picked != null) {
      setState(() {
        _dueAt = picked;
      });
    }
  }

  void _submit() {
    final isValid = _formKey.currentState?.validate() ?? false;
    if (!isValid) return;
    _formKey.currentState?.save();
    widget.onSubmit(
      TaskDraft(
        title: _title.trim(),
        description: _description?.trim(),
        dueAt: _dueAt,
        priority: _priority,
        status: _status,
        estimatedMinutes: _estimatedMinutes,
      ),
    );
    Navigator.of(context).pop();
  }

  @override
  Widget build(BuildContext context) {
    final isEditing = widget.initialTask != null;
    return Padding(
      padding: EdgeInsets.only(
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      child: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: <Widget>[
              Container(
                width: 48,
                height: 4,
                margin: const EdgeInsets.only(bottom: 12),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.outline,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              Text(
                isEditing ? 'Edit task' : 'New task',
                style: Theme.of(context).textTheme.titleLarge,
              ),
              const SizedBox(height: 12),
              TextFormField(
                initialValue: _title,
                decoration: const InputDecoration(labelText: 'Title'),
                onSaved: (value) => _title = value ?? '',
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Title is required';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 12),
              TextFormField(
                initialValue: _description,
                decoration: const InputDecoration(labelText: 'Description'),
                maxLines: 3,
                onSaved: (value) => _description = value,
              ),
              const SizedBox(height: 12),
              Row(
                children: <Widget>[
                  Expanded(
                    child: DropdownButtonFormField<TaskPriority>(
                      value: _priority,
                      decoration: const InputDecoration(labelText: 'Priority'),
                      items: TaskPriority.values
                          .map((priority) => DropdownMenuItem<TaskPriority>(
                                value: priority,
                                child: Text(priority.name.toUpperCase()),
                              ))
                          .toList(),
                      onChanged: (value) {
                        if (value != null) {
                          setState(() => _priority = value);
                        }
                      },
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: DropdownButtonFormField<TaskStatus>(
                      value: _status,
                      decoration: const InputDecoration(labelText: 'Status'),
                      items: TaskStatus.values
                          .map((status) => DropdownMenuItem<TaskStatus>(
                                value: status,
                                child: Text(status.name.toUpperCase()),
                              ))
                          .toList(),
                      onChanged: (value) {
                        if (value != null) {
                          setState(() => _status = value);
                        }
                      },
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                children: <Widget>[
                  Expanded(
                    child: TextFormField(
                      initialValue: _estimatedMinutes?.toString(),
                      decoration: const InputDecoration(labelText: 'Estimated minutes'),
                      keyboardType: TextInputType.number,
                      onSaved: (value) => _estimatedMinutes = int.tryParse(value ?? ''),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: OutlinedButton.icon(
                      onPressed: _pickDueDate,
                      icon: const Icon(Icons.event),
                      label: Text(_dueAt != null
                          ? MaterialLocalizations.of(context).formatMediumDate(_dueAt!)
                          : 'Pick due date'),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _submit,
                  child: Text(isEditing ? 'Save changes' : 'Create task'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


========================================
FILE: ./Flutter/lib/features/tasks/presentation/widgets/task_list_item.dart
========================================

import 'package:flutter/material.dart';

import '../../domain/task.dart';

class TaskListItem extends StatelessWidget {
  const TaskListItem({
    super.key,
    required this.task,
    this.onTap,
    this.onDelete,
  });

  final Task task;
  final VoidCallback? onTap;
  final VoidCallback? onDelete;

  Color _priorityColor(TaskPriority priority, BuildContext context) {
    switch (priority) {
      case TaskPriority.high:
        return Theme.of(context).colorScheme.error;
      case TaskPriority.medium:
        return Theme.of(context).colorScheme.primary;
      case TaskPriority.low:
        return Theme.of(context).colorScheme.secondary;
    }
  }

  String _statusLabel(TaskStatus status) {
    switch (status) {
      case TaskStatus.todo:
        return 'To do';
      case TaskStatus.inProgress:
        return 'In progress';
      case TaskStatus.done:
        return 'Done';
      case TaskStatus.deferred:
        return 'Deferred';
    }
  }

  @override
  Widget build(BuildContext context) {
    final dueText = task.dueAt != null
        ? 'Due ${MaterialLocalizations.of(context).formatShortDate(task.dueAt!)}'
        : 'No due date';
    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: <Widget>[
              Container(
                height: 10,
                width: 10,
                margin: const EdgeInsets.only(top: 4),
                decoration: BoxDecoration(
                  color: _priorityColor(task.priority, context),
                  shape: BoxShape.circle,
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: <Widget>[
                    Text(
                      task.title,
                      style: Theme.of(context).textTheme.titleMedium,
                    ),
                    if (task.description != null && task.description!.isNotEmpty)
                      Padding(
                        padding: const EdgeInsets.only(top: 4),
                        child: Text(
                          task.description!,
                          style: Theme.of(context).textTheme.bodyMedium,
                        ),
                      ),
                    Padding(
                      padding: const EdgeInsets.only(top: 8),
                      child: Wrap(
                        spacing: 8,
                        runSpacing: 4,
                        children: <Widget>[
                          Chip(
                            label: Text(_statusLabel(task.status)),
                            backgroundColor: Theme.of(context)
                                .colorScheme
                                .primaryContainer
                                .withOpacity(0.6),
                            visualDensity: VisualDensity.compact,
                          ),
                          Chip(
                            label: Text(dueText),
                            visualDensity: VisualDensity.compact,
                          ),
                          if (task.estimatedMinutes != null)
                            Chip(
                              label: Text('${task.estimatedMinutes} min'),
                              visualDensity: VisualDensity.compact,
                            ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
              if (onDelete != null)
                IconButton(
                  icon: const Icon(Icons.delete_outline),
                  onPressed: onDelete,
                ),
            ],
          ),
        ),
      ),
    );
  }
}


========================================
FILE: ./Flutter/lib/main.dart
========================================

import 'package:flutter/widgets.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'app/bootstrap.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  final container = await bootstrap();
  runApp(UncontrolledProviderScope(container: container, child: const LifeMergeApp()));
}


========================================
FILE: ./Flutter/LifeMerge_docs/00_Administration/Decisions_Log.md
========================================

# Template for new decisions

## DEC-XXX — Название решения
**Дата:**  
**Категория:**  
**Статус:** Proposed / Accepted / Rejected / Deprecated  
**Ответственный:**  

### Контекст

### Решение

### Причины

### Влияние


### Альтернативы

### Риски


### Миграции / технические действия

### Ссылки



========================================
FILE: ./Flutter/LifeMerge_docs/00_Administration/Glossary.md
========================================

# Glossary – LifeMerge

Документ содержит список терминов, используемых в проекте LifeMerge, их определения и контекст применения.

Структура:
1. Основные термины продукта
2. Планирование и задачи
3. Финансы
4. AI и машинное обучение
5. Архитектура и backend
6. Мобильная разработка (Flutter)
7. Метрики и аналитика
8. Подписки и монетизация
9. Процессы разработки
10. Специфические термины LifeMerge

---

## 1. Основные термины продукта

**LifeMerge**  
Приложение «операционная система жизни», объединяющее цели, задачи, календарь, финансы и AI.

**Сфера жизни (Life Sphere)**  
Категории: работа, здоровье, личное, финансы, учёба и т.д.

**Event (Событие)**  
Любая запись в календаре: встреча, смена, сон, поезка, спорт, финансовое событие.

**Task (Задача)**  
Единица работы, которую пользователь должен выполнить. Может быть привязана к цели или календарю.

**Goal (Цель)**  
Стратегическая задача, состоящая из подзадач.

**Inbox (GTD)**  
Входящие идеи, мысли, задачи без структуры.

---

## 2. Планирование и задачи

**Time Blocking (Блоки времени)**  
Метод планирования, при котором задачи размещаются на временной шкале.

**Working Schedule (Рабочий график)**  
Шаблон рабочей нагрузки (5/2, 2/2, 3/3, ночные смены и т.д.).

**Recurring Task (Регулярная задача)**  
Автоматически повторяющаяся задача по правилу.

**Splittable Task (Дробимая задача)**  
Задача, разбиваемая на несколько временных слотов.

**Context (Контекст)**  
Условие выполнения задачи (например, «@компьютер», «@дом», «@дорога»).

**Energy Level (Энергозатратность)**  
Оценка сложности задачи — лёгкая, средняя, тяжёлая.

---

## 3. Финансы

**Finance Record (Финансовая запись)**  
Доход или расход.

**Recurring Finance Record (Регулярный платёж)**  
Платёж, повторяющийся по расписанию.

**Budget Forecast (Прогноз бюджета)**  
Прогноз финансовой активности на будущее.

**Linked Finance Event (Финансовое событие календаря)**  
Финансовая запись, привязанная к событию календаря.

**Account (Счёт)**  
Источник средств: карточка, наличные, депозит.

---

## 4. AI и машинное обучение

**AI Planner**  
Модуль, предлагающий оптимальные слоты для задач.

**Rule Compliance (Соблюдение правил)**  
AI должен соблюдать правила пользователя (например, «не ставить задачи вечером»).

**AI Suggestion (AI-рекомендация)**  
Предложение AI (изменить слоты, перенести задачу, убрать перегрузку).

**Fallback**  
Поведение системы, когда AI не может дать валидный результат.

**AI Model Versioning**  
Система управления версиями моделей AI.

---

## 5. Архитектура и backend

**API (Application Programming Interface)**  
Взаимодействие между клиентом и сервером.

**Endpoint**  
Конкретный адрес API (например, POST /tasks).

**Entity**  
Основная сущность в системе (user, task, event, finance_record).

**Migration (Миграция)**  
Изменение структуры базы данных.

**Queue (Очередь синхронизации)**  
Механизм отправки событий офлайн-режима после восстановления сети.

---

## 6. Мобильная разработка

**Flutter**  
Фреймворк кроссплатформенной разработки.

**State Management**  
Архитектурный подход для управления состоянием (в LifeMerge — Riverpod).

**Offline Cache (Оффлайн-кэш)**  
Хранение данных локально на устройстве.

**Sync Entry**  
Единица данных, ожидающая синхронизации.

---

## 7. Метрики и аналитика

**NSM (North Star Metric)**  
Ключевая метрика успеха продукта — Weekly Productive Engagement.

**DAU/WAU/MAU**  
Daily / Weekly / Monthly Active Users.

**Activation Rate**  
Процент пользователей, достигших первой ценности продукта.

**Retention D1/D7/D30**  
Удержание пользователей в динамике.

**AI Adoption Rate**  
Доля пользователей, использующих AI.

**Plan Acceptance Rate**  
Процент принятых планов AI.

---

## 8. Подписки и монетизация

**Free Tier**  
Бесплатный тариф с базовыми возможностями.

**Pro Tier**  
Платный тариф с AI, расширенной аналитикой, автоматизацией.

**Trial Period**  
Пробный период использования Pro.

**LTV (Lifetime Value)**  
Ценность пользователя за всё время.

**Churn**  
Отток пользователей.

---

## 9. Процессы разработки

**DoR (Definition of Ready)**  
Критерии готовности задачи к разработке.

**DoD (Definition of Done)**  
Критерии завершённости задачи.

**Release Candidate (RC)**  
Потенциальная сборка для продакшена.

**Hotfix**  
Срочное исправление критического бага на проде.

**CCB (Change Control Board)**  
Группа, утверждающая крупные изменения.

---

## 10. Специфические термины LifeMerge

**Life Intelligence Layer**  
Аналитический уровень Pro 2.0, анализирующий влияние времени, целей и финансов друг на друга.

**Autonomy Mode**  
Режим полуавтономного AI — управляется только по согласию пользователя.

**Planning Consistency Index**  
Метрика устойчивости планирования: насколько фактические действия совпадают с планом.

**Sphere Cross-Impact Analytics**  
Отчёт взаимного влияния сфер жизни.

---

## История изменений
| Дата | Автор | Изменения |
|------|--------|------------|
| 2025-01-XX | … | Первая версия |
| 2025-01-XX | … | Добавлены термины AI и Analytics |



========================================
FILE: ./Flutter/LifeMerge_docs/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning /Mobile Sprint 01 — Technical Breakdown (Jira-ready).md
========================================

# 📱 Mobile — Sprint 01 (Foundation + A1)

## EPIC M0 — Core App Skeleton & Infrastructure

### M0.1 Finalize App Skeleton

**Type:** Story
**Priority:** P0

**Scope:**

* Зафиксировать структуру слоёв: `presentation / application / domain / data / core`.
* Финализировать DI-контейнер (scope per feature).
* App bootstrap (env, flavors, error handling root).
* AppRouter + Shell (Auth / Calendar / Tasks / Inbox / Settings / Pro).

**DoD:**

* Проект собирается.
* Можно подключать фичи без правок core.
* Нет feature-to-feature зависимостей.

---

### M0.2 Core Storage (Secure + KV)

**Type:** Story
**Priority:** P0

**Scope:**

* `SecureStorage` (tokens, sensitive data).
* `KeyValueStorage` (flags, onboarding state, prefs).
* Чистые интерфейсы + реализации.

**Tech notes:**

* Без прямых зависимостей в features.
* Async-safe, ready для offline-first.

**DoD:**

* Используется в Auth и Onboarding.
* Покрыт базовыми unit-тестами.

---

## EPIC M1 — Theme & Design System

### M1.1 AppTheme & Tokens

**Type:** Story
**Priority:** P0

**Scope:**

* Light/Dark theme.
* Color tokens (semantic).
* Typography (H1–Caption).
* Spacing, radii.

**Tech notes:**

* Naming = UI Kit v1.0.
* Ни одного “raw color” в UI.

**DoD:**

* Theme используется по всему приложению.
* Токены — единственный источник правды.

---

### M1.2 Base UI Components

**Type:** Story
**Priority:** P0

**Scope:**

* Button (Primary / Secondary / Tertiary + loading/disabled).
* TextField (all states).
* AppBar.
* BottomNavigation.
* ModalSheet / Dialog.
* Loader / Skeleton.

**DoD:**

* Компоненты используются в Auth/Tasks/Calendar.
* Нет дублирующихся UI-реализаций.

---

## EPIC M2 — Navigation

### M2.1 App Navigation Shell

**Type:** Story
**Priority:** P0

**Scope:**

* Auth flow routes.
* Main shell (tabs).
* Guarded routes по AuthState.
* Placeholder routes для Sprint 02.

**DoD:**

* Навигация соответствует wireframes.
* После онбординга → Calendar Day.

---

## EPIC M3 — Auth & Onboarding (A1 critical)

### M3.1 Auth Domain

**Type:** Story
**Priority:** P0

**Scope:**

* Entities: User, AuthState.
* UseCases: signIn, signUp, refresh, logout, restoreSession.
* Repository interfaces.

**DoD:**

* Domain не зависит от Flutter/UI.
* Готово к mock/real data source.

---

### M3.2 Auth UI & State

**Type:** Story
**Priority:** P0

**Scope:**

* Login / Register / Recovery.
* Form validation.
* Error states.
* Loading states.

**Tech notes:**

* Riverpod.
* Single source of truth для AuthState.

**DoD:**

* Happy path A1 проходит ≤5 минут.
* Ошибки API корректно отображаются.

---

### M3.3 Onboarding Flow

**Type:** Story
**Priority:** P0

**Scope:**

* Onboarding screens.
* Persist onboarding completion.
* Transition → Main Shell.

**Analytics:**

* `Onboarding_Complete`.

**DoD:**

* Логируется один раз.
* Повторный запуск → onboarding не показывается.

---

## EPIC M4 — Tasks Core (CRUD)

### M4.1 Tasks Domain

**Type:** Story
**Priority:** P0

**Scope:**

* Task entity.
* Status lifecycle.
* CRUD use-cases.

**Constraints:**

* Без goals.
* Без recurrence.

---

### M4.2 Tasks UI

**Type:** Story
**Priority:** P0

**Scope:**

* Task List.
* Task Create/Edit.
* Complete task.

**Analytics:**

* `Task_Created`
* `Task_Completed`.

**DoD:**

* Работает offline (через queue).
* UI соответствует design states.

---

## EPIC M5 — Calendar Day (Basic)

### M5.1 Calendar Day View

**Type:** Story
**Priority:** P0

**Scope:**

* Day timeline.
* Event list.
* Empty/loading/offline states.

**Constraints:**

* No drag&drop.
* No recurrence.

---

### M5.2 Event Create (Basic)

**Type:** Story
**Priority:** P0

**Scope:**

* Create event.
* Simple start/end.
* Save to backend / queue.

**Analytics:**

* `Reached_Calendar`.

---

## EPIC M6 — Offline Queue v1

### M6.1 Offline Operations Queue

**Type:** Story
**Priority:** P0

**Scope:**

* Queue for Tasks + Events.
* request_id + updated_at.
* Retry & conflict-safe.

**Tech notes:**

* Единая реализация.
* Прозрачна для features.

**DoD:**

* Можно создавать задачи/ивенты offline.
* Синк без дублей.

---

## EPIC M7 — Analytics (A1)

### M7.1 Analytics Infrastructure

**Type:** Story
**Priority:** P0

**Scope:**

* AnalyticsService abstraction.
* Firebase + Amplitude.
* Debug logging.

---

### M7.2 A1 Events

**Type:** Story
**Priority:** P0

**Events:**

* User_SignUp
* Onboarding_Complete
* Task_Created
* Reached_Calendar

**DoD:**

* События не дублируются.
* Проверены на QA-стенде.

---

# ⏱️ Ownership

* **Даниил:** архитектура, M0, M1, M6, аналитика, ревью.
* **Дмитрий:** реализация M2–M5 под контролем.


========================================
FILE: ./Flutter/LifeMerge_docs/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning / Sprint 01–02.md
========================================

**MEETING NOTE — Strategic MVP Planning / Sprint 01–02**

**Проект:** LifeMerge
**Дата:** 12.12.2025
**Тип встречи:** Стратегическое планирование MVP (CEO-level)
**Модератор:** Олег (CEO / Founder)

**Участники:**

* Олег — CEO / Founder
* Антон — Product Manager
* Виктор — Product Analyst
* Борис — Lead UI/UX Designer
* Григорий — Interaction Designer
* Даниил — Tech Lead Mobile (Flutter)
* Дмитрий — Mobile Developer
* Егор — Backend Lead
* Евгений — Backend Developer
* Игорь — AI Lead
* Константин — AI Engineer
* Леонид — QA Lead
* Марк — QA Engineer

---

### 1. Цель встречи

1. Зафиксировать P1-ядро MVP согласно Vision / Roadmap / Charter.
2. Уточнить разделение функционала по Sprint 01 и Sprint 02.
3. Определить технические ограничения и риск-области (TZ, offline, AI Planner).
4. Раздать конкретные Action Items командам с ответственными.

---

### 2. Краткий итог обсуждения

* Подтвержден P1-scope MVP: Auth/Onboarding, Calendar Core (Day), Tasks Core, Goals (базово), Inbox, AI Planner v1 (Pro-only), Notifications, Offline Sync, Core Architecture.
* Уточнено разделение спринтов:

  * Sprint 01 — фундамент + A1 (Auth/Onboarding, Tasks CRUD без целей, Calendar Day без drag&drop, Inbox MVP, Notifications infra, аналитика для A1).
  * Sprint 02 — A2 + связки + AI Planner v1 skeleton (Goals, Task→Calendar, Calendar drag&drop, AI Planner v1, Goal Progress, Calendar Conflicts basic, Digest push).
* Зафиксированы ограничения MVP: 1 задача = 1 слот в календаре; простой рабочий график; AI Planner v1 без продвинутой персонализации.
* Подтверждена готовность Design (UI Kit v1.0, P1 wireframes, страница Ready for Dev).
* Подтверждена готовность Mobile skeleton к старту фич (слои, DI, навигация shell, storage-контракты).
* Backend подтвердил стабильность Auth/Tasks/Calendar API и требует жёсткой дисциплины по TZ/updated_at/request_id.
* AI определил минимальный контракт Planner v1 (Tasks, Calendar, Preferences, Goals, Metadata).
* QA сформулировал требования к качеству базовых модулей и базовый набор smoke-тестов для Sprint 01.

---

## 3. Decisions (Решения)

| #   | Решение                                                                                                                                                       | Обоснование                                                                                                   | Owner внедрения                |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------ |
| D1  | Утверждено P1-ядро MVP: Auth/Onboarding, Calendar Day, Tasks, Goals (базово), Inbox, AI Planner v1 (Pro-only), Notifications, Offline Sync, Core Architecture | Соответствие Product Vision, Roadmap и Metrics Plan; ядро, на котором строится A1/A2 и дальнейшая монетизация | Олег / Антон                   |
| D2  | Разделение спринтов: Sprint 01 = фундамент + A1, Sprint 02 = A2 + AI Planner skeleton                                                                         | Снижение риска расползания скопа, фокус на быстрой активации и устойчивом фундаменте                          | Олег / Антон                   |
| D3  | В Sprint 01 реализуем Calendar Day без drag&drop и сложных recurrence                                                                                         | Ускорение time-to-value, уменьшение технической сложности и рисков миграций на старте                         | Антон / Даниил / Егор          |
| D4  | Вводим MVP-ограничение: 1 задача = 1 слот в календаре (no many-to-many)                                                                                       | Снижение сложности Calendar/Tasks/AI, уменьшение риска сложных миграций по связям                             | Антон / Егор                   |
| D5  | Рабочие графики в MVP реализуются в простом формате (без сложных паттернов и истории смен)                                                                    | Избежать высокой сложности в Calendar и Data Model на MVP-этапе                                               | Антон / Егор                   |
| D6  | AI Planner v1 на MVP работает как rule-based+LLM skeleton с минимальным контрактом (Tasks, Calendar, Preferences, Goals)                                      | Быстрый запуск Pro-ценности, минимизация рисков ML и сложности персонализации на старте                       | Олег / Игорь                   |
| D7  | Все времена храним в UTC, клиент передает TZ в заголовке; единый middleware для idempotency/updated_at/request_id                                             | Устойчивость Offline Sync, консистентность данных, снижение риска критических багов в проде                   | Егор / Даниил                  |
| D8  | Crash-free цель для MVP: ≥99% (цель после стабилизации — 99.5%+)                                                                                              | Поддержка премиального позиционирования продукта и Pro-монетизации                                            | Олег / Леонид                  |
| D9  | Обязательная аналитика для событий A1/A2 с первого релиза (User_SignUp, Onboarding_Complete, Task_Created, Calendar_Connected и др.)                          | Необходимо для измерения активации, конверсии в Pro и продуктовых решений                                     | Антон / Виктор / Даниил / Егор |
| D10 | Design-файлы P1 (UI Kit v1.0, Ready for Dev) считаются единственным источником правды для визуала и взаимодействий                                            | Устранение разночтений, ускорение разработки и QA, снижение design-debt                                       | Борис                          |
| D11 | AI Planner API и JSON-схемы фиксируются как отдельный контракт, backend агрегирует данные, клиент передает только период и request_id                         | Разделение ответственности, упрощение клиента, соблюдение AI Architecture                                     | Игорь / Егор                   |
| D12 | QA Definition of Ready/Done становится обязательной для задач Sprint 01, влияющих на A1/A2                                                                    | Защита от недоделанных задач в критичных сценариях, контроль качества с первого инкремента                    | Леонид / Антон                 |

---

## 4. Action Items

### 4.1 Product

| #  | Action Item                                                                                                                                                                    | Owner          | Deadline (относительно встречи) | Статус |
| -- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------- | ------------------------------- | ------ |
| P1 | Зафиксировать Sprint 01 Scope в формате Sprint Plan (Auth/Onboarding, Tasks CRUD без целей, Calendar Day basic, Inbox MVP, Notifications infra, аналитика A1) и завести в Jira | Антон          | 3 рабочих дня                   | Open   |
| P2 | Подготовить сводную таблицу DoR/DoD по модулям Sprint 01 (Auth, Onboarding, Tasks, Calendar Day, Inbox, Notifications, Analytics)                                              | Антон          | 3 рабочих дня                   | Open   |
| P3 | Формально описать A1/A2 сценарии и добавить их в Metrics Plan                                                                                                                  | Антон / Виктор | 5 рабочих дней                  | Open   |
| P4 | Синхронизировать Event Spec c фактическим scope Sprint 01 (A1-события)                                                                                                         | Виктор         | 5 рабочих дней                  | Open   |

### 4.2 Design

| #    | Action Item                                                                                                                                    | Owner    | Deadline       | Статус |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------- | -------- | -------------- | ------ |
| Dsg1 | Подтвердить и заморозить список P1-экранов для Sprint 01; убедиться, что все состояния (empty/error/loading/offline) находятся в Ready for Dev | Борис    | 3 рабочих дня  | Open   |
| Dsg2 | Обновить Interaction Guidelines для A1-flow и Calendar Day без drag&drop                                                                       | Григорий | 5 рабочих дней | Open   |
| Dsg3 | Зафиксировать дизайн-токены (цвета, типографика, spacing, corner radius, состояния) и согласовать naming c mobile-командой                     | Борис    | 3 рабочих дня  | Open   |

### 4.3 Mobile

| #  | Action Item                                                                                                                          | Owner                              | Deadline                           | Статус |
| -- | ------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------- | ---------------------------------- | ------ |
| M1 | Завершить и зафиксировать skeleton архитектуры (слои, DI, навигация shell, storage-контракты)                                        | Даниил                             | до конца 1-й недели Sprint 01      | Open   |
| M2 | Реализовать Theme / Design System (AppTheme, типографика, colors, базовые компоненты) согласно токенам Figma                         | Даниил / Дмитрий                   | до середины Sprint 01              | Open   |
| M3 | Реализовать Auth/Onboarding (домен, состояние экранов, навигация, валидация, обработка ошибок) с интеграцией с Auth API по контракту | Дмитрий (под руководством Даниила) | до конца Sprint 01                 | Open   |
| M4 | Реализовать базовый Tasks CRUD (список, создание, редактирование, завершение) без целей                                              | Дмитрий                            | до конца Sprint 01                 | Open   |
| M5 | Реализовать Calendar Day: отображение событий + создание простого события, без drag&drop и сложных recurrence                        | Дмитрий                            | конец Sprint 01 / начало Sprint 02 | Open   |
| M6 | Реализовать offline-queue v1 для задач и событий (updated_at + request_id)                                                           | Даниил                             | до конца Sprint 01                 | Open   |
| M7 | Интегрировать аналитические события A1 (User_SignUp, Onboarding_Complete, Task_Created, Reached_Calendar)                            | Даниил / Дмитрий                   | до конца Sprint 01                 | Open   |

### 4.4 Backend

| #  | Action Item                                                                                                                        | Owner          | Deadline                                 | Статус  |
| -- | ---------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------------------------------- | ------- |
| B1 | Реализовать Auth API (/signup, /login, /refresh, /forgot, /reset, /logout) согласно спецификации                                   | Егор / Евгений | до середины Sprint 01                    | Open    |
| B2 | Реализовать Tasks API (CRUD без подзадач/recurrence на MVP-этапе) с полями priority, estimated_minutes, due_at, status, goal_id    | Егор / Евгений | до конца Sprint 01                       | Open    |
| B3 | Реализовать Calendar Events API для Day View (CRUD + базовая логика без сложных recurrence)                                        | Егор / Евгений | конец Sprint 01 / начало Sprint 02       | Open    |
| B4 | Реализовать единый middleware для TZ/idempotency (UTC storage, TZ header, updated_at, request_id) и прокинуть во все критичные API | Егор           | до конца Sprint 01                       | Open    |
| B5 | Реализовать backend-агрегацию данных для AI Planner (tasks_min, calendar_min, preferences, goals_min)                              | Егор / Евгений | Sprint 02 (подготовка в конце Sprint 01) | Planned |

### 4.5 AI

| #   | Action Item                                                                                                                          | Owner                               | Deadline                                 | Статус  |
| --- | ------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------- | ---------------------------------------- | ------- |
| AI1 | Зафиксировать JSON-схемы минимального контракта Planner v1 (tasks_min, calendar_min, preferences, goals_min) и согласовать с backend | Игорь                               | 3 рабочих дня                            | Open    |
| AI2 | Реализовать stub-реализацию /v1/ai/plan_week (детерминированный шаблонный план)                                                      | Константин (под руководством Игоря) | Sprint 02 (подготовка в конце Sprint 01) | Planned |
| AI3 | Добавить audit-поля (request_id, user_hash, model_version, prompt_version) в AI сервис                                               | Игорь / Константин                  | Sprint 02                                | Planned |
| AI4 | Подготовить sample payloads (простая неделя, перегруженная неделя, выходные) для мобайла и QA                                        | Константин                          | до начала Sprint 02                      | Planned |

### 4.6 QA

| #   | Action Item                                                                                                  | Owner         | Deadline              | Статус |
| --- | ------------------------------------------------------------------------------------------------------------ | ------------- | --------------------- | ------ |
| QA1 | Сформировать Smoke Test Checklist для Sprint 01 (Auth, Navigation, Calendar Day basic, Tasks, Offline-queue) | Леонид / Марк | 5 рабочих дней        | Open   |
| QA2 | Оформить QA Definition of Ready/Done для задач Sprint 01, влияющих на A1/A2                                  | Леонид        | 5 рабочих дней        | Open   |
| QA3 | Настроить QA-стенд и debug-режим аналитики (видимость ключевых событий A1/A2)                                | Марк          | до середины Sprint 01 | Open   |
| QA4 | Подготовить e2e-сценарии для проверки TZ и offline-синхронизации (Tasks + Calendar)                          | Леонид / Марк | до конца Sprint 01    | Open   |


========================================
FILE: ./Flutter/LifeMerge_docs/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning /Sprint01.md
========================================

## Sprint 01 Backlog — LifeMerge

### 🔖 Эпики (M0–M7)

* **M0 – Skeleton & Infrastructure**
* **M1 – Auth & Onboarding**
* **M2 – Tasks MVP**
* **M3 – Calendar Day MVP**
* **M4 – Inbox MVP**
* **M5 – Notifications Infra**
* **M6 – Analytics Events (A1)**
* **M7 – AI Planner v1 (Stub & Contracts)**

---

### 🧩 Бэклог задач по эпикам

#### 🟦 M0 – Skeleton & Infrastructure

* **[P0] Init project architecture (Mobile skeleton)**
  Assignee: Даниил
  Desc: DI, router shell, layer separation, navigation container
  Status: In Progress
  DoR: структура слоёв согласована, shell-роутинг определён

* **[P0] Storage Layer + SecurePrefs abstraction**
  Assignee: Дмитрий
  Desc: key-value + encrypted storage, clear interfaces
  DoR: согласованы контракты offline-хранилища

* **[P1] AppTheme / Tokens integration**
  Assignee: Дмитрий
  Figma: [Ready for Dev → Theme tokens](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=1001)
  Desc: типографика, цвета, spacing, радиусы — по токенам

* **[P1] Base UI Components (Buttons, TextFields, AppBars)**
  Assignee: Дмитрий
  Figma: [Ready for Dev → Components](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=2002)
  Desc: Button, TextField, BottomNav, Sheet, Dialog — по токенам

---

#### 🟦 M1 – Auth & Onboarding

* **[P0] SignUp / SignIn / Forgot / Reset / Logout flows**
  Assignee: Дмитрий
  Figma: [Ready for Dev → Auth](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=3010)
  Desc: форма, ошибки, интеграция с Auth API

* **[P0] RestoreSession & token refresh**
  Assignee: Даниил
  Desc: проверка токена, автоматическое восстановление

* **[P0] Onboarding flow + schedule setup**
  Assignee: Дмитрий
  Figma: [Ready for Dev → Onboarding](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=3020)
  Desc: мастер из 3 экранов, график работы, завершение онбординга

---

#### 🟦 M2 – Tasks MVP

* **[P0] Task List UI + offline sync**
  Assignee: Дмитрий
  Figma: [Ready for Dev → Tasks List](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=4001)
  Desc: список задач, offline состояние, pull-to-refresh

* **[P0] Create / Edit / Complete Task**
  Assignee: Даниил
  Figma: [Ready for Dev → Task Editor](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=4002)
  Desc: поля: title, priority, due_at, estimated_min, goal_id (nullable)

* **[P1] Offline queue: Tasks CRUD**
  Assignee: Дмитрий
  Desc: очередь операций + conflict resolution по updated_at

---

#### 🟦 M3 – Calendar Day MVP

* **[P0] Calendar Day View: static timeline + event list**
  Assignee: Дмитрий
  Figma: [Ready for Dev → Calendar Day](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=5001)
  Desc: отображение событий по времени, support offline read

* **[P0] Create Event: basic modal**
  Assignee: Даниил
  Figma: [Ready for Dev → Event Modal](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=5002)
  Desc: без повторений, один слот, заглушка времени

---

#### 🟦 M4 – Inbox MVP

* **[P1] Inbox screen + record input**
  Assignee: Дмитрий
  Figma: [Ready for Dev → Inbox](https://www.figma.com/file/xyz/ready-for-dev?type=design&node-id=6001)
  Desc: запись текста, отображение списка

* **[P2] Convert Inbox Item → Task**
  Assignee: Даниил
  Desc: выбор действия при обработке inbox элемента

---

#### 🟦 M5 – Notifications Infra

* **[P1] Push infra + local permissions request**
  Assignee: Даниил
  Desc: подключение Firebase, регистрация токена, проверка разрешений

---

#### 🟦 M6 – Analytics Events (A1)

* **[P0] Send A1 events to debug: User_SignUp, Onboarding_Complete, Task_Created, Reached_Calendar**
  Assignee: Дмитрий
  Desc: логика вызова и параметров, интеграция в flow

---

#### 🟦 M7 – AI Planner v1 (Stub)

* **[P0] Validate Planner JSON schemas (tasks_min, calendar_min, preferences, goals_min)**
  Assignee: Игорь
  Desc: фиксация схем, валидация, sync с backend

* **[P1] /v1/ai/plan_week stub API**
  Assignee: Константин
  Desc: приём JSON, возвращение шаблонного плана, поля plan[], notes[], audit

* **[P1] Sample payloads: normal / overloaded / weekend-only**
  Assignee: Константин
  Desc: 3 заготовки, используемые для QA и Mobile интеграции


========================================
FILE: ./Flutter/LifeMerge_docs/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning /Sprint02.md
========================================

## Metrics Plan — A1 / A2 / Core Metrics (Обновлён)

### A1 Activation (Sprint 01)

| Event               | Trigger                                           | Notes                             |
| ------------------- | ------------------------------------------------- | --------------------------------- |
| User_SignUp         | Завершена регистрация                             | email + метод                     |
| Onboarding_Complete | Пройден мастер онбординга                         | выбран график, дошёл до календаря |
| Task_Created        | Создана первая задача                             | через Task Editor                 |
| Reached_Calendar    | Пользователь открыл Calendar Day после онбординга | первый вход в планировщик         |

### A2 Activation (Sprint 02)

| Event                     | Trigger                                         | Notes                   |
| ------------------------- | ----------------------------------------------- | ----------------------- |
| Goal_Created              | Создана новая цель                              | через Goal Editor       |
| Task_Linked_To_Goal       | Привязана задача к цели                         | через goal_id           |
| Task_Attached_To_Calendar | Задача получила слот в календаре                | manual или drag         |
| AI_Planner_Used           | Пользователь нажал кнопку «Спланировать неделю» | даже если план заглушка |

### AI Metrics

| Event             | Trigger                                | Notes                 |
| ----------------- | -------------------------------------- | --------------------- |
| AI_Plan_Received  | Planner вернул plan[]                  | успешно, без ошибок   |
| AI_Plan_Confirmed | Пользователь применил план             | через UI принятия     |
| AI_Plan_Rejected  | Пользователь отменил предложенный план | измеряет недоверие/UX |

### Retention / WPAR Contribution

* WPAR = Weekly Planning Attachment Rate: есть ли цель → задачи → слот?
* Повторное использование Planner = proxy на perceived value
* Повторное создание целей = прокси на долгосрочную вовлечённость


========================================
FILE: ./Flutter/LifeMerge_docs/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning /Sprint Do R Do D.md
========================================

## DoR / DoD Таблица — Sprint 01 (LifeMerge MVP)

| Модуль            | DoR                                                                          | DoD                                                                                                           | Блокирующие зависимости                           |
| ----------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------- |
| Auth              | UI в Ready for Dev, Auth API спецификация финализирована                     | Форма работает, ошибки валидируются, токены обрабатываются, debug-логика событий есть                         | Auth API (B1)                                     |
| Onboarding        | Экраны + flow в Figma, Interaction описан, данные профиля уточнены           | Онбординг сохраняет график, фиксируется `Onboarding_Complete`, навигация завершает на Calendar Day            | Schedule Settings, Event Spec                     |
| Tasks             | Список + форма + состояния экрана готовы, API финализирован                  | CRUD работает, `Task_Created` логируется, offline-queue интегрирован                                          | Tasks API (B2), Storage Layer                     |
| Calendar Day      | Экраны и таймлайн в Ready for Dev, API по /events подтверждён                | События отображаются и создаются, `Reached_Calendar` логируется, поддержка offline                            | Calendar API (B3), Timezone Middleware (B4)       |
| Inbox MVP         | UX поток описан, UI в Ready, структура хранения известна                     | Записи создаются, отображаются, конвертация в задачу работает                                                 | Tasks (M4), Storage                               |
| Notifications     | Push-структура определена, системные разрешения проработаны                  | Приложение может прислать локальный push, инфра не падает, покрыто smoke                                      | Firebase, Permissions                             |
| Analytics Events  | Event Spec готов, события A1 определены                                      | Все ключевые события A1 (`User_SignUp`, `Onboarding_Complete`, `Task_Created`, `Reached_Calendar`) логируются | Event Spec, Analytics SDK                         |
| Core Architecture | Навигация, DI, AppTheme, offline-queue API описаны                           | Навигация работает, UI подключён к теме, offline-операции синкаются                                           | Mobile skeleton (M1), Storage, Backend Middleware |
| AI Planner (stub) | JSON-схемы (tasks_min и др.) согласованы, структура /plan_week зафиксирована | Заглушка API доступна, schema-валидатор встроен, sample payloads готовы                                       | AI1, B5, Tasks, Calendar, Preferences onboarding  |


========================================
FILE: ./Flutter/LifeMerge_docs/00_Administration/Meeting_Notes/MEETING NOTE — Strategic MVP Planning /Sprint Planning.md
========================================

## Sprint Planning — Sprint 01 (LifeMerge MVP)

**Даты спринта:** 15.12.2025 — 29.12.2025
**Product Owner:** Антон (PM)
**Scrum Master:** Олег (CEO, в роли фассилитатора)
**Команда:** Mobile (Даниил, Дмитрий), Backend (Егор, Евгений), AI (Игорь, Константин), QA (Леонид, Марк), Product (Антон, Виктор), Design (Борис, Григорий)

---

### 🎯 Цель Sprint 01

Закладка технического и продуктового фундамента MVP, реализация сценария A1:
**Install → Registration → Onboarding → First Task or Event Created ≤ 5 минут.**

---

### 🧱 Состав фич и модулей

| Модуль            | Описание                                                                 |
| ----------------- | ------------------------------------------------------------------------ |
| Auth              | Регистрация, логин, восстановление, logout                               |
| Onboarding        | Онбординг-мастер, выбор графика, завершение flow                         |
| Tasks             | Список, создание, редактирование, завершение задач                       |
| Calendar Day      | Просмотр событий на день, создание события                               |
| Inbox MVP         | Быстрая запись, отображение входящих                                     |
| Notifications     | Push-инфраструктура, напоминания о событиях и задачах                    |
| Analytics Events  | Интеграция событий: User_SignUp, Onboarding_Complete, Task_Created и др. |
| Core Architecture | DI, навигация, offline-queue, дизайн-система, storage                    |
| AI Planner (stub) | JSON-схемы, /plan_week заглушка, sample payloads, audit metadata         |

---

### 🔗 Связь с метриками и сценариями

* **A1 (Activation):** покрывается полностью.
* **A2 (Goal/Calendar):** подготовка foundation для Sprint 02.
* **WPAR:** подготавливаются элементы (задача, слот, цель) для расчёта.

---

### 📌 Зависимости

* Backend API (Auth, Tasks, Calendar) должны быть готовы в рамках спринта.
* AI контракты JSON (tasks_min и др.) входят в DoR.
* QA стенд и debug-аналитика — обязательны к середине спринта.

---

### ✅ Definition of Ready (DoR)

* Дизайн в статусе "Ready for Dev".
* API/JSON-схемы зафиксированы.
* UI Kit и Interaction Guidelines синхронизированы.
* Сценарии аналитики определены и внесены в Event Spec.

### ✅ Definition of Done (DoD)

* Все критичные баги устранены.
* Интеграционные события шлются в debug.
* Покрытие smoke QA сценариев.
* Модули работают офлайн и проходят sync.
* Визуально соответствуют UI Kit и Interaction Guidelines.

---

### 📁 Подзадачи (см. в Jira)

* [M1] Завершение skeleton архитектуры (Mobile)
* [M3] Auth/Onboarding UI + логика + API интеграция
* [M4] Tasks CRUD MVP
* [M5] Calendar Day View MVP
* [M6] Offline queue для задач/событий
* [B1] Auth API
* [B2] Tasks API
* [B3] Calendar Day API
* [B4] Middleware TZ/idempotency
* [AI1] JSON-схемы Planner v1
* [AI4] Sample payloads
* [QA1] Smoke checklist
* [QA3] Debug-аналитика A1


========================================
FILE: ./Flutter/LifeMerge_docs/00_Administration/Meeting_Notes/Template_Meeting_Note.md
========================================

# Meeting Note — {{Название встречи}}
**Дата:**  
**Участники:**  
**Тип:** Product / Design / Tech / AI / Sprint / Planning  

---

## 1. Agenda
- Пункт 1  
- Пункт 2  

---

## 2. Discussion Summary
- Основные решения  
- Открытые вопросы  

---

## 3. Decisions
| Решение | Ответственный | Дедлайн |
|---------|---------------|---------|

---

## 4. Action Items
| Задача | Ответственный | Дата |
|--------|---------------|-------|

---

## 5. Materials & Links
- Figma  
- Jira  
- Документы  



========================================
FILE: ./Flutter/LifeMerge_docs/00_Administration/Project_Charter.md
========================================

# Project Charter – LifeMerge

Официальный документ, определяющий цели, границы, принципы, ресурсы, риски и общий контекст проекта LifeMerge.

---

## 1. Project Overview (Обзор проекта)

**Название:** LifeMerge  
**Тип проекта:** Мобильное приложение + AI-платформа  
**Цель:** Создать операционную систему жизни, объединяющую календарь, задачи, цели и финансы в единую систему с AI-планировщиком.  
**Продуктовое обещание:** «Живи осознанно. Управляй всем. Достигай большего.»

---

## 2. Background & Problem Statement (Контекст и проблемы)

Современные профессионалы сталкиваются с:
- фрагментацией инструментов (календарь, задачи, заметки, финансы — отдельно),
- перегруженностью контекстами (работа, семья, здоровье, деньги),
- отсутствием связи между краткосрочными задачами и долгосрочными целями,
- финансовой неопределённостью (нет прогноза, анализа, привязки доходов/расходов к действиям),
- отсутствием персонализированного помощника, учитывающего расписание и правила пользователя.

LifeMerge решает эти проблемы комплексно.

---

## 3. Mission (Миссия проекта)

Помочь людям системно управлять своей жизнью — временем, целями, энергией и деньгами — создавая ясность, контроль и устойчивый прогресс.

---

## 4. Vision (Видение продукта)

LifeMerge станет:
- единым интерфейсом управления жизнью,
- личным помощником по продуктивности и финансам,
- системой, связывающей календарь, задачи, цели и финансы в один поток,
- платформой, адаптирующейся к личности пользователя,
- центральным элементом его ежедневной операционной среды.

---

## 5. Scope (Область проекта)

### В рамках проекта (In Scope)
- Мобильные приложения (iOS, Android) на Flutter.
- Backend-сервис (Auth, Calendar, Tasks, Finance, Inbox, AI).
- AI-планировщик задач: анализ расписания, дедлайнов, приоритетов.
- Финансовый модуль: доходы/расходы, регулярные операции, прогноз.
- GTD Inbox.
- Подписки и Pro-тариф.
- Базовая аналитика.
- Offline-кэш и отложенная синхронизация.
- Push-уведомления.

### Не входит в проект (Out of Scope)
- Полностью автономный AI (только в будущем).
- Полная web-версия (будет в Pro 2.0).
- Интеграция банков по Open Banking (этап Pro).
- Интеграции HealthKit/Google Fit (этап Autonomy).
- ML-модель, обучающаяся на данных пользователя (будущее).

---

## 6. Objectives & Success Criteria (Цели и критерии успеха)

### Основные цели проекта:
1. Создать MVP, соединяющий календарь, задачи, цели и финансы.
2. Реализовать AI-планировщик задач уровня Pro.
3. Обеспечить высокое удержание и ежедневную полезность.
4. Построить технический фундамент для дальнейшей автономности AI.

### Ключевые критерии успеха:
- **Retention D7 ≥ 25%** (целевое).
- **Trial → Pro Conversion ≥ 12–18%**.
- **AI Adoption ≥ 60% среди Pro пользователей.**
- **Crash-free ≥ 99.5%**.
- **Monthly Active Planners ≥ 40% от MAU.**

---

## 7. Deliverables (Основные артефакты)

### MVP Deliverables:
- Мобильные приложения iOS/Android.
- Календарь (день/неделя), задачи, цели.
- Финансовый модуль (доходы/расходы).
- GTD Inbox.
- Backend API + БД.
- Pro Trial + подписки.
- AI Planner v1.
- Система аналитики.
- UI-kit и дизайн систем.

### Документация:
- Product Vision, Roadmap, User Stories.
- Technical Specifications.
- Architecture documents.
- QA Plan.
- Release Plan.
- Change Management Process.
- Metrics Plan.

### MVP Functional Requirements (детализация):
- **Auth & Онбординг:** email+пароль, восстановление через письмо, онбординг 3–5 шагов с выбором рабочего графика, предложение Trial без привязки карты.
- **Календарь & Расписание:** режимы «День/Неделя», создание/редактирование/перетаскивание событий, параллельные слоты, отображение смен, время на дорогу, напоминания, привязка задач.
- **Задачи/Цели/Проекты:** задачи с приоритетами/контекстами/дедлайнами, цели/проекты, связь задач с целями, прогресс по целям, базовая фильтрация, дробление и повторяемость задач.
- **Финансы:** доходы/расходы с категориями и регулярными операциями, привязка к календарю, месячная сводка.
- **Inbox (GTD):** быстрый ввод, конвертация в задачу/цель, пошаговая обработка входящих.
- **AI Planner (Pro/Trial):** генерация плана с учётом занятости и пользовательских правил, ручное подтверждение перед записью в календарь.
- **Подписки и доступ:** просмотр тарифов, запуск Trial без списания, экран статуса подписки, видимые ограничения Free.
- **Уведомления:** запрос разрешений, настраиваемые напоминания по событиям/задачам/финансам, отдельные переключатели категорий.
- **Offline & Синхронизация:** работа с кэшем, очередь действий офлайн, автоматическая отправка и баннер статуса.
- **Настройки:** сменный график, часовой пояс, уведомления, переключение темы (опционально).

---

## 8. Constraints (Ограничения)

### Технические
- Flutter как основной фреймворк.
- PostgreSQL как основная БД.
- Строгая поддержка Offline-first архитектуры в будущем.

### Продуктовые
- Регион СНГ → важны инфляция, валюты, рабочие графики.
- Упрощённый UI — без перегрузки иллюстрациями.
- Прозрачность Pro Trial.

### Временные
- MVP за 4–5 месяцев от старта разработки.  

### Финансовые
- Ограниченные ресурсы → фокус на быстром создании ценности, а не «идеальности».

---

## 9. Assumptions (Предположения)

1. Пользователи готовы использовать приложение ежедневно или несколько раз в неделю.
2. AI-помощник увеличит ценность Pro-тарифа.
3. Финансовый модуль станет важным преимуществом на рынке СНГ.
4. Пользователи предпочтут честный Pro Trial перед paywall-first.
5. Интерфейс «Notion + Apple» хорошо воспринимается целевой аудиторией.

---

## 10. Risks (Риски)

### Технические
- Сложность интеграции AI в планировщик.
- Offline-конфликты и надёжность синхронизации.
- Потенциальные проблемы с производительностью календаря.

### Бизнес-риски
- Низкая конверсия в Pro.
- Сильная конкуренция (Notion, Todoist, TickTick, Google Calendar, local apps).
- Недостаточная привычка пользователей вести финансы.

### Продуктовые риски
- Перегруз функционалом.
- Недостаточно прозрачная ценность AI.

### Риски платформ
- Ограничения App Store/Google Play при работе с подписками.
- Региональные ограничения по платежам.

---

## 11. Stakeholders (Стейкхолдеры)

| Роль | Имя | Интересы |
|------|------|-----------|
| CEO / Founder | … | Успешный продукт, рост подписок |
| Product Manager | … | Ценность продукта, выполнение roadmap |
| Tech Lead | … | Качество архитектуры и скорость разработки |
| Backend Lead | … | Надёжность API и БД |
| AI Lead | … | Качество AI-планировщика |
| Design Lead | … | Высокий UX/UI |
| QA Lead | … | Стабильность и качество релизов |

---

## 12. Governance (Управление проектом)

- Scrum или Kanban (в зависимости от размера команды).  
- Еженедельные синки лидов.  
- Спецификация задач → refinement → DoR.  
- DoD для фич.  
- Release cadence: каждые 2 недели (patch → minor).  

---

## 13. Project Timeline (Ключевые сроки)

| Этап | Длительность | Результат |
|------|--------------|-----------|
| Pre-production | 2–3 недели | Vision, дизайн-концепт, архитектура |
| Design Sprint | 4–5 недель | UI, UX, прототипы |
| Разработка MVP | 12–16 недель | Первый рабочий продукт |
| Полировка & QA | 3–4 недели | Release Candidate |
| Closed Beta | 2–3 недели | Feedback, улучшения |
| Релиз MVP | — | Версия 1.0 |
| Pro 1.0 / Pro 2.0 | — | Дальнейшее развитие |
| Autonomy Mode | — | Дальний горизонт |

---

## 14. Approval (Утверждение)

| Имя | Роль | Статус | Дата |
|------|--------|---------|---------|
| … | CEO | ✔ | … |
| … | Product Manager | ✔ | … |
| … | Tech Lead | ✔ | … |

---

## 15. История изменений

| Дата | Версия | Автор | Изменения |
|------|---------|---------|------------|
| 2025-01-XX | 1.0 | … | Первая версия |
| … | … | … | … |



========================================
FILE: ./Flutter/LifeMerge_docs/00_Administration/Team_Roles_and_Contacts.md
========================================

# Team Roles & Contacts — LifeMerge

Документ описывает роли команды, зоны ответственности, контакты и правила коммуникации между участниками.

---

## 1. Состав команды

### Product Team
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| Product Manager |Антон| Визион, roadmap, требования, приоритизация, сценарии | @username, email |
| Product Analyst |Виктор| Метрики, аналитика, дешборды, A/B | @username, email |

### Design Team
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| Lead UI/UX Designer |Борис| Дизайн-система, макеты, прототипы, user flow | @username, email |
| Interaction Designer |Григорий| Анимации, UX-паттерны | @username, email |

### Engineering Team
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| Tech Lead (Mobile) |Даниил| Архитектура Flutter, код-ревью, технические решения | @username, email |
| Flutter Developer |Дмитрий| Реализация экранов, логики, интеграций | @username, email |
| Backend Lead |Егор| Архитектура API, БД, интеграции, DevOps | @username, email |
| Backend Developer |Евгений| Реализация API, миграции БД, очереди задач | @username, email |
| AI Lead |Игорь| Архитектура AI, модели, качество AI Planner | @username, email |
| AI Engineer |Константин| Разработка моделей, тестирование, фичи AI | @username, email |

### QA Team
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| QA Lead |Леонид| QA стратегия, регрессия, e2e | @username, email |
| QA Engineer |Марк| Тестирование фич, тест-кейсы | @username, email |
| Automation QA |Николай| Автотесты, CI/CD интеграция | @username, email |

### Business & Operations
| Роль | Имя | Основная зона ответственности | Контакты |
|------|------|------------------------------|-----------|
| CEO / Founder |Олег| Vision, инвестиции, стратегические решения | @username, email |
| Support Lead (после MVP) |Пётр| Поддержка пользователей, база знаний | @username, email |

---

## 2. Карта ответственности (RACI)

### Пример (MVP функции)
| Задача | R (ответственный) | A (утверждающий) | C (консультируемый) | I (информируемый) |
|--------|-------------------|------------------|----------------------|-------------------|
| Product Vision | PM | CEO | Design, Tech Lead | команда |
| Архитектура приложения | Tech Lead | CTO | BE Lead, AI Lead | PM |
| AI Planner MVP | AI Lead | PM | Tech Lead | QA |
| Дизайн календаря | Designer | PM | Tech Lead | QA |
| Финансовый модуль (MVP) | BE Lead | PM | Designer | QA |
| Подписки и Trial | PM | CEO | BE Lead, Tech Lead | QA |
| Offline-синк | Tech Lead | PM | BE Lead | QA |
| Release | PM | CEO | QA Lead | вся команда |

---

## 3. Правила коммуникации

### Каналы
- Slack / Telegram — ежедневная коммуникация  
- Notion / Confluence — документация  
- Jira / Linear — постановка задач  
- Figma — дизайн  
- GitHub / GitLab — код  

### Важные принципы
1. **Асинхронность предпочтительнее**, если вопрос не срочный.  
2. **Встречи только по необходимости**, с чёткой повесткой.  
3. **Решения фиксируются письменно** в Decision Log.  
4. **Общие стендапы** — 10–15 минут.  
5. **Кросс-ревью**: Mobile ↔ Backend, AI ↔ Product.

---

## 4. SLA по коммуникациям

| Тип вопроса | SLA | Канал |
|-------------|------|--------|
| Критический баг (приложение падает, данные теряются) | 15 минут | Tech чат |
| Баг высокой важности | 2 часа | QA чат |
| Запросы по дизайну | 24 часа | Design чат |
| Требования и уточнения | 24 часа | Product чат |
| Код-ревью | 12–24 часа | GitHub/GitLab |
| AI-доработки | 24–48 часов | AI чат |

---

## 5. График встреч
- **Weekly Sync** — PM + Leads  
- **Design Review** — 1–2 раза в неделю  
- **Tech Review / Architecture** — раз в неделю  
- **Sprint Planning** — каждые 2 недели  
- **Sprint Retro** — каждые 2 недели  
- **AI Quality Review** — раз в неделю  

---

## 6. Доступы и владение аккаунтами
- App Store Connect: владелец — …  
- Google Play Console: владелец — …  
- RuStore Developer: владелец — …  
- Firebase: владелец — …  
- Production Database: доступ только Backend Lead + CTO  
- Monitoring/Sentry: Tech Lead + BE Lead  

---

## 7. Экстренные контакты (для hotfix)
- Tech Lead — @…  
- Backend Lead — @…  
- AI Lead — @…  
- QA Lead — @…  
- PM — @…  

---

## 8. История изменений документа
| Дата | Автор | Изменение |
|------|--------|------------|
| 2025-01-XX | … | Создан первый вариант |
| — | — | — |




========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/Change_Management/Change_Management_Process.md
========================================

# 🔄 **CHANGE MANAGEMENT PROCESS — LifeMerge**

## Цель процесса

Обеспечить контролируемое, прозрачное, безопасное и предсказуемое внесение изменений в продукт LifeMerge:

* минимизировать риски багов и регрессий,
* защищать стабильность AI-логики,
* не ломать данные пользователей (календарь, задачи, финансы),
* избегать хаоса в Roadmap,
* сохранять предсказуемость релизов.

---

# 1. Типы изменений

Все изменения делятся на 5 категорий:

### **1) Feature Change**

* любые фичи (новые или улучшения)
* пример: AI Planner v2, межсферная аналитика, новый отчёт.

### **2) UX/UI Change**

* изменение внешнего вида и поведения интерфейса
* пример: переработка календаря недели.

### **3) Technical Change**

* архитектурные улучшения, рефакторинг, оптимизация производительности
* пример: переход на новый state-менеджер или новый механизм кэша.

### **4) Data Model Change**

* изменение структуры таблиц, индексов, связей, миграций
* пример: добавление таблицы "accounts" в финансы.

⚠️ **Наиболее критичная для рисков категория.**
Ё
### **5) Hotfix Change**

* быстрые исправления продакшн-багов
* пример: падение при генерации AI-плана.

---

# 2. Change Request Workflow (полный цикл)

Каждое изменение проходит строгий **7-шаговый путь**:

```
Proposal → Analysis → Approval → Implementation → Testing → Release → Monitoring
```

Разберём каждый шаг.

---

# 3. Шаг 1. Change Proposal (инициация)

Инициатор: PM / Tech Lead / Designer / Support / Analytics

Форма Change Request (CR) должна содержать:

1. Заголовок
2. Описание проблемы или потребности
3. Цель изменения
4. Категория change’а
5. Пользовательская ценность
6. Технический impact
7. Зависимости
8. Риски
9. Требования к аналитике
10. Требуемая дата (если есть SLA)

CR создаётся в системе управления задачами (Jira/YouTrack/Linear).

---

# 4. Шаг 2. Analysis (оценка влияния)

Ответственные:

* PM
* Tech Lead
* Backend Lead
* QA Lead
* AI Lead (если затрагивает AI)

Проводится:

### 4.1. Impact Analysis

* затрагиваемые модули: календарь, задачи, финансы, AI, оффлайн-синк
* риски данных: миграции, изменения моделей
* влияние на Free/Pro
* UX-влияние
* зависимость между платформами iOS/Android/Web
* влияние на метрики (Retention / AI Adoption / Conversion)

### 4.2. Estimation

Оценка стоимости:

* FE (Flutter)
* BE
* AI
* QA
* Дизайн

### 4.3. Solution Draft

Черновое решение: схемы, макеты, API-контракт, архитектурная записка.

**Результат:** CR переходит в статус **Ready for Approval**.

---

# 5. Шаг 3. Approval (утверждение изменений)

Решение принимают: PM + Tech Lead
Для изменения Data Model или AI-логики — также AI Lead + Backend Lead.

### Критерий одобрения:

* Решение соответствует Roadmap
* Не ломает пользовательские данные
* Не нарушает принципы UX
* Технически возможно в заданные сроки
* Соответствует бизнес-целям

### Возможные исходы:

* Approved
* Approved with changes
* Rejected
* Deferred (перенос в будущее)

---

# 6. Шаг 4. Implementation (разработка)

Команда создаёт отдельную ветку feature/xxx в репозитории.

### Требования:

1. Следовать архитектурным правилам (Riverpod, Clean Architecture, Dio, offline queue и т.д.)
2. Для Data Model → миграции согласуются заранее с backend.
3. Для AI → используется feature flag.
4. Для UX → никто не отклоняется от Figma-схем.
5. Для сложности оценки → разбить на несколько задач (epic → stories → tasks).

---

# 7. Шаг 5. Testing (QA + авто-тесты)

QA должна протестировать 4 слоя:

1. **Unit tests:** бизнес-логика
2. **Integration tests:** API, offline-sync
3. **UI tests:** корректность отображения и поведения
4. **E2E tests:** пользовательские сценарии

Для AI:

* строгая проверка **hard rule compliance**
* проверка fallback и ошибок
* проверка глубины предложенного плана

После тестирования — отчёт QA → фиксы.

---

# 8. Шаг 6. Release (выкатка)

Варианты релизов:

### Release channels:

* **Internal** (только команда)
* **Closed Beta** (TestFlight / Google Internal)
* **Staged Rollout** (1% → 10% → 50% → 100%)

### Требования перед релизом:

1. Все критерии DoD выполнены
2. Пройдена регрессия по основным модулям
3. Crash-free rate ≥ 99.5% на staging
4. API backward-compatible
5. Чек-лист релиза заполнен PM

---

# 9. Шаг 7. Monitoring (наблюдение после релиза)

Особенно критично для:

* изменений данных (миграции),
* AI-поведения,
* планировщика задач,
* подключения подписок.

### Мониторим:

* Crash-free %
* Ошибки API
* AI rule violation rate
* Drop-offs в новых фичах
* Метрики активации
* Метрики монетизации
* Баг-репорты от пользователей

Если критические ошибки → включаем **Emergency Hotfix Process**.

---

# 10. Emergency Hotfix Process

1. QA подтверждает баг как **Critical**
2. PM/Tech Lead принимают решение → "hotfix required"
3. Создаётся ветка hotfix/xxx
4. Быстрая реализация (≤ 24 часов)
5. Минимальный набор тестов + smoke
6. Выкатка в прод аккуратно (100% или staged)
7. Постморем до 48 часов после фикса

Когда используется:

* приложение не открывается
* AI генерирует опасные/ошибочные планы
* потеря данных задач/финансов
* краши > 1% в проде
* сломанные подписки

---

# 11. Управление версиями продукта

Mobile semantic versioning:

```
MAJOR.MINOR.PATCH (пример: 1.3.2)
```

* MAJOR = крупные изменения (например, Planner v2, новые модули)
* MINOR = новые фичи MVP уровня
* PATCH = багфиксы

Backend versioning:

```
/api/v1/*
/api/v2/* (когда ломаем контракты)
```

AI versioning:

* каждая модель имеет **версию**, хранящуюся в конфиге backend:

  ```
  planner_model_version: "1.2.0"
  ```

---

# 12. Change Control Board (CCB)

Мини-группа, которая принимает решения по крупным изменениям:

### Участники:

* CEO / Founder
* PM
* CTO / Tech Lead
* AI Lead
* Design Lead

Обрабатываемые вопросы:

* крупные фичи roadmap
* изменения бизнес-модели
* рискованные изменения структуры данных
* внедрение Autonomy Mode

---

# 13. Change Risk Matrix

| Тип изменения       | Риск          | Действия                                |
| ------------------- | ------------- | --------------------------------------- |
| UI/UX change        | низкий        | обычный CR процесс                      |
| Feature change      | средний       | CR + тестирование                       |
| Data model change   | высокий       | CCB approval + миграции + staging тесты |
| AI logic change     | очень высокий | feature flag + A/B тест + rollback      |
| Offline sync change | критический   | нагрузочные тесты + E2E + fallback      |

---

# 14. Templates

## 14.1. Change Request Template

```
Title: 
Category: Feature / UI / Tech / Data / Hotfix
Summary:
Problem:
Goal:
User Value:
Technical Impact:
Affected Modules:
Risks:
API Changes:
Migration Needed: Yes/No
Estimated Effort:
Dependencies:
Metrics Affected:
Design Link:
Attachments:
```

## 14.2. Release Checklist Template

```
☐ Все DoD выполнены
☐ Пройдена регрессия
☐ Crash-free ≥ 99.5% на staging
☐ API backwards-compatible
☐ Подписки проверены (Trial, Pro)
☐ AI Planner протестирован
☐ Offline-сценарии проверены
☐ В changelog добавлены изменения
☐ Мониторинг настроен
```

---

# 15. Главные принципы управления изменениями в LifeMerge

1. **Ни одно изменение не должно ухудшать качество планирования.**
2. **AI всегда должен быть под контролем пользователя.**
3. **Структура данных — священная часть системы; менять её — только думая о миграциях.**
4. **Изменения должны улучшать метрики, а не только функциональность.**
5. **Любое изменение может быть отменено (roll back).**
6. **Feature flags — обязательны для AI и крупных модулей.**
7. **Документация обновляется всегда.**

========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/Metrics/Alerts_And_Thresholds.md
========================================

# Alerts & Thresholds

- **Crash-free mobile < 98%** за 24 часа → блокируем выкаты, приоритетный фикс.
- **Error rate API > 5%** на ключевых эндпоинтах (/tasks,/calendar,/finance) за 5 минут → page on-call.
- **Активация A1 < 60%** за неделю → проверка онбординга и аналитики.
- **D7 retention < 30%** → анализ когорт и причин оттока.
- **AI planner failure rate > 10%** или время ответа > 5 сек → переключение на fallback/ограничение трафика.
- **Скорость синхронизации > 5 сек** для 90 перцентиля → расследование очередей/сети.


========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/Metrics/Dashboards_Structure.md
========================================

# Структура дашбордов

1. **Product Health**
   - MAU/WAU/DAU, активация A1/A2, D1/D7/D30 retention.
   - Функциональное использование: % пользователей с задачами, событиями, финансами.
2. **Acquisition & Funnel**
   - Источники трафика, конверсии онбординга, время до первого value.
3. **Module Dashboards**
   - Tasks/Goals: создано/выполнено, активные цели, прогресс целей.
   - Calendar: события по источникам, конфликтные синхронизации.
   - Finance: транзакции по типам, бюджеты, ARPU (для Pro, если появится).
4. **AI Quality**
   - Успех планов, время ответа, ручные правки, жалобы.
5. **Reliability**
   - Crash-free, error rate, latency p95, нагрузка на очереди.


========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/Metrics/Events_Specification.md
========================================

North Star Metric – WPAR (Weekly Planning Activity Rate): доля активных пользователей за неделю, которые составили интегрированный план – связали задачу с событием календаря и целью.
Формула: WPAR = (число пользователей с ≥1 связкой «задача+событие+цель» за неделю) / (общее число Weekly Active Users) × 100%.
Обоснование: этот показатель отражает основную ценность продукта – активное еженедельное планирование. Чем выше WPAR, тем больше пользователей полноценно используют приложение для планирования времени, задач и целей, что коррелирует с долгосрочным удержанием.

Удержание на 7-й день (Retention D7): процент новых пользователей, которые возвращаются в приложение через 7 дней после регистрации. Используется для оценки удержания аудитории; целевой уровень – >30% возвращений на 7-й день. <br/>События: отслеживается по повторным визитам пользователя (например, событие App_Open на 7-й день после Signup).

Task-to-Calendar Attachment Rate: доля задач, которые были привязаны к событиям календаря. Формула: (задачи, добавленные в календарь) / (все созданные задачи) × 100%. Показатель демонстрирует, насколько активно пользователи планируют задачи во времени (в календаре). Стремимся повышать этот процент, так как привязка задач к расписанию свидетельствует о глубоком использовании продукта. <br/>События: отслеживается по событиям Task_Created и Task_Scheduled (сколько задач создано и сколько из них размещено на календаре).

Конверсия онбординга и настройки календаря: доля новых пользователей, которые завершили онбординг и создали первую задачу/событие (A1), а также подключили календарь (настроили расписание, этап A2) после регистрации. Важный показатель активации новых пользователей; целевой уровень A1-конверсии – >70%, при времени до достижения A1 < 5 минут. <br/>События: фиксируется событиями Onboarding_Complete (успешное прохождение onboarding) и Calendar_Connected (подключение внешнего календаря) у каждого нового пользователя.

Events_Specification.md
Ключевые продуктовые события (MVP)
event_name	category	trigger_point (когда фиксируется)	parameters (основные)	used_in_dashboards	notes
User_SignUp	Регистрация	Пользователь успешно зарегистрировался (создан аккаунт)	method (тип регистрации),
source (источник трафика)	Воронка активации (Amplitude)	Логируется один раз на пользователя.
Onboarding_Complete	Онбординг	Завершение всех шагов onboarding-процесса	duration (время прохождения, сек)	Воронка онбординга (Amplitude)	Соответствует достижению A1 (частично).
Task_Created	Задачи	Создание новой задачи пользователем	task_id, via (manual/AI)	Product usage (Amplitude, задачи)	Первое создание задачи используется для метрики A1.
Task_Completed	Задачи	Отметка задачи как выполненной	task_id, completion_time	Engagement (Amplitude, активность)	Используется для расчета активных пользователей (≥3 выполненных задач/неделя).
Calendar_Connected	Интеграция календаря	Подключение внешнего календаря (Google/Exchange и т.д.)	calendar_type (например, Google)	Активация A2 (Amplitude), использование	Пользователь настроил синхронизацию расписания.
Task_Scheduled	Задачи/Календарь	Привязка задачи к слоту в календаре (планирование задачи)	task_id, event_id	Feature usage (Amplitude, связь задач-календарь)	Отслеживается для метрики привязки задач к календарю.
Goal_Created	Цели	Создание новой цели пользователем	goal_type (категория/область)	Активация A2 (Amplitude), использование	Логируется при добавлении цели (альтернатива A2, если не подключён календарь).
AI_Planner_Used	AI Planner	Запуск пользователем AI-планировщика задач	tasks_scheduled (число задач в плане)	Feature usage (Amplitude, AI)	Повторное использование показывает ценность AI-планирования.
Finance_Transaction_Added	Финансы	Добавление новой финансовой транзакции	amount, category	Finance module usage (Amplitude)	Показывает вовлечённость в модуль финансов.
Finance_Initialized	Финансы	Завершение начальной настройки финансов (категории/бюджет)	categories_count	Product usage (Amplitude, Finance)	Пользователь начал использовать финансы (заполнил категории расходов).

Формат именования событий: [object]_[action] в UpperCamelCase через underscore. Например: User_SignUp (регистрация пользователя), Task_Completed (выполнение задачи), Calendar_Connected (интеграция календаря). Имена отражают сущность и совершенное действие.

Общие требования к логированию:

Каждое продуктовое событие должно логироваться одновременно в Firebase и Amplitude (дублировать события в обе системы для консистентности данных).

Логируются только значимые действия пользователя: необходимо минимизировать технический шум (не отправлять события о внутренних вызовах, рендерах UI и т.п.).

Вся логика отправки событий должна быть тщательно протестирована: проверяем, что события срабатывают единожды в нужный момент, содержат корректные параметры, и не дублируются. Желательно использовать sandbox/тестовые окружения и debug-режимы аналитики для проверки.

Структура дашбордов MVP на старте

Amplitude (продуктовая аналитика):
– Воронки по ключевым сценариям (регистрация → онбординг → A1/A2) для анализа конверсий.
– Retention: показатели удержания D1, D7, D30 (когортный анализ возвращаемости пользователей).
– North Star Metric: трекинг динамики WPAR по неделям.
– Использование функций: доля пользователей, использующих задачи, календарь, цели, финансы (активность по модулям).
– Отток на онбординге: выявление шагов онбординга с наибольшим отсевом (падение конверсии между этапами).

Firebase (качество и технические метрики):
– Crash-free sessions: процент сессий без сбоев (стабильность приложения).
– Статистика устройств: версия приложения, ОС, модель устройства (для отслеживания технических характеристик аудитории).
– Error rate: уровень ошибок (HTTP 5xx, сбои) на бэкенде и в приложении.
– Доставка push-уведомлений: метрики отправки и открытия push (сколько push доставлено и сколько из них открыто пользователями).

Metabase (бизнес-показатели, при необходимости):
– ARPU (Average Revenue Per User) – средний доход на пользователя (если в MVP предусмотрены платные функции).
– Trial‑to‑Pro конверсия – процент пользователей, перешедших с пробной версии на платную (при наличии подписки).
– LTV (Lifetime Value) – пожизненная ценность пользователя, на основе данных о доходах и удержании.
– Дополнительные аналитические запросы (SQL) для глубокой сегментации и анализа использования, которые не покрываются стандартными дашбордами.

========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/Metrics/Metrics_Plan.md
========================================

# Metrics Plan (MVP)

## North Star
- «Планирование, выполняемое пользователями»: доля активных, у которых есть связка задачи+событие+цель за неделю.

## Активация
- A1: завершён онбординг и создана первая задача/событие.
- A2: подключён календарь или создана цель.
- Время до A1 < 5 минут, конверсия онбординга >70%.

## Удержание
- D1/D7/D30 retention.
- Weekly Active with ≥3 выполненными задачами.
- Повторное использование AI-планировщика.

## Модульные метрики
- Календарь: % пользователей с ≥1 событием в неделю, синхронизация без конфликтов.
- Задачи/цели: среднее количество задач в день, прогресс целей.
- Финансы: MAU модуля, доля пользователей с заполненными категориями и ≥5 транзакциями/месяц.

## Качество
- Crash-free mobile >98%.
- Ошибки API (5xx) <1%.
- SLA синхронизации офлайн очереди <5 сек.

## North Star Metric – WPAR (Weekly Planning Activity Rate):
доля активных пользователей за неделю, которые составили интегрированный план – связали задачу с событием календаря и целью.
Формула: WPAR = (число пользователей с ≥1 связкой «задача+событие+цель» за неделю) / (общее число Weekly Active Users) × 100%.
Обоснование: этот показатель отражает основную ценность продукта – активное еженедельное планирование. Чем выше WPAR, тем больше пользователей полноценно используют приложение для планирования времени, задач и целей, что коррелирует с долгосрочным удержанием.

## Удержание на 7-й день (Retention D7): процент новых пользователей, которые возвращаются в приложение через 7 дней после регистрации. 
Используется для оценки удержания аудитории; целевой уровень – >30% возвращений на 7-й день. <br/>События: отслеживается по повторным визитам пользователя (например, событие App_Open на 7-й день после Signup).

## Task-to-Calendar Attachment Rate:
доля задач, которые были привязаны к событиям календаря. Формула: (задачи, добавленные в календарь) / (все созданные задачи) × 100%. Показатель демонстрирует, насколько активно пользователи планируют задачи во времени (в календаре). Стремимся повышать этот процент, так как привязка задач к расписанию свидетельствует о глубоком использовании продукта. <br/>События: отслеживается по событиям Task_Created и Task_Scheduled (сколько задач создано и сколько из них размещено на календаре).

## Конверсия онбординга и настройки календаря: 
доля новых пользователей, которые завершили онбординг и создали первую задачу/событие (A1), а также подключили календарь (настроили расписание, этап A2) после регистрации. Важный показатель активации новых пользователей; целевой уровень A1-конверсии – >70%, при времени до достижения A1 < 5 минут. <br/>События: фиксируется событиями Onboarding_Complete (успешное прохождение onboarding) и Calendar_Connected (подключение внешнего календаря) у каждого нового пользователя.


========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/MVP_Scope_v1.md
========================================

Регистрация и онбординг

Входящие модули и фичи: Регистрация нового аккаунта по email + паролю, вход и восстановление пароля, а также первичный онбординг пользователя. Онбординг реализован в виде мастера из ~3–5 экранов: краткое представление ценности продукта, настройка параметров (например, выбор рабочего графика 5/2, 2/2, 3/3 или кастомного расписания) и предложение активировать бесплатный Trial Pro-подписки.

Статус реализации: Входит в MVP. Все перечисленные возможности (создание учётной записи, авторизация, сброс пароля, онбординг и базовая пробная подписка) реализованы в мобильном приложении.

Пользовательская ценность: Обеспечивает быстрый старт работы с приложением. Пользователь получает защищённый доступ к своим данным и синхронизацию между устройствами, знакомится с основными возможностями LifeMerge и настраивает приложение под свой образ жизни (например, график работы) для персонализированного опыта.

Зависимости: Модуль аутентификации (для управления аккаунтами и токенами), модуль профиля/настроек (сохранение рабочего графика, часового пояса и предпочтений), интеграция с системой подписок (для активации Trial). Онбординг взаимодействует с календарём (применяет выбранный рабочий график к расписанию пользователя).

Сценарии использования: 1) Новый пользователь устанавливает приложение, регистрируется через email и пароль, после чего проходит серию экранов онбординга – узнаёт о возможностях приложения, выбирает свой рабочий график, и на финальном шаге при желании активирует Trial Pro-функций. 2) Возвращающийся пользователь входит в аккаунт и видит синхронизированные данные (ранее созданные задачи, события, цели) сразу после авторизации.

Планирование задач и целей

Входящие модули и фичи: Модуль задач (Task Manager) и модуль целей/проектов. Пользователь может создавать, редактировать и удалять задачи; указывать для них приоритет, дедлайн, контекст и статус выполнения. Поддерживаются подзадачи и повторяющиеся задачи. Задачи можно связывать с целями/проектами – для этого реализован модуль целей, позволяющий создавать цели в разных сферах жизни и отслеживать прогресс их достижения. Отображается процент выполнения цели на основе выполненных связанных задач. Также реализована базовая фильтрация и организация задач по проектам.

Статус реализации: Входит в MVP. Базовый функционал задач и целей реализован полностью в мобильном приложении. (Продвинутые возможности управления проектами, такие как совместная работа или подробная аналитика по целям, в MVP не входят.)

Пользовательская ценность: Позволяет пользователю управлять своими делами и долгосрочными целями в одном месте. Задачи привязаны к конкретным целям, что даёт понимание, как ежедневные действия приближают пользователя к его целям. Пользователь получает инструмент планирования по методологии GTD: можно разгружать голову, фиксируя задачи, и быть уверенным, что ничего не потеряется.

Зависимости: Связка с модулем календаря (задачи могут отображаться в расписании, если назначены на слот времени), с модулем уведомлений (напоминания о дедлайнах задач), с модулем аналитики (отображение прогресса по целям), а также с inbox/входящими (идея из инбокса может быть преобразована в задачу или цель). Работает в связке с офлайн-системой (создание и изменение задач/целей офлайн с последующей синхронизацией).

Сценарии использования: 1) Создание задачи и цели: пользователь добавляет новую цель (например, “Подготовиться к сертификации”), затем создаёт несколько задач внутри этой цели. Он указывает дедлайны и приоритеты, после чего видит прогресс выполнения цели (например, 0% выполнено, позже процент растёт по мере закрытия задач). 2) Управление задачами: пользователь просматривает список задач на день, отмечает некоторые из них выполненными, изменяет приоритет других. Если задача становится нерелевантной – удаляет или переносит дедлайн. Все изменения синхронизируются и при необходимости будут отражены в календаре и общей статистике целей.

Управление календарём

Входящие модули и фичи: Календарный модуль – центральный элемент приложения. Реализованы основные представления календаря: режим “День” и “Неделя” (интерактивный таймлайн) для обзора расписания. Пользователь может создавать события в календаре (с указанием названия, времени начала, длительности/конца, а также опционально места и типа события) и редактировать их. Поддерживаются повторяющиеся события (например, еженедельные встречи) и параллельные события на одно время (учёт случаев многозадачности). Предусмотрен Drag & Drop – возможность перетаскивать события и задачи по календарю для быстрого изменения времени. В календаре автоматически отображается выбранный при онбординге рабочий график (смены) – рабочие дни и выходные визуально различаются. Также учитывается время на дорогу между событиями (заложены промежутки) и конфликты по времени (приложение предупредит, если события пересекаются). Задачи из списка задач можно привязывать к временны́м слотам календаря, превращая их в запланированные активности на день.

Статус реализации: Входит в MVP. Основные функции (день/неделя, события, повторения, перемещение, отображение сменного графика) реализованы. Просмотр месяца как целого календарного сетка не реализован полноценно в MVP (может быть добавлен в будущих версиях). Синхронизация с внешними календарями (Google/Apple) не выполняется в рамках MVP, фокус сделан на собственном календаре приложения.

Пользовательская ценность: Позволяет пользователю видеть полную картину своего времени и планировать дни и недели с учётом всех активностей. Календарь интегрирован с задачами и финансами, поэтому в одном месте отображаются и события (встречи, тренировки, рабочие смены) и запланированные задачи, и даже важные финансовые транзакции (например, день зарплаты). Это обеспечивает целостное управление временем. Гибкость календаря (поддержка нестандартных графиков, параллельных задач) помогает адаптировать планировщик под реальную жизнь пользователя.

Зависимости: Интеграция с модулем задач/целей (задачи добавляются в календарь), с модулем финансов (календарь может отображать финансовые события, привязанные к датам, такие как регулярные платежи или поступления), с уведомлениями (напоминания о наступлении событий). Зависит от настроек пользователя (рабочий график, часовой пояс) и от модуля офлайн-синхронизации, чтобы изменения в расписании не терялись без сети.

Сценарии использования: 1) Планирование недели: пользователь открывает вид “Неделя” и видит рабочие дни и выходные. Он перетаскивает 3 задачи из списка на свободные окна во вторник и четверг, создаёт событие “Встреча с клиентом” в среду 15:00, дублирует его на каждую неделю (повторение), и убеждается, что в календаре не осталось конфликтов. 2) Ежедневный просмотр: утром пользователь переключается в режим “День” и просматривает текущий день – отмечены рабочие часы согласно графику, запланированы две задачи (например, с 10:00 до 11:00 и с 17:00 до 18:00) и одно событие в обед. Приложение напомнит уведомлением за выбранное время до начала каждой активности.

Финансы

Входящие модули и фичи: Финансовый модуль для базового учёта личных финансов. Пользователь может добавлять транзакции доходов и расходов с указанием суммы, категории и даты. Поддерживаются регулярные операции (например, ежемесячная зарплата или аренда) для автоматического добавления в бюджет. Имеется справочник категорий расходов и доходов, адаптированных под СНГ. Реализован дашборд “Месяц” – агрегированная сводка финансов за текущий месяц: общая сумма доходов, расходов и расчёт баланса; прогресс исполнения бюджета. Пользователь может устанавливать простые бюджетные ограничения (например, лимит расходов на месяц) и видеть прогноз до конца месяца с учётом регулярных транзакций.

Статус реализации: Входит в MVP (базовая версия). Основной функционал учёта финансов реализован: ручной ввод транзакций, категории, повторяющиеся платежи, просмотр статистики за месяц. Расширенные возможности (например, несколько счетов, детальная аналитика по категориям за период, интеграции с банковскими API для авто-импорта) – не включены в MVP.

Пользовательская ценность: Позволяет пользователю отслеживать свои финансы в том же приложении, где он планирует время и задачи. Благодаря этому он видит целостную картину ресурсов: куда уходит не только время, но и деньги. Это повышает осознанность расходов и помогает планировать бюджеты. Связка с календарём даёт понимание, когда ожидаются крупные траты или поступления (например, приложение может отобразить день зарплаты в календаре). В результате пользователь лучше контролирует финансовые цели (накопления, сокращение долгов и т.п.).

Зависимости: Модуль категорий (для классификации транзакций), модуль календаря (отображение финансовых событий – для регулярных платежей, дат зарплаты и т.д.), модуль уведомлений (напоминания о предстоящих платежах). Зависит от системы синхронизации (чтобы данные о транзакциях были доступны офлайн и синкались при восстановлении сети). Также связан с аналитикой приложения – финансовые данные могут влиять на AI-аналитику и подсказки в будущем.

Сценарии использования: 1) Учёт расходов: пользователь после каждой покупки открывает раздел “Финансы” и добавляет расход – например, 500₽ в категории “Продукты” сегодня. В течение месяца он вносит доход (зарплата) и десятки расходов. На экране дашборда он видит, что, например, за текущий месяц потрачено 20,000₽ из бюджета 30,000₽ (оставшийся лимит 10,000₽). 2) Регулярные платежи: пользователь задаёт регулярный расход “Абонемент в спортзал 1000₽ каждый месяц 1-го числа”. Приложение автоматически добавляет такую транзакцию в начале нового месяца и может отобразить событие в календаре 1-го числа с пометкой, что будет списание. Пользователь получает уведомление в этот день и не забывает заложить нужную сумму.

GTD Inbox (Входящие)

Входящие модули и фичи: Модуль Inbox для сбора входящей информации и идей по принципу GTD. Пользователь в любой момент может быстро зафиксировать новую мысль, задачу или напоминание в виде элемента “Inbox” (минимум полей – например, только текст заметки). Далее предусмотрена обработка входящих: элемент из Inbox можно преобразовать в задачу, событие календаря или цель одним нажатием, когда пользователь разбирает накопившиеся записи. Inbox поддерживает базовый список уведомлений из разных модулей (например, непрочитанные напоминания также могут попадать во входящие для обзора). Присутствует функционал последовательной обработки: пользователю предлагается просмотреть каждый элемент inbox и решить, во что его конвертировать или удалить, что соответствует GTD-практикам “разбора входящих”.

Статус реализации: Входит в MVP. Реализованы создание элементов Inbox, их хранение локально и на сервере, а также конвертация входящего элемента в запись другого модуля (задачу, событие календаря или цель). Дополнительные AI-подсказки для автоматической категоризации или рекомендации действий (заявленные в Pro-версии) – не входят в функционал MVP.

Пользовательская ценность: Позволяет оперативно фиксировать любые мысли или задачи, не заботясь сразу о их месте в структуре. Пользователь освобождает голову, зная, что ничего не потеряется: всё незакреплённое временно складируется во входящих. Затем, в удобное время, он обрабатывает Inbox и раскладывает элементы “по своим местам” – планирует как задачу, добавляет в календарь или относит к какой-то цели. Это повышает продуктивность и снижает стресс от необходимости держать всё в памяти.

Зависимости: Тесно интегрирован с модулями задач, календаря и целей (так как преобразование создаёт объекты в этих модулях). Связан с уведомлениями (например, пропущенное уведомление может сохраниться во входящих для внимания пользователя) и с AI-модулем (в будущем – для умных подсказок классификации, которые в MVP отключены). Зависит от офлайн-режима: записи Inbox можно делать без сети, они синхронизируются позже.

Сценарии использования: 1) Быстрая запись идеи: пользователь по пути на работу открывает Inbox и быстро печатает заметку “Купить подарок на др\n рождения мамы”. Пока он занят, эта запись просто хранится во входящих. Вечером он открывает приложение, заходит в Inbox и конвертирует эту заметку в задачу с дедлайном на нужную дату. 2) Обработка входящих: пользователь раз в день открывает Inbox, где накопилось, скажем, 5 элементов (заметки, идеи). Он последовательно проходит по каждому: какие-то сразу удаляет как неактуальные, какие-то превращает в задачи, назначая им дату, а один элемент преобразует в событие календаря. В итоге Inbox очищается, все дела разнесены по своим категориям.

AI-планировщик

Входящие модули и фичи: Модуль AI Planner – интеллектуальный помощник для планирования расписания. На этапе MVP доступен ограниченно и только для Pro-пользователей (либо на период Trial). Функциональность: пользователь может запросить у AI-сервиса сформировать оптимальное недельное расписание на основе текущих задач, событий календаря и предпочтений. Первая версия AI-планировщика учитывает базовые правила: не планировать задачи на позднюю ночь, соблюдение выходных дней, добавление буферов между событиями. AI анализирует список невыполненных задач пользователя, их приоритеты, длительности, а также занятость календаря, после чего предлагает расписание – распределяет задачи по свободным слотам недели с учётом указанных ограничений. Результат планирования показывается пользователю в виде черновика расписания, пользователь может внести правки и подтвердить план, после чего задачи расставляются в календаре. Также AI может предоставить текстовые инсайты – например, краткое объяснение, почему выбрано такое расписание, или советы по продуктивности.

Статус реализации: Частично входит в MVP. Первая версия AI-планировщика реализована и работает через внешний AI-сервис (LLM API). Однако функциональность доступна только в платной версии (ограничение тарифа Free). Бесплатные пользователи увидят заглушку с предложением попробовать Trial. Продвинутые функции AI (учёт энергии пользователя, голосовые команды, полностью автономное планирование и т.д.) находятся за рамками MVP.

Пользовательская ценность: Предоставляет уникальное преимущество приложения – экономит время пользователя на ручное планирование. AI выступает как “умный ассистент”, который на основе данных о задачах и расписании генерирует оптимальный план недели. Пользователь получает персональные рекомендации – когда лучше выполнить ту или иную задачу, как сбалансировать работу и отдых. В итоге повышается продуктивность: меньше прокрастинации и забытых дел, более равномерная нагрузка в течение недели. Даже в первой ограниченной версии AIPlanner помогает пользователю увидеть возможный план и снять с него часть когнитивной нагрузки по распределению задач.

Зависимости: Глубоко интегрирован с модулями задач, календаря и целей – AI берёт входные данные из них. Зависит от backend AI-сервиса (вычисления плана происходят на стороне сервера/модели). Требует актуальной информации о предпочтениях пользователя (рабочие часы, выходные, личные запретные временные окна – эти настройки берутся из профиля). После составления плана создаёт события в календаре (через backend API). Также связан с модулем уведомлений (например, может присылать уведомление “Новый AI-план готов”) и с модулем подписки (чтобы проверять доступность функции для данного пользователя).

Сценарии использования: 1) Запуск недельного планирования: в воскресенье вечером пользователь нажимает “Спланировать неделю (AI)”. Приложение показывает индикатор, затем отображает предварительное расписание: все несделанные задачи распределены по дням предстоящей недели с учётом его уже запланированных встреч. Пользователь видит, что, например, в понедельник AI поставил 3 задачи высокой приоритетности утром, а вечер оставил свободным для отдыха. Он принимает план, и задачи автоматически занимают слоты в календаре. 2) Частичный ре-план: в середине недели пользователь выполнил не все задачи за понедельник. Он удаляет пропущенные задачи из календаря и снова обращается к AI с запросом перепланировать оставшиеся на оставшиеся дни. AI пересчитывает и предлагает скорректированный план, который пользователь редактирует (например, убирает задачу с четверга) и сохраняет.

Уведомления

Входящие модули и фичи: Модуль уведомлений отвечает за отправку push-уведомлений пользователю о важных событиях и задачах. Реализованы напоминания о событиях календаря и дедлайнах задач – с настраиваемым временем упреждения (например, за 10 минут до события, за 1 день до дедлайна задачи). Также предусмотрены уведомления о финансовых событиях (например, напоминание “сегодня день оплаты счета” на основе регулярной транзакции). Пользователь может управлять категориями уведомлений – например, отключить пуши о финансах, но оставить о задачах. Помимо точечных напоминаний, реализован ежедневный и еженедельный дайджест: утром приложение может прислать краткий обзор дня (сколько дел запланировано, ближайшие события, прогноз погоды – при интеграции, и т.п.), а в конце недели – сводку выполненных задач, прогресса по целям и финансового баланса. (Дайджесты настраиваемые, их можно выключить.)

Статус реализации: Входит в MVP. Базовые пуш-уведомления реализованы через сервисы FCM/APNs. Настройка времени и типа напоминаний доступна в приложении. Отправка дайджест-уведомлений реализована ограниченно (например, только текстом, без сложной инфографики). Внешние интеграции (например, погодные уведомления или email-рассылки) не используются в MVP.

Пользовательская ценность: Помогает пользователю ничего не пропустить – приложение своевременно напоминает о запланированных событиях и дедлайнах, тем самым повышая надёжность ведения дел в LifeMerge. Дайджесты позволяют оглянуться на прогресс: сколько всего сделано за день/неделю, что потрачено, чего достигли – это мотивирует продолжать использование и улучшает осознанность пользователя о своих достижениях и планах. Уведомления делают приложение более “живым” и полезным в ежедневной рутине без необходимости постоянно его открывать.

Зависимости: Интеграция с модулями задач, календаря и финансов – эти модули предоставляют события, по которым нужно отправлять уведомления (время начала события, срок задачи или дата платежа). Зависит от системных сервисов уведомлений (Firebase Cloud Messaging для Android, Apple Push Notification service для iOS). Связан с настройками профиля (пользовательские предпочтения по уведомлениям, временные окна “Do not Disturb”). Также зависит от точности данных календаря/задач: если задача не имеет дедлайна, уведомление не сформируется.

Сценарии использования: 1) Напоминание о событии: за 15 минут до начала встречи, добавленной в календарь, пользователь получает push на телефон: “⚡️ Встреча с клиентом в 14:00 (через 15 мин)”. Благодаря этому он успевает подготовиться и не пропускает событие. 2) Еженедельный отчёт: в воскресенье вечером приложение присылает уведомление: “Ваш прогресс за неделю: выполнено 12 задач, достигнут прогресс в 2 целях, баланс финансов +5% от плана. На следующей неделе – 3 задачи запланированы. Отличная работа! ✨”. Пользователь открывает приложение, чтобы подробнее посмотреть аналитику, вдохновлён результатами.

Оффлайн-режим и синхронизация

Входящие модули и фичи: Поддержка полнофункциональной работы приложения офлайн. Реализована локальная база данных (SQLite через пакет sqflite) для хранения всех основных сущностей: задачи, события календаря, цели, финансовые транзакции, а также специальная очередь операций для синхронизации. При отсутствии интернет-соединения все изменения, вносимые пользователем (создание или редактирование задач, событий, целей, финансовых записей), сохраняются локально и ставятся в очередь. Как только связь восстановится, приложение автоматически отправит накопленные операции на сервер. Реализован механизм разрешения конфликтов: у каждой записи есть метка updated_at, при синхронизации возможен детект конфликтов (например, запись была изменена на другом устройстве) – тогда сервер вернёт ошибку, и клиент покажет пользователю уведомление или выполнит стратегию слияния изменений. В UI приложения предусмотрен индикатор состояния синхронизации (например, значок офлайн-режима или баннер “Соединение потеряно/восстановлено”). Также все просмотренные данные кэшируются, чтобы были доступны без сети в режиме Read-Only.

Статус реализации: Входит в MVP. Офлайн-режим поддерживается для всех основных сценариев: создание/редактирование задач, событий, целей и финансовых записей без интернета – с последующим автоматическим sync. Покрыт базовый случай конфликтов (последний updated_at побеждает). Ограничения: в MVP синхронизация происходит сразу при появлении сети или вручную по открытию приложения; более тонкая настройка (например, выбор только Wi-Fi для sync) не реализована.

Пользовательская ценность: Даёт уверенность, что приложение доступно в любое время и в любом месте, даже без подключения к интернету. Пользователь может, к примеру, в самолёте или в метро продолжать работать: добавлять задачи, отмечать выполненное, смотреть календарь. Все изменения надёжно сохраняются локально и не будут потеряны. Это особенно важно для планировщика, претендующего на роль “операционной системы жизни” – он должен быть надёжным и автономным. Офлайн-синхронизация повышает доверие: пользователь знает, что данные синхронизируются корректно, даже если связь прерывалась.

Зависимости: Зависит от модулей хранения данных на устройстве (локальная БД, шифрование хранилища для чувствительных данных). Тесно связан с backend API – все операции повторяются на сервере, когда появляется связь. Требует поддержки в каждом функциональном модуле: задачи, календарь, финансы и т.д. должны правильно ставить операции в очередь. Также интегрирован с модулем уведомлений: при длительном офлайне может быть показан баннер о режиме офлайн. Безопасность: учитывается ограничение на количество офлайн-сессий (до 3 активных устройств на аккаунт).

Сценарии использования: 1) Создание задачи без сети: пользователь находится под землёй без интернета и добавляет новую задачу в приложении. Приложение моментально сохраняет её локально и помечает значком синхронизации. Когда пользователь выйдет в сеть, задача автоматически отправится на сервер, и значок пропадёт. 2) Редактирование календаря офлайн: пользователь в отпуске, Интернет дорогой. Он вносит несколько изменений в календарь (двигает события, добавляет задачи на дни). Приложение сохраняет всё локально. Позже, подключившись к Wi-Fi, пользователь открывает приложение – оно синхронизирует все изменения за несколько секунд (батчем). Все устройства пользователя теперь обновлены с учётом этих правок.

Free vs Pro Rules (MVP)

В рамках MVP реализовано разграничение функциональности между бесплатной версией (Free) и платной подпиской (Pro). Ниже перечислены ограничения для бесплатных пользователей и соответствующие преимущества Pro:

AI-планировщик задач: Доступен только пользователям Pro-тарифа (включая Trial-период); у бесплатных аккаунтов эта функция отключена. То есть Free-пользователь не может запустить автоматическое расписание недели – в приложении ему будет предложено оформить Trial или подписку для использования AI.

Продвинутые аналитические отчёты: В бесплатной версии доступны только базовые метрики и отчёты (например, количество выполненных задач, общий прогресс целей, суммарные доходы/расходы за месяц). Расширенная аналитика и прогнозы доступны в Pro. Например, детальная статистика по времени (помесячные тренды, разбивка дня по сферам), по финансам (анализ категорий, уведомления о превышении бюджета) и по целям (вклад каждой задачи в прогресс цели) будут эксклюзивом Pro-подписки.

Финансовые счета и бюджеты: Бесплатный пользователь может вести только один счёт (кошелёк) для учёта финансов; функция добавления нескольких счетов открывается на Pro-тарифе. Также в Free доступен лишь простой месячный бюджет (общий лимит расходов на месяц). Настройка нескольких бюджетов (например, отдельные лимиты по категориям) и продвинутые финансовые функции планирования доступны в Pro.

Количество целей и задач: В бесплатном плане предусмотрены ограничения на масштаб использования. Например, можно активно вести не более 5 целей одновременно; создание большего числа целей требует перехода на Pro. По задачам ограничение может составлять 100 активных задач (попытка добавить свыше покажет уведомление о необходимой подписке). В Pro-версии ограничения на количество целей и задач сняты (можно вести неограниченно проектов и задач). Примечание: сами базовые функции создания/редактирования задач и целей есть в обеих версиях – речь идёт лишь об ограничении объёма данных.

Дополнительные функции и сервисы: Некоторые возможности, не критичные для ядра, зарезервированы за Pro. Например, шаблоны расписаний и повторяющихся задач, а также расширенные правила планирования (тонкая настройка условий, когда планировщик может назначать задачи) отнесены к Pro-тарифу. Приоритетная поддержка (более быстрый ответ службы поддержки) также доступна только Pro-подписчикам. Мультиязычность и веб-версия планируются как часть развития Pro-предложения в будущем. На этапе MVP приложение доступно на русском языке, веб-интерфейс отсутствует для всех пользователей.

Trial-период: Новый пользователь может активировать бесплатный Trial (пробный период) продолжительностью 7–14 дней. На время Trial доступны все Pro-функции (AI, расширенные отчёты и др.) в полном объёме, что позволяет оценить преимущества платного тарифа. После окончания Trial функциональность откатывается до Free, если пользователь не оформит платную подписку.

========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/Product_Vision/Competitors_Comparison.md
========================================

# Сравнение с конкурентами

| Продукт | Сильные стороны | Ограничения | Что делаем иначе |
|---------|-----------------|-------------|------------------|
| Todoist | Простота задач, кроссплатформенность | Нет финансов и календаря, AI ограничен | Единая связка задачи+календарь+финансы, локализация СНГ |
| Notion | Гибкость, базы данных | Высокий порог входа, нет готовых шаблонов календаря/финансов | Готовые сценарии, мобильный UX, автоматизация AI |
| Google Calendar | Стабильная синхронизация событий | Нет целей/задач/финансов | Добавляем управление задачами и целями поверх календаря |
| YNAB/Дзен-мани | Глубокий финучёт | Нет задач/целей/AI | Объединяем финансы с планированием времени и целей |


========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/Product_Vision/Personas/Persona_1.md
========================================

# Персона 1: Мария, 32, продакт-менеджер

- Живёт в Москве, работает в ИТ, совмещает работу, спорт, личные проекты.
- Боли: много встреч, задачи разлетаются по почте/мессенджерам, нет связки с личными финансами.
- Цели: успевать тренироваться 3 раза в неделю, закрывать квартальные OKR, копить на отпуск.
- Как помогает LifeMerge: планирует неделю с учётом встреч, видит нагрузку по дням, отслеживает расходы и бюджет, AI предлагает фокус-задачи.


========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/Product_Vision/Personas/Persona_2.md
========================================

# Персона 2: Алексей, 28, врач-ординатор

- Работает по сменам, часто меняется график, нужно планировать экзамены и личные дела.
- Боли: отсутствие единого календаря смен, забывает оплачивать счета, нет времени распределять учебные задачи.
- Цели: пройти курс повышения, сдать экзамен, контролировать расходы.
- Как помогает LifeMerge: синхронизирует смены в календаре, напоминает о платежах, предлагает слоты для учёбы и отдыха.


========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/Product_Vision/Personas/Persona_3.md
========================================

# Персона 3: Ирина, 35, предприниматель

- Управляет небольшим интернет-магазином, много задач по команде, финансам и маркетингу.
- Боли: хаос в задачах, сложность видеть кассовые разрывы, нет времени на стратегические цели.
- Цели: увеличить выручку, запустить новые продукты, держать личный баланс работы и семьи.
- Как помогает LifeMerge: объединяет задачи по проектам, показывает бюджет и прогноз расходов, AI помогает распределить время между бизнесом и семьёй.


========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/Product_Vision/Product_Vision.md
========================================

# ✅ **PRODUCT VISION — версия 1.0 для LifeMerge (рабочее название)**

*Кроссплатформенное приложение для интегрированного управления временем, целями и финансами.*

# **1. Назначение продукта (Purpose)**

LifeMerge создаётся как **операционная система жизни для молодых профессионалов 25–40 лет**, совмещающих работу, саморазвитие, личные проекты, здоровье и финансовые цели.
Основная ценность продукта:

### **«Живи осознанно. Управляй всем. Достигай большего.»**

Это не просто планировщик задач — это интегрированная среда, объединяющая:

* **время**,
* **цели**,
* **деньги**,
* **энергию**,
* **приоритеты**,
* **и прогресс пользователя в разных сферах жизни**.

---

# **2. Видение (Vision Statement)**

LifeMerge создаёт единое пространство, где человек понимает:

* что он делает,
* почему он это делает,
* сколько это стоит (во времени, энергии и деньгах),
* и как это приближает его к личным и профессиональным целям.

Приложение помогает превратить жизнь из хаотичного списка задач в **систему, работающую на долгосрочный рост**.

---

# **3. Проблема, которую решает продукт**

Пользователи 25–40 из СНГ часто сталкиваются с:

1. **Фрагментацией информации**

   * расписание в одном приложении,
   * финансы — в другом,
   * цели — в третьем,
   * заметки/идеи — в четвёртом.

Это создаёт перегрузку контекстом и отсутствие общей картины.

2. **Перегрузкой обязанностями**
   Работа, семья, здоровье, саморазвитие — всё требует внимания одновременно.

3. **Нестабильностью среды**
   Непредсказуемый график, переработки, финансовые колебания, инфляция, валютные риски.

4. **Прокрастинацией и слабой связью задач с реальными целями**
   Большинство приложений не показывают: *как ежедневные действия влияют на долгосрочные цели*.

5. **Отсутствием персонализированных рекомендаций**
   Классические планировщики не анализируют:

* энергию,
* контексты,
* сменные графики,
* финансовую нагрузку,
* временные ограничения.

LifeMerge решает всё это в единой системе.

---

# **4. Уникальное ценностное предложение (UVP)**

### **LifeMerge — первый в СНГ интегрированный планировщик, который объединяет цели, время и деньги в одном месте и использует AI как продвинутого ассистента.**

**Ключевые отличия:**

* Календарь — **центр продукта**, а не дополнение к задачам.
* Задачи автоматически связаны с целями, временем и финансовыми последствиями.
* Поддержка сложных графиков (2/2, 3/3, ночные смены).
* Финансовый слой встроен в ежедневное планирование.
* Аналитика показывает реальную взаимосвязь сфер жизни.
* AI строго следует пользовательским правилам (этика контроля).

---

# **5. Целевая аудитория**

### **Основная:**

* Возраст: **25–40**
* Регионы: страны СНГ
* Профиль:

  * молодые специалисты,
  * менеджеры,
  * IT-специалисты,
  * медики,
  * специалисты сменных профессий,
  * фрилансеры,
  * предприниматели.

### **Психографика:**

* амбициозные,
* ценят самосовершенствование,
* живут в многозадачном мире,
* стремятся к порядку, но не хотят тратить много сил на рутину,
* ищут систему, которая *понимает их жизнь*, а не просто хранит данные.

---

# **6. Ключевые функции продукта**

### **1) Календарь нового поколения**

* Гибкие рабочие графики: **5/2, 2/2, 3/3, ночные смены, пользовательские циклы**
* Учёт дороги
* Параллельные активности
* Временные блоки, связанные с целями и финансами
* Drag&drop, умная раскладка, шаблоны расписаний

### **2) Интегрированные задачи и цели**

* Задачи привязаны к целям
* Поддержка разовых, регулярных и дробимых задач
* Приоритеты, контексты, энергозатраты
* Цели → проекты → задачи → календарь → аналитика

### **3) Финансовый модуль**

* Доходы/расходы
* Регулярные платежи
* «Финансовые события» в календаре
* Прогноз бюджета
* Несколько счетов (Pro)
* Категории расходов СНГ
* Учет валют и инфляции

### **4) GTD-фреймворк**

* Входящие (Inbox)
* Обработка и превращение элементов в задачи/цели/события
* AI-подсказки в Pro-версии

### **5) AI Pro-функции**

* Умный планировщик задач
* Рекомендации по продуктивности
* Финансовая аналитика и предупреждения
* Предложения по структуре целей
* Будущий режим полуавтономного планирования

---

# **7. Продуктовая стратегия (High-level)**

### **Free — ядро системы**

* Календарь
* Базовые задачи
* Цели
* Простая финансовая учётка
* GTD и Inbox
* Базовые отчёты

### **Pro — автоматизация жизни**

* AI
* Расширенная аналитика
* Прогнозы
* Счета и бюджеты
* Шаблоны
* Расширенные правила планирования
* Приоритетная поддержка
* Мультиязычность + Web

### **Trial**

* 7–14 дней
* Активируется после привязки карты
* Демонстрация полной мощности экосистемы

---

# **8. Дизайн-принципы**

### **1) Осознанность > визуальный шум**

Минимализм, пространство, структурность.

### **2) 70% Notion + 30% Apple**

* строгая сетка, простота, модульность
* плавность, микроанимации, depth, слабые градиенты

### **3) Прозрачность логики**

Пользователь всегда понимает, *почему* AI сделал предложение.

### **4) Контроль остаётся у пользователя**

AI — помощник, а не оператор.

### **5) Данные — главный контент**

Минимум иллюстраций, максимум аналитики и смысла.

---

# **9. Ключевые метрики успеха**

### **North Star Metric (NSM):**

**Weekly Productive Engagement (WPE)**
= количество пользователей, которые в течение недели **создают задачи + планируют время + взаимодействуют с аналитикой**.

То есть не просто открывают приложение, а реально *живут в нём*.

### **Сопутствующие метрики:**

* 7- / 30-day Retention
* Количество запланированных задач в календаре
* Количество целей с привязанными задачами
* Частота использования AI-планировщика
* LTV / CAC Ratio
* Конверсия Free → Trial → Pro
* Доля пользователей, использующих 3+ сферы (время + цели + финансы)

---

# **10. Долгосрочное видение (3–5 лет)**

### **Life OS уровня СНГ**

Платформа, которая объединяет всё:

* время
* цели
* финансы
* здоровье
* energy management
* AI-планировщик
* автоматизация рутин

### **AI-агент уровня персонального помощника**

Понимает контексты, даёт советы, анализирует состояние дел, прогнозирует будущее.
Автономность — опциональна, под контролем пользователя.

### **Экосистема из мобильного, веба и десктопа**

Единый Pro-доступ на всех устройствах.


========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/Product_Vision/Value_Proposition.md
========================================

# Ценностное предложение

LifeMerge экономит время и деньги, объединяя планирование задач, целей и финансов в одном приложении. Пользователь видит, куда уходит время и бюджет, и получает AI-подсказки, как двигаться к целям.

**Ключевые выгоды:**
- Единый поток: из inbox → задачи → календарь → цели.
- Контроль ресурсов: время, энергия, деньги в одном месте.
- Умные рекомендации: AI предлагает расписание недели и советы по приоритетам.
- Офлайн и локализация под СНГ, привычные валюты.


========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/Roadmap/Roadmap_Pro_Stages.md
========================================

# Roadmap Pro (beyond MVP)

1. **Collaboration**
   - Шеринг задач/проектов, комментарии, упоминания, история изменений.
2. **Automation & Integrations**
   - Интеграции с таск-трекерами (Jira/Trello), банковскими сервисами (для автоимпорта расходов).
   - Правила: если задача просрочена → предложить слот, если бюджет превышен → уведомление.
3. **Advanced AI**
   - Голосовые команды, чат-помощник, прогноз достижимости целей, персональные эксперименты A/B.
4. **Web/Desktop**
   - Веб-версия и десктоп-клиенты, синхронизация с мобильным приложением.
5. **Монетизация**
   - Pro-подписка: расширенные отчёты, совместная работа, дополнительные интеграции.


========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/Roadmap/Roadmap_Stages.md
========================================

# 🚀 **ROADMAP (Этапы развития LifeMerge)**

**MVP → Pro 1.0 → Pro 2.0 → Autonomy Mode**

---

# 🟩 **Этап 1 — MVP (Product Foundations & Validation)**

Главная цель: **проверить ядро продукта и ценность интеграции времени, целей и финансов**.

---

## 🎯 1. Основные модули

* Календарь (день/неделя)
* Сменные графики (5/2, 2/2, 3/3)
* Inbox (GTD)
* Задачи + цели (базово)
* Финансы (базовый доход/расход + регулярные операции)
* Привязка задач/финансов к календарю

---

## 🤖 2. AI — ограниченный

* Умный планировщик задач (первая версия)
* Соблюдение базовых правил:

  * не планировать в поздние часы,
  * запретные дни,
  * буфер между задачами.

---

## 💳 3. Подписки и Trial

* Trial при привязке карты
* Тарифы Free / Pro
* Ограниченные Pro-функции: AI, выделенная аналитика

---

## 🔔 4. Уведомления

* Напоминания о событиях
* Дедлайны задач
* Финансовые события (зарплата, платежи)

---

## 📊 5. Аналитика (базовая)

* Часы задач по категориям
* Доход/расход за месяц
* Прогноз бюджета (простая модель)

---

## 🧱 6. Архитектура

* Локальный кэш + отложенная синхронизация
* Инфраструктура мультиязычности (только RU)
* Готовность к Web (responsive-компоненты)

---

## 🧪 7. Цели этапа

* Проверка product-market fit
* Измерение retention 7/30
* Оценка использования AI-планировщика
* Выявление лидирующих сценариев (календарь vs цели vs финансы)

---

---

# 🟦 **Этап 2 — Pro 1.0 (Automation & Insights Layer)**

Главная цель: **повысить ценность Pro-тарифа, усилить аналитику и автоматизацию**.

---

## 🔥 1. Расширенная аналитика

### Время:

* Разбивка дня по сферам (работа/спорт/личное)
* Почасовая продуктивность
* Недельные и месячные отчёты

### Цели:

* Динамика прогресса
* «Вклад задач» в цели
* velocity (скорость выполнения задач)

### Финансы:

* Анализ категорий
* Week-over-week spending
* Зоны риска (категории, превышающие план)

---

## ⚙️ 2. Расширенные правила планирования (Pro)

* Мягкие и жёсткие запреты (например, «после 20:00 — только лёгкие задачи»)
* Лимиты по контексту день/неделя
* Распределение задач по приоритету
* Система weighting (весовые коэффициенты для AI)

---

## 🤖 3. AI Planner 2.0

* Учет энергии (лёгкие/тяжёлые задачи)
* Учет road time (переезды)
* Улучшенные алгоритмы распределения
* Гибкое редактирование предложенного плана

---

## 🧭 4. Улучшения календаря

* Режим «Месяц» в полной версии
* Быстрые шаблоны расписания
* История изменений (undo для сессий AI)

---

## 🛠 5. Улучшения GTD

* Интеллектуальные подсказки при обработке Inbox (не авто-категоризация, а рекомендации)
* Связка Inbox ↔ Проекты

---

## 🧪 6. Цели этапа

* Рост конверсии Free → Pro
* Формирование привычки «недельного планирования»
* Увеличение времени взаимодействия с задачами/целями

---

---

# 🟧 **Этап 3 — Pro 2.0 (Life Intelligence Layer)**

Главная цель: **создать интеллектуальный слой, который соединяет цели, время и деньги в единую картину жизни**.

---

## 🔗 1. Межсферная аналитика (ключевое отличие LifeMerge)

* «Как переработки влияют на здоровье/цели/бюджет»
* «Как часто финансовые стрессоры нарушают выполнение задач»
* «Как изменения в графике влияют на выполнение проектов»

---

## 🧠 2. AI-советник (Pro)

### Продуктивность:

* рекомендации по распределению задач,
* советы по концентрации,
* анализ паттернов работы.

### Финансы:

* предупреждения о превышении бюджета,
* рекомендации по перераспределению средств,
* поиск аномалий.

### Цели:

* рекомендация структуры целей,
* выявление «мертвых зон» (цели без задач),
* автоматическое создание подключаемых «дорожных карт».

---

## 🤖 3. Smart Context Awareness

* AI учитывает контекст:

  * где находится пользователь,
  * свободные временные окна,
  * привычки дня недели.
* Пример: «У тебя окно 45 минут, доступные задачи из контекста @телефон — хочешь выбрать одну?»

---

## 📲 4. Web-версия (Pro)

* Полноценный интерфейс
* Двухпанельный режим (список + календарь)
* Отчёты + работа с AI

---

## 📊 5. Финансовые улучшения

* Поддержка нескольких счетов
* Простая интеграция с банками (ручная загрузка CSV/экспорт)
* Планирование бюджета на квартал/год
* Мультивалютность + модели инфляции

---

## 🧪 6. Цели этапа

* Повышение LTV
* Перевод Pro в категорию «незаменимого ассистента»
* Повышение accuracy AI

---

---

# 🟥 **Этап 4 — Autonomy Mode (SuperPro / AI Life OS)**

Главная цель: **частичная автономность планирования жизни под контролем пользователя**.

---

## 🤖 1. Автономный режим планирования (опциональный)

AI может автоматически:

* распределять рутинные задачи,
* оптимизировать слотирование задач под цели,
* учитывать нагрузку и баланс сфер,
* корректировать план на основе новых событий.

### Контроль:

* Пользователь всегда подтверждает авто-изменения.
* Есть «история решений» AI.

---

## 🔄 2. Self-Adjusting Policy Engine

Алгоритмы, автоматически адаптирующиеся под паттерны пользователя:

* когда он наиболее продуктивен,
* когда он чаще переносит задачи,
* когда он тратит больше денег,
* как меняется энергия в течение недели.

AI подстраивает:

* буферы,
* время для тяжёлых задач,
* бюджеты,
* нагрузки по сферам.

---

## 🌐 3. Полная интеграция с экосистемами Apple/Google

* HealthKit / Google Fit для энергии и сна
* Calendar API для внешних событий
* Shortcuts / Automations
* Умные виджеты на iOS/Android

---

## 💸 4. Финансовая автономность

* автоматическая категоризация транзакций (где разрешено)
* прогнозы на основе ML
* предупреждения о рисках по целям («не уложитесь в бюджет проекта»)

---

## 🧠 5. LifeMerge Genome (личная модель пользователя)

LLM-ориентированная модель, которая знает:

* поведение,
* ритмы,
* предпочтения,
* цели,
* стиль работы,
* финансовые привычки.

Это даёт:

* гиперперсонализированные рекомендации,
* стратегическое планирование («через 6 месяцев вы достигнете X, если продолжите темп Y»).

---

## 🎯 6. Цели этапа

* Создать продукт, который работает *не вместо человека*, а *за человека*, под его контролем.
* Стать лучшим AI-Life-OS в СНГ.

---

# 📌 Сводная таблица Roadmap

| Этап              | Основные улучшения                                           | AI-уровень    | Ценность                      |
| ----------------- | ------------------------------------------------------------ | ------------- | ----------------------------- |
| **MVP**           | Календарь, задачи, финансы, базовый AI                       | Planner v1    | Проверка ядра                 |
| **Pro 1.0**       | Расширенная аналитика, правила, Planner v2                   | Context rules | Monetization power            |
| **Pro 2.0**       | Межсферная аналитика, Smart Context, Web                     | Advisor       | Жизненная система             |
| **Autonomy Mode** | Частичное авто-планирование, интеграции, персональная модель | Autonomous AI | AI-операционная система жизни |



========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/User_Stories/User_Stories_All.md
========================================

# 📘 **USER STORIES — LifeMerge MVP**

---

## 🎯 Обязательные функциональные требования MVP

- **Регистрация и онбординг:** US-REG-001…003, US-ONB-001…003. Обязательны email + пароль, восстановление через письмо, онбординг-мастер из 3–5 шагов с выбором рабочего графика и предложением Trial без привязки карты.
- **Календарь и расписание:** US-CAL-001…009. Поддержка режимов «День/Неделя», создание/редактирование/перетаскивание событий, параллельные слоты, отображение сменного графика, учёт дороги, напоминания и привязка задач.
- **Задачи, цели, проекты:** US-TASK-001…007. Создание задач с приоритетом/контекстом/дедлайном, цели/проекты, привязка задач к целям, отображение прогресса, базовая фильтрация, дробление и повторяемость задач.
- **Финансы:** US-FIN-001…005. Добавление доходов/расходов с категориями, регулярные операции, календарные связи и месячная сводка.
- **Inbox (GTD):** US-INB-001…004. Быстрый ввод, преобразование в задачу или цель, последовательная обработка.
- **AI (Pro):** US-AI-001…003. Планировщик доступен только в Pro/Trial, учитывает рабочий график и уже забронированные события, финальное расписание подтверждается пользователем.
- **Подписки и Trial:** US-SUB-001…004. Прозрачный просмотр тарифов, запуск Trial без списания, отображение статуса, понятные ограничения Free.
- **Уведомления:** US-NOT-001…003. Получение системного разрешения, напоминания о событиях/финансах/задачах с настраиваемым упреждением, возможность отключать категории.
- **Offline & синхронизация:** US-OFF-001…003. Просмотр кэша и создание/редактирование сущностей офлайн с отложенной синхронизацией и индикацией статуса.
- **Настройки и профиль:** US-SET-001…004. Изменение рабочего графика, часового пояса, уведомлений; переключение темы как пользовательская опция.

---

# 1. Регистрация, логин, онбординг

## 1.1. Регистрация аккаунта

**US-REG-001**
**Как** новый пользователь,
**я хочу** зарегистрироваться по email и паролю,
**чтобы** получить доступ к своим данным и синхронизации на всех устройствах.

**Acceptance Criteria:**

* Поля email и пароль обязательные.
* Ошибка при некорректном email.
* Ошибка при слишком коротком пароле.
* После регистрации пользователь автоматически авторизуется.

---

## 1.2. Вход в аккаунт

**US-REG-002**
Как пользователь,
я хочу войти по email и паролю,
чтобы получить доступ к своему профилю и данным.

**Acceptance Criteria:**

* Валидация формата email и минимальной длины пароля.
* Ошибка при неверных учётных данных.
* После успешного входа данные профиля и календаря синхронизируются.
* Сессия сохраняется до выхода или истечения токена.

---

## 1.3. Восстановление пароля

**US-REG-003**
Как пользователь,
я хочу восстановить пароль через email,
чтобы вернуть доступ в аккаунт.

**Acceptance Criteria:**

* Ввод email с валидацией формата.
* Отправка письма с одноразовой ссылкой или кодом.
* Установка нового пароля после перехода по ссылке.
* Сообщение об успехе или ошибке (не раскрывающее наличие аккаунта).

---

## 1.4. Первичный онбординг

**US-ONB-001**
Как новый пользователь,
я хочу пройти онбординг с кратким объяснением ценности приложения,
чтобы понять, чем LifeMerge может мне помочь.

**Acceptance Criteria:**

* Серия из 3–5 экранов с навигацией «вперёд/назад» и прогресс-баром.
* Возможность пропустить онбординг и вернуться к нему через настройки.
* Последний шаг ведёт к настройке графика и предложению Trial.

---

## 1.5. Настройка рабочего графика при онбординге

**US-ONB-002**
Как пользователь,
я хочу выбрать свой рабочий график (5/2, 2/2, 3/3, пользовательский),
чтобы календарь корректно отражал моё расписание.

**Acceptance Criteria:**

* Пресеты смен 5/2, 2/2, 3/3 + кастом со временем начала/длительностью смены.
* Предпросмотр того, как график отобразится в календаре.
* Сохранённый график влияет на все будущие дни календаря.

---

## 1.6. Предложение активировать Pro Trial

**US-ONB-003**
Как новый пользователь,
я хочу увидеть предложение активировать Pro Trial,
чтобы попробовать продвинутые функции перед покупкой.

**Acceptance Criteria:**

* Trial доступен без привязки карты (достаточно подтвердить email/аккаунт магазина).
* Есть понятное описание того, что включено в Pro.
* Пользователь может отложить активацию и вернуться через настройки/профиль.

---

# 2. Календарь и расписание

## 2.1. Просмотр календаря в режиме «День»

**US-CAL-001**
Как пользователь,
я хочу видеть свой день в виде таймлайна,
чтобы понимать, какие события меня ждут.

**Acceptance Criteria:**

* Интервалы не мельче 15 минут, доступна прокрутка по времени.
* Отображаются пересекающиеся события и время на дорогу между ними.
* Быстрый переход к текущему времени.

---

## 2.2. Просмотр календаря в режиме «Неделя»

**US-CAL-002**
Как пользователь,
я хочу видеть неделю целиком,
чтобы планировать распределение задач.

**Acceptance Criteria:**

* Неделя начинается с выбранного в настройках дня.
* События отображаются с укрупнёнными слотами и поддержкой зума.
* Есть переключение между «День» ↔ «Неделя» без потери контекста даты.

---

## 2.3. Создание события

**US-CAL-003**
Как пользователь,
я хочу создавать события в календаре,
чтобы фиксировать обязательные активности (работа, тренировки, встречи).

**Acceptance Criteria:**

* Обязательные поля: название, дата, время начала и длительность/конец.
* Можно указать локацию и категорию/тип события.
* Событие создаётся как из пустого слота, так и через кнопку «+».

---

## 2.4. Перемещение события (drag & drop)

**US-CAL-004**
Как пользователь,
я хочу перетаскивать события в календаре,
чтобы быстро изменять расписание.

**Acceptance Criteria:**

* Поддержка drag & drop в режимах «День» и «Неделя».
* При перемещении учитывается время на дорогу и предупреждение о конфликте.
* После подтверждения событие пересохраняется с новой датой/временем.

---

## 2.5. Параллельные события

**US-CAL-005**
Как пользователь,
я хочу иметь возможность создания нескольких событий в одно и то же время,
чтобы учитывать многозадачные процессы (например, аудиокурс во время уборки).

---

## 2.6. Отображение рабочего графика (смены)

**US-CAL-006**
Как пользователь,
я хочу, чтобы мой сменный график отображался в календаре автоматически,
чтобы всегда видеть рабочие и выходные дни.

**Acceptance Criteria:**

* Шаблон смены из настроек наносится на календарь на ближайшие 90 дней.
* Рабочие дни визуально отличаются от выходных.
* При обновлении графика расписание пересчитывается.

---

## 2.7. Учёт времени на дорогу

**US-CAL-007**
Как пользователь,
я хочу добавлять время дороги между событиями,
чтобы планирование было реалистичным.

**Acceptance Criteria:**

* Время на дорогу задаётся вручную или из пресетов (15/30/45/60 минут).
* В расписании отображается как отдельный слот между событиями.
* При перемещении исходных событий дорожные слоты сдвигаются.

---

## 2.8. Привязка задачи к календарю

**US-CAL-008**
Как пользователь,
я хочу привязывать задачу к конкретному времени,
чтобы планировать выполнение задач в контексте расписания.

**Acceptance Criteria:**

* Задачу можно назначить на свободный слот или на существующее событие.
* Ссылка на задачу видна в карточке события и на таймлайне.
* Из календаря можно открыть карточку задачи.

---

## 2.9. Напоминания о событиях

**US-CAL-009**
Как пользователь,
я хочу получать уведомления о начале событий,
чтобы не забывать о встречах и обязательствах.

**Acceptance Criteria:**

* По умолчанию уведомление за 15 минут, пользователь может выбрать другие опции.
* Push приходит даже при закрытом приложении (если разрешение выдано).
* Уведомление ведёт к экрану события.

---

# 3. Задачи, цели, проекты

## 3.1. Создание задачи

**US-TASK-001**
Как пользователь,
я хочу создавать задачи с приоритетами, контекстами и дедлайнами,
чтобы эффективно организовать свою деятельность.

---

## 3.2. Создание проекта / цели

**US-TASK-002**
Как пользователь,
я хочу создавать цели и проекты,
чтобы структурировать долгосрочные намерения.

---

## 3.3. Привязка задачи к цели

**US-TASK-003**
Как пользователь,
я хочу связывать задачи с целями,
чтобы видеть вклад действий в итоговый результат.

---

## 3.4. Отображение прогресса цели

**US-TASK-004**
Как пользователь,
я хочу видеть процент выполнения цели,
чтобы отслеживать продвижение.

---

## 3.5. Фильтрация задач

**US-TASK-005**
Как пользователь,
я хочу фильтровать задачи по приоритету, контексту и проекту,
чтобы быстро находить нужные элементы.

---

## 3.6. Дробимые задачи

**US-TASK-006**
Как пользователь,
я хочу разбивать большую задачу на несколько временных слотов,
чтобы гибко распределять нагрузку.

---

## 3.7. Регулярные задачи

**US-TASK-007**
Как пользователь,
я хочу создавать повторяющиеся задачи,
чтобы автоматизировать рутину.

---

# 4. Финансы

## 4.1. Создание расхода

**US-FIN-001**
Как пользователь,
я хочу добавлять расходы с категорией и суммой,
чтобы вести учёт финансов.

---

## 4.2. Создание дохода

**US-FIN-002**
Как пользователь,
я хочу фиксировать доходы,
чтобы видеть баланс месяца.

---

## 4.3. Привязка финансового события к календарю

**US-FIN-003**
Как пользователь,
я хочу привязывать финансовые операции к календарным событиям,
чтобы видеть, как деньги связаны со временем.

---

## 4.4. Регулярные операции

**US-FIN-004**
Как пользователь,
я хочу создавать регулярные доходы/расходы,
чтобы не вводить их вручную каждый месяц.

---

## 4.5. Просмотр месячного финансового отчёта

**US-FIN-005**
Как пользователь,
я хочу видеть сводку (доходы, расходы, баланс),
чтобы понимать финансовое состояние.

---

## 4.6. Уведомления о предстоящих финансовых событиях

**US-FIN-006**
Как пользователь,
я хочу получать пуш-уведомления о важной финансовой активности,
чтобы ничего не пропускать.

---

# 5. GTD: Inbox

## 5.1. Добавление элемента во входящие

**US-INB-001**
Как пользователь,
я хочу быстро добавлять идеи/заметки в Inbox,
чтобы не держать их в голове.

---

## 5.2. Превращение элемента Inbox в задачу

**US-INB-002**
Как пользователь,
я хочу превращать элемент Inbox в задачу,
чтобы он становился частью моего рабочего процесса.

---

## 5.3. Превращение элемента Inbox в цель

**US-INB-003**
Как пользователь,
я хочу создавать цели на основе элементов Inbox,
чтобы быстро оформлять долгосрочные планы.

---

## 5.4. Обработка Inbox

**US-INB-004**
Как пользователь,
я хочу просматривать элементы Inbox по одному,
чтобы принимать решения о дальнейших действиях.

---

# 6. AI (Pro)

## 6.1. Запуск AI-планировщика

**US-AI-001**
Как Pro-пользователь,
я хочу запустить умный планировщик задач,
чтобы получить оптимальное распределение нагрузки.

---

## 6.2. Получение предложенного плана

**US-AI-002**
Как Pro-пользователь,
я хочу увидеть предложенный AI-план,
чтобы сравнить его со своим расписанием.

---

## 6.3. Принятие/Частичное принятие/Отмена плана

**US-AI-003**
Как Pro-пользователь,
я хочу принимать или отклонять предложения AI,
чтобы сохранять контроль над своим временем.

---

## 6.4. Пользовательские правила для AI

**US-AI-004**
Как Pro-пользователь,
я хочу задавать правила (не планировать поздно, перерывы, запреты по дням),
чтобы AI подстраивался под мои предпочтения.

---

# 7. Подписки и Trial

## 7.1. Просмотр тарифов

**US-SUB-001**
Как пользователь,
я хочу видеть различия между Free и Pro,
чтобы понять смысл апгрейда.

---

## 7.2. Активация Trial

**US-SUB-002**
Как новый пользователь,
я хочу активировать Trial без привязки карты,
чтобы протестировать все Pro-функции.

**Acceptance Criteria:**

* Trial запускается по кнопке из онбординга или экрана тарифов.
* На экране указаны длительность Trial и дата автоотмены/окончания.
* В течение Trial доступны все Pro-функции, после — откат к Free без списания.

---

## 7.3. Просмотр статуса подписки

**US-SUB-003**
Как пользователь,
я хочу видеть мой текущий тариф и дату списания,
чтобы управлять подпиской.

**Acceptance Criteria:**

* На экране статуса отображаются тариф, срок действия, дата следующего списания/окончания Trial.
* Есть кнопки продления/отмены (по платформенным правилам).
* Для Free — подсказки, какие функции недоступны.

---

## 7.4. Ограничения Free (UX)

**US-SUB-004**
Как пользователь Free,
я хочу видеть прозрачные ограничения (например, «AI доступен в Pro»),
чтобы понимать, что даёт апгрейд.

**Acceptance Criteria:**

* Маркеры «Pro» видны в интерфейсе у недоступных функций.
* Переход по маркеру ведёт на экран тарифов.
* Ограничения не блокируют базовые сценарии Free.

---

# 8. Уведомления

## 8.1. Разрешение на уведомления

**US-NOT-001**
Как пользователь,
я хочу дать приложению разрешение на уведомления,
чтобы получать напоминания о задачах и событиях.

**Acceptance Criteria:**

* Системный диалог запрашивается один раз и повторно только по запросу пользователя.
* Отклонённое разрешение отображается как статус с инструкцией, как включить его в настройках устройства.
* Без разрешения напоминания не создаются и пользователь получает подсказку.

---

## 8.2. Получение напоминаний о событиях

**US-NOT-002**
Как пользователь,
я хочу получать уведомление за 15 минут до начала события,
чтобы ничего не пропускать.

**Acceptance Criteria:**

* Настраиваемое время упреждения: 5/15/30/60 минут и «в момент».
* Напоминание создаётся автоматически при создании события, если разрешения выданы.
* Тап по уведомлению открывает событие в календаре.

---

## 8.3. Управление уведомлениями

**US-NOT-003**
Как пользователь,
я хочу отключать и включать категории уведомлений,
чтобы контролировать информационный поток.

**Acceptance Criteria:**

* Отдельные переключатели для событий, задач, финансовых напоминаний и системных сообщений.
* Настройки синхронизируются между устройствами.
* Изменение настроек применяется к будущим уведомлениям.

---

# 9. Offline & Синхронизация

## 9.1. Работа без интернета (кэш)

**US-OFF-001**
Как пользователь,
я хочу иметь возможность продолжать работу без интернета,
чтобы приложение не блокировало меня.

**Acceptance Criteria:**

* Последние данные календаря/задач/финансов доступны из локального кэша.
* Созданные/изменённые сущности ставятся в очередь синхронизации.
* Пользователь видит, какие действия находятся «в очереди».

---

## 9.2. Отложенная синхронизация

**US-OFF-002**
Как пользователь,
я хочу, чтобы действия автоматически отправлялись на сервер после восстановления сети,
чтобы мне не приходилось делать это вручную.

**Acceptance Criteria:**

* Фоновые попытки синхронизации запускаются при восстановлении соединения.
* При успехе локальный статус действий обновляется без участия пользователя.
* При ошибке отправки отображается уведомление/баннер с возможностью повторить.

---

## 9.3. Оповещение о режиме офлайн

**US-OFF-003**
Как пользователь,
я хочу получать ненавязчивый баннер «Синхронизация отложена»,
чтобы понимать текущее состояние.

**Acceptance Criteria:**

* Баннер показывает статус: «Онлайн», «Оффлайн», «Синхронизация…».
* Баннер не перекрывает основной контент и может быть свернут.
* При переходе в онлайн баннер автоматически обновляется.

---

# 10. Настройки и профиль

## 10.1. Изменение рабочего графика

**US-SET-001**
Как пользователь,
я хочу изменять рабочий график в настройках,
чтобы календарь адаптировался к моей реальной жизни.

---

## 10.2. Переключение темы (Тёмная / Светлая)

**US-SET-002**
Как пользователь,
я хочу управлять темой оформления,
чтобы адаптировать интерфейс под освещение.

---

## 10.3. Изменение уведомлений

**US-SET-003**
Как пользователь,
я хочу настраивать уведомления,
чтобы приложение соответствовало моим привычкам.

---

## 10.4. Изменение временной зоны

**US-SET-004**
Как пользователь,
я хочу изменять часовой пояс,
чтобы корректно отображались все события.

---

# 11. Free / Pro дифференциация

### Free-пользователь может:

* пользоваться календарём;
* создавать задачи и цели;
* пользоваться Inbox;
* вести базовый бюджет;
* получать напоминания;
* видеть базовую аналитику.

### Pro-пользователь получает:

**US-PRO-001** — Доступ к AI-планировщику.
**US-PRO-002** — Расширенную аналитику по времени и финансам.
**US-PRO-003** — Расширенные правила планирования.
**US-PRO-004** — Неограниченное количество целей/проектов (если Free ограничен).
**US-PRO-005** — Приоритетную поддержку.

---

# 12. Autonomy Mode (опциональный AI-режим)

## 12.1. Активация и контроль режима

**US-AUTO-001**
Как пользователь,
я хочу включать/выключать Autonomy Mode через настройки и давать явное согласие на автоизменения,
чтобы автономное планирование включалось только под моим контролем.

**Acceptance Criteria:**

* Режим выключен по умолчанию и требует явного согласия.
* Есть тумблер и экран условий (что будет менять AI).
* Можно поставить на паузу без потери данных.

---

## 12.2. Автопланирование с подтверждением

**US-AUTO-002**
Как пользователь,
я хочу получать пакетные предложения от AI по перераспределению задач и событий,
чтобы быстро применять улучшенный план одним подтверждением.

**Acceptance Criteria:**

* Показывается список изменений (переносы, вставки буферов, отмены).
* Каждое изменение можно принять/отклонить, есть кнопка «Применить всё».
* Применение фиксируется в журнале AI-решений.

---

## 12.3. Self-Adjusting Policy Engine

**US-AUTO-003**
Как пользователь,
я хочу, чтобы AI автоматически подстраивал правила планирования под мои привычки (энергия, переносы, загруженность),
чтобы расписание оставалось реалистичным без ручной настройки.

**Acceptance Criteria:**

* AI обновляет буферы/слоты на основе наблюдаемых паттернов.
* Есть прозрачный лог: какие правила обновлены и почему.
* Можно откатить последние изменения правил.

---

## 12.4. Интеграции для автономности

**US-AUTO-004**
Как пользователь,
я хочу подключать HealthKit/Google Fit и внешние календари,
чтобы AI учитывал сон, активность и сторонние события при автопланировании.

**Acceptance Criteria:**

* Права запрашиваются отдельно для каждого источника.
* Пользователь видит, как данные влияют на предложения (лейблы «сон», «нагрузка», «внешнее событие»).
* Можно временно отключить использование конкретного источника данных.

---

## 12.5. История и безопасность изменений

**US-AUTO-005**
Как пользователь,
я хочу видеть историю действий AI и иметь возможность отката изменений,
чтобы чувствовать контроль над автономным режимом.

**Acceptance Criteria:**

* Есть журнал с датой, причиной и списком изменений.
* Откат возвращает расписание/правила в предыдущее состояние.
* Оповещение при массовых изменениях (например, >5 правок за раз).



========================================
FILE: ./Flutter/LifeMerge_docs/01_Product/User_Stories/User_Story_Map.md
========================================

# User Story Map (high-level)

1. **Onboarding**
   - Как новый пользователь, я хочу пройти короткий опрос целей, чтобы получить персональные подсказки.
   - Как пользователь, я хочу импортировать календарь, чтобы сразу видеть свои события.
2. **Plan Day/Week**
   - Как пользователь, я хочу создать задачи и разместить их в календаре, чтобы понимать нагрузку.
   - Как пользователь, я хочу получить AI-предложение расписания недели.
3. **Execute & Track**
   - Как пользователь, я хочу отмечать задачи выполненными и видеть прогресс по целям.
   - Как пользователь, я хочу фиксировать расходы и видеть бюджет.
4. **Review**
   - Как пользователь, я хочу недельный дайджест (выполнено/финансы/цели).
   - Как пользователь, я хочу предложения, что улучшить на следующей неделе.


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/Branding/Brand_Guidelines.md
========================================

# Brand Guidelines

- Название: **LifeMerge** (одно слово, F заглавная).
- Логотип: комбинация волны/потока и чекбокса; в темной теме используем светлый логотип.
- Цвета бренда: primary #5B8DEF, accent #FF9F1C, фон #0F1115.
- Тональность: поддерживающая, практичная, без излишнего пафоса.
- Фото: реальные люди 25–40, работающие и занимающиеся хобби, с тёплым светом.
- Айконсет: линийные иконки 24px с округлыми углами.


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/Interaction_Guidelines.md
========================================

# Interaction Guidelines — LifeMerge (MVP)

*Григорий — Interaction Design / Motion / Micro-interactions*

Документ определяет принципы анимаций, переходов и микро-взаимодействий для MVP LifeMerge. Опираться на UI Kit, тёмную тему, производительность Flutter и общие UX‑паттерны из дизайн-системы.

---

## 1. Цели анимаций в LifeMerge

1. Повысить ясность интерфейса — анимации должны помогать ориентироваться в данных (календарь, задачи, финансы).
2. Передавать тактильность — физические паттерны, реалистичная инерция, лёгкие пружины.
3. Снизить когнитивную нагрузку — направлять внимание, а не привлекать его без причины.
4. Работать в тёмной теме без визуального шума.
5. Быть лёгкими для производительности (60 fps, минимизация слоёв, избегать тяжёлых эффектов).

---

## 2. Паттерны анимаций для MVP

### 2.1. Fade-Scale для появления контента

**Использование:** карточки задач, элементы списков, записи Inbox, модальные окна.

* Время: 120–160 мс
* Кривая: easeOutCubic
* Поведение: лёгкое увеличение от 0.96 → 1.0 + fade 0 → 1
* Flutter: `FadeTransition + ScaleTransition`, без лишних RepaintBoundary

### 2.2. Slide-Fade вертикальный для переходов между вкладками

**Использование:** переключение Home → Calendar → Tasks → Finance.

* Время: 160–200 мс
* Кривая: standard (0.4, 0.0, 0.2, 1)
* Избегать больших параллаксов — акцент на плавности.

### 2.3. Shared Axis (Horizontal) для Calendar / Tasks

**Использование:** переходы между списками задач, карточкой задачи, карточкой события.

* Время: 180–220 мс
* Кривая: easeInOut
* Оси:

  * Горизонталь — для навигации между sibling‑экранами
  * Вертикаль — для переходов уровня вложенности (список → детальная)

### 2.4. Opacity Lift для выделения активного элемента

**Использование:** нажатие на карточку задачи, событие календаря, элемент Inbox.

* Время: 80–120 мс
* Лёгкое повышение яркости и глубины (elevation.sheet → elevation.card)
* Без масштабирования более чем на 1–2%

### 2.5. Animated Drag Feedback

**Использование:** drag & drop событий в Calendar.

* Время обратной связи: < 16 мс (реакция в один кадр)
* Эффект: при захвате — небольшое увеличение 1.00 → 1.04, тень усиливается.
* Возврат при отмене — пружина 180–220 мс.

---

## 3. Переходы для Calendar

### 3.1. День ↔ Неделя

**Цель:** сохранить пространственное восприятие времени.

**Анимация:**

* Изменение высоты таймлайнов с анимацией layout (AnimatedSize).
* События плавно перебираются в новую сетку.
* Duration: 220–260 мс.
* Кривая: easeInOutCubic.

**Рекомендации:**

* Не масштабировать весь экран — изменять лишь сетку.
* Включить hero‑анимацию для текущей временной метки.

### 3.2. Переход список событий → карточка события

**Паттерн:** Shared Axis Vertical.

* Деталь «выезжает» сверху, список слегка затемняется.
* Duration: 180–220 мс.
* Плавный elevation shift.

### 3.3. Drag & Drop: перемещение события

* Захват: тень ↑, масштаб 1.00 → 1.04.
* Перемещение: курсор/палец «ведёт» карточку без задержки.
* Drop: пружина 160–200 мс + небольшой fade на подтверждение.
* Конфликт времени (overlap): короткий красный highlight 80 мс.

---

## 4. Переходы для Tasks

### 4.1. Список задач → карточка задачи

**Паттерн:** Shared Axis Vertical.

* Сжатие списка вниз, карточка поднимается вверх.
* Duration: 200 мс.

### 4.2. Добавление задачи

**Паттерн:** Fade-Scale Up.

* Скейл 0.96 → 1.0 + opacity 0 → 1.
* Duration: 140–160 мс.
* Подчеркнуть момент появления и облегчить восприятие нового элемента.

### 4.3. Отметка «выполнено»

**Паттерн:** Completion Sweep.

* Иконка галочки анимируется sweep‑движением 120 мс.
* Карточка выцветает 1 → 0.4 opacity + лёгкий подъём 4 px.
* Полное исчезновение через 200 мс, если настроено автоскрытие.

### 4.4. Работа с подзадачами

* Раскрытие: height animation (AnimatedSize) 160 мс.
* Чёткая визуальная иерархия за счёт сдвига и линии слева.

---

## 5. Общие принципы Micro‑Interactions

### 5.1. Реалистичные тайминги

* Малые взаимодействия: 80–120 мс.
* Средние переходы: 160–220 мс.
* Большие изменения структуры: 220–300 мс.

### 5.2. Физичность без «пружинности ради пружинности»

* Использовать пружину только для drag/drop и подтверждений.
* Для всего остального — bezier-кривые UI Kit.

### 5.3. Отсутствие лишней хореографии

* Никаких «сложных входов» списков и карточек.
* Ключевой принцип MVP — скорость и визуальная ясность.

### 5.4. Темная тема

* Избегать светящихся элементов.
* Анимации должны работать без изменения контраста.

### 5.5. Производительность

* До 2 одновременно анимируемых свойств: opacity + scale или offset + opacity.
* Layout изменения через AnimatedSize, избегать анимации больших списков.

### 5.6. Обратная связь при ошибках

* Ошибочные состояния — короткий shake или highlight 80 мс.
* Для сетевых ошибок — fade‑banner сверху 200 мс.

---

## 6. Компоненты с обязательными анимациями

* Календарь: drag/drop, переход день⇄неделя, открытие карточки события.
* Задачи: отметка выполнения, открытие карточки, добавление новой.
* Inbox: появление элемента, преобразование в задачу/цель.
* Модальные окна: fade‑scale.

---

## 7. Не допускается

* Масштабирование экрана > 4% — вызывает дезориентацию.
* Избыточные тени на тёмной теме.
* Длительные (>300 мс) переходы в основных сценариях.
* Нелинейные кривые типа bounce для текстовых списков.

---

## 8. Требования к реализации (Flutter)

* Использовать Implicit Animations там, где возможно.
* Для Calendar использовать RepaintBoundary вокруг крупных таймлайнов.
* Обязательный тест performance профилем: 60 fps на Pixel 6 / iPhone 12.
* Анимации должны учитываться в DoD: UI соответствует макетам и спецификациям анимации.

---

## 9. Следующие шаги

1. Утвердить с Lead UI/UX Designer.
2. Синхронизировать с Flutter-командой по реализуемости.
3. Добавить анимации в прототип Figma.
4. Создать библиотеку motion‑токенов (durations, curves).

---

Документ готов к итерациям и расширению для Pro 1.0.


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/Prototypes/Dark_Mode/Readme.md
========================================

# Dark Mode – Prototypes

Здесь хранятся дизайн-спецификации тёмной темы:
- основные экраны,
- компоненты,
- цветовые токены,
- уровни теней и контрастности.

Файлы пригодны для передачи разработчикам.


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/Prototypes/Notes/MVP_Wireframes.md
========================================

Структура MVP_Wireframes.md:

Введение: кратко описано, что ниже приведён список экранов MVP с пояснениями. Указано, что эти экраны отражены в прототипах/wireframes, и что детальные визуальные макеты доступны на странице "Ready for Dev" (с общим линком на файл Figma). Также поясняется система приоритетов (например, P1 – критически необходим для MVP, P2 – желательный, но может быть отложен, если не успеваем).

Список экранов по разделам: экраны сгруппированы по тем же блокам: Auth, Calendar, Tasks:

Auth:

Onboarding_v1 – Цель: познакомить нового пользователя с приложением (welcome-скрины). Приоритет: P1 (высокий), т.к. влияет на конверсию новых пользователей. Figma: Onboarding_v1.

ScheduleSetup_v1 – Цель: сбор данных о графике пользователя для персонализации. Приоритет: P2 (средний) – полезно, но не блокирует MVP, может быть упрощено. Figma: ScheduleSetup_v1.

Register_v1 – Цель: регистрация пользователя. Приоритет: P1. Figma: Register_v1.

Login_v1 – Цель: вход в аккаунт. Приоритет: P1. Figma: Login_v1.

Recovery_v1 – Цель: восстановление пароля. Приоритет: P2. Figma: Recovery_v1.

Calendar:

Calendar_Day_v1 – Цель: показать расписание на день. Приоритет: P1 (основной экран календаря). Figma: Calendar_Day_v1.

Calendar_Week_v1 – Цель: обзор недели. Приоритет: P2 (можно запустить MVP и без недельного вида, но желателен). Figma: Calendar_Week_v1.

Calendar_Month_v1 – Цель: обзор месяца. Приоритет: P2. Figma: Calendar_Month_v1.

Event_New_v1 – Цель: создание нового события. Приоритет: P1 (ядро функционала календаря). Figma: Event_New_v1.

Event_Details_v1 – Цель: просмотр/редактирование события. Приоритет: P1. Figma: Event_Details_v1.

Tasks:

Task_List_v1 – Цель: список всех задач (с фильтрами). Приоритет: P1 (основной экран задач). Figma: Task_List_v1.

Task_Detail_v1 – Цель: детали задачи. Приоритет: P1. Figma: Task_Detail_v1.

Task_Form_v1 – Цель: создание/редактирование задачи. Приоритет: P1. Figma: Task_Form_v1.

(Каждый пункт содержит имя фрейма, краткое описание цели/функции экрана, приоритет и гиперссылку на макет Figma. Ссылки указывают прямо на конкретные фреймы на странице "Ready for Dev".)

Примечания/Допущения: в конце файла приведены общие заметки. Например: «Экран “Week View” отмечен как P2 – может быть реализован во вторую очередь, если сроки поджимают, основной функционал календаря обеспечит Day и Month». Или: «В MVP не включён раздел Finance (финансы) – он в планах на будущее, поэтому в списке отсутствуют соответствующие экраны». Также зафиксировано, что критерий успешности MVP – наличие как минимум одного рабочего сценария для каждой ключевой сущности (задачи, события, цели), и перечисленные экраны этому соответствуют.

Документ MVP_Wireframes.md становится частью проектной документации. Он облегчает коммуникацию: новые члены команды или сторонние участники могут быстро понять, какие экраны будут в первом релизе и почему. При изменениях (scope change) документ обновляется. Кроме того, наличие ссылок на Figma обеспечивает актуальность: всегда можно кликнуть и увидеть последний дизайн соответствующего экрана.

========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/Prototypes/Web_Future/Notes/Web_Adaptive_Design_Principles.md
========================================

Здесь пока пусто

========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/Prototypes/Web_Future/Notes/Web_Navigation_Concepts.md
========================================

Здесь пока пусто

========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/Prototypes/Web_Future/Readme.md
========================================

# Web Future – Prototypes

Папка хранит концепты будущей web-версии LifeMerge:
- адаптивная панель,
- двухпанельный режим,
- календарь и финансы на широких экранах.

Файлы делятся на:
- Wireframes — структурные макеты,
- High_Fidelity — высокодетализированные дизайны,
- Notes — описание UX решений.


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/UI_Kit/Colors.md
========================================

# Цвета

| Токен | Значение | Использование |
|-------|----------|---------------|
| `primary` | #5B8DEF | Кнопки, активные элементы |
| `primaryDark` | #3562C2 | Hover/нажато, тёмная тема |
| `accent` | #FF9F1C | Уведомления, акценты на карточках |
| `success` | #34C759 | Выполнено, позитивные статусы |
| `error` | #FF3B30 | Ошибки, критичные уведомления |
| `bg` | #0F1115 | Фон приложения (dark first) |
| `surface` | #181C22 | Карточки, модальные окна |
| `textPrimary` | #FFFFFF | Основной текст |
| `textSecondary` | #B8C2D1 | Вторичный текст, подписи |


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/UI_Kit/Components/Buttons.md
========================================

# Кнопки

- **Primary**: background `primary`, текст `textPrimary`, радиус `12`, высота `52`. Состояния: default, pressed (`primaryDark`), disabled (20% opacity).
- **Secondary**: обводка `primary`, текст `primary`, фон `surface`. Hover/pressed затемнение 8%.
- **Ghost/Icon**: без рамки, padding 12, иконка 24px.
- Минимальная ширина 120px, tap area 44px.


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/UI_Kit/Components/Cards.md
========================================

# Карточки

- Фон `surface`, радиус `12`, тень `elevation.card`.
- Внутренние отступы: `16` по всем сторонам; между элементами `8`.
- Поддерживаются вариации: задача, событие, финоперация, цель (отличаются иконкой и акцентом).
- Для задач и событий показываем бейдж статуса/источника в правом верхнем углу.


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/UI_Kit/Components/Chips.md
========================================

# Чипсы

- Радиус 16, высота 32, padding 12.
- Варианты: фильтр (toggle), статус (filled), тег (outline).
- Цвета: primary для активных, surface + текст вторичный для неактивных.
- Иконка слева опциональна, крестик для удаления тегов справа.


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/UI_Kit/Components/Inputs.md
========================================

# Поля ввода

- Высота 52, радиус `12`, фон `surface`.
- Обводка 1px `primary` при фокусе, `textSecondary` по умолчанию.
- Подписи/лейблы `Caption`, плейсхолдер вторичным цветом.
- Поддержка иконки слева, кнопки очистки справа.
- Ошибка: обводка и текст `error`, вспомогательный текст под полем.


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/UI_Kit/Components/Modals.md
========================================

# Модальные окна/боттомшиты

- Радиус верхних углов 16, фон `surface`, тень `elevation.sheet`.
- Хэндл для перетягивания 40x4, отступ сверху 8.
- Внутренние отступы 20 по сторонам, кнопки внизу закреплены.
- Поддержка full-screen модалов для создания задач/событий.


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/UI_Kit/Components/Navigation.md
========================================

# Навигация

- Нижняя таб-бар на 5 вкладок: Home, Calendar, Tasks, Finance, AI/Inbox.
- FAB на Home для быстрого создания задачи/события/финоперации.
- Вторичный top-bar с переключением вида календаря (день/неделя/месяц).
- Deeplink из пушей ведёт на конкретную задачу/событие.


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/UI_Kit/Dark_Theme.md
========================================

# Темная тема

- **Dark-first:** интерфейс по умолчанию использует тёмную палитру (`bg`, `surface`), светлая тема не проработана.
- **Контраст:** минимально `4.5:1` для текста и `3:1` для иконок/бордеров. Используем `textPrimary` для основного текста и `textSecondary` для подписи/плейсхолдера.
- **Состояния поверхностей:** hover — осветляем фон на `8%`, pressed — на `12%` (можно через белый overlay), disabled — понижаем непрозрачность до `60%`.
- **Блики и тени:** карточки и модалки опираются на токены `elevation.card` и `elevation.sheet`; избегаем жёстких теней, используем мягкие размытия.
- **Акценты:** `primary` — основной брендовый цвет, `primaryDark` — для hover/pressed и тёмных фоновых элементов; `accent` применяем только для уведомлений и бейджей.
- **Изображения и логотипы:** на тёмном фоне применяем светлые версии логотипа и иллюстраций (см. бренд-гайд).
- **Градиенты и шум:** допускаются лёгкие шумовые/радиальные градиенты на фоне, но без ухудшения читаемости текста.


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/UI_Kit/Design_Tokens.json
========================================

{
  "colors": {
    "primary": "#5B8DEF",
    "primaryDark": "#3562C2",
    "accent": "#FF9F1C",
    "success": "#34C759",
    "error": "#FF3B30",
    "bg": "#0F1115",
    "surface": "#181C22",
    "textPrimary": "#FFFFFF",
    "textSecondary": "#B8C2D1"
  },
  "typography": {
    "fontFamily": "Inter",
    "h1": {"size": 32, "weight": 700, "lineHeight": 38},
    "h2": {"size": 24, "weight": 700, "lineHeight": 30},
    "body": {"size": 16, "weight": 400, "lineHeight": 22},
    "caption": {"size": 13, "weight": 400, "lineHeight": 18}
  },
  "radius": {"s": 8, "m": 12, "l": 16},
  "spacing": {"xs": 4, "s": 8, "m": 12, "l": 16, "xl": 24},
  "elevation": {"card": 8, "sheet": 16}
}


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/UI_Kit/Typography.md
========================================

# Типографика

- Базовый шрифт: **Inter**.
- Заголовки: `H1 32/38 bold`, `H2 24/30 bold`, `H3 20/26 semibold`.
- Текст: `Body 16/22 regular`, `Caption 13/18 regular`.
- Используем `1.2–1.3` line-height для читаемости в темной теме.
- Максимум 2 цвета текста: `textPrimary` и `textSecondary`.


========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/UI_Kit/UI_Kit_v1.0.md
========================================

UI Kit v1.0 для проекта LifeMerge
Обязательные компоненты дизайна (Приоритет 1)
Кнопки (Buttons)

Включены три стиля кнопок – Primary (основная), Secondary (второстепенная) и Tertiary (дополнительная). Все кнопки имеют высоту 48pt и скругленные углы с радиусом 10pt, обеспечивая достаточную площадь нажатия (что соответствует минимальному рекомендованному размеру тап-таргета ~48dp
m1.material.io
). Для каждой кнопки проработаны состояния: обычное (default), наведение/нажатие (pressed), неактивное (disabled) и загрузка (loading).

Primary-кнопки используются для ключевых действий и выделяются основным цветом темы; Secondary – для второстепенных действий (может быть с контуром или более мягким цветом), Tertiary – для вспомогательных действий (часто отображаются как текстовые кнопки без заливки). Состояние загрузки оформлено либо встроенным индикатором на кнопке, либо заменой текста на спиннер. Неактивное состояние визуально приглушено (более бледный фон и текст) и не допускает взаимодействия.

Поля ввода (Input Fields)

В UI Kit присутствуют текстовые поля для ввода (например, логин, пароль, поиск и т.п.) с метками (label) и вспомогательным текстом. Все поля оформлены в едином стиле с рамкой или подчеркиванием, обеспечивая достаточный контраст и размер шрифта для читабельности. Предусмотрены различные состояния: дефолтное (пустое поле без фокуса), фокус (focused) – с подсветкой рамки или тени, заполненное (filled) – когда пользователь ввёл данные, состояние ошибки (error) – с красной рамкой и сообщением об ошибке, и неактивное (disabled) – с бледным текстом/рамкой и без возможности ввода. Наличие всех этих состояний соответствует лучшим практикам дизайн-систем: поля ввода являются одними из наиболее распространённых компонентов и должны включать метку, подсказку и визуальную индикацию ошибок
uxpin.com
uxpin.com
.

Например, для состояния ошибки отображается понятный текст ошибки и изменяется цвет рамки на цвет ошибки из палитры.

Карточки (Cards)

Разработаны три вида карточек для разных типов контента: TaskCard, EventCard, FinanceCard. Все карточки имеют скругление углов 12pt и лёгкую тень, чтобы выделяться над фоном. Карточки служат контейнерами для связанной информации и действий по задачам, событиям или финансам. Единый стиль карточек помогает пользователям быстрее сканировать содержимое
uxpin.com
. Каждая карточка содержит заголовок, иконки или превью (если применимо) и краткие детали: например, TaskCard включает название задачи, статус и дедлайн; EventCard – название события, дату/время и место; FinanceCard – сумму, категорию расхода/дохода. При взаимодействии карточки могут слегка подниматься (эффект hover) или изменять тень. Все карточки адаптированы под светлую и тёмную тему (фон и текст автоматически меняют цвет согласно токенам темы).

Чипсы (Chips)

Небольшие метки-фильтры высотой 28pt, используемые для отображения категорий или атрибутов и для фильтрации контента. Чипсы имеют скруглённые углы (радиус примерно 14pt) и содержат короткий текст или иконку с текстом. Реализованы состояния: обычное (default) – нейтральный фон (или обводка) и стандартный цвет текста; выбранное (selected) – фон или обводка подсвечены основным цветом, текст контрастный (например, белый на активном фоне); неактивное (disabled) – элемент бледнее, недоступен для взаимодействия. Чипсы помогают пользователю отмечать выборы или фильтровать элементы и часто используются группами, позволяя множественный выбор.

Верхняя панель (App Bar)

Фиксированная верхняя панель высотой 56pt, содержащая заголовок экрана и иконки действий. App Bar обеспечивает контекст и навигацию на всех основных экранах. Слева обычно располагается иконка навигации (например, “бургер” для меню или стрелка назад для возврата), по центру – заголовок текущего раздела, а справа – одна или две иконки действий (например, поиск, настройки). Высота 56pt соответствует гайдлайнам Material для мобильных приложений, обеспечивая удобство касания элементов. В тёмной теме App Bar меняет цвет фона на более тёмный, а текст/иконки – на светлые, чтобы сохранить контраст.

Нижняя навигация (Bottom Navigation)

Нижняя панель навигации с пятью основными разделами приложения, представленными иконками и подписями. Каждый элемент отображается как иконка (и текст) и имеет состояния: default (не выбран) – обычно монохромная или приглушённая иконка, selected (выбран) – окрашенная основным цветом и (если предусмотрено) сопровождаемая яркой подписью. Bottom Navigation фиксируется внизу экрана, облегчая пользователю переключение между разделами (например, Календарь, Задачи, Финансы, Профиль). Пять пунктов – это максимум для сохранения читаемости и удобства нажатия; каждый пункт имеет достаточную ширину (~минимум 48pt) для комфортного взаимодействия. При выборе раздела может отображаться небольшая анимация или изменение фона под иконкой, сигнализируя о смене текущего раздела.

Индикаторы загрузки (Spinners & Progress)

Для состояний загрузки и ожидания предусмотрены анимированные индикаторы. Используется спиннер (круговой индикатор) для фоновых коротких процессов и прогресс-бар (линейная полоска) для более продолжительных или многошаговых операций. Спиннер оформлен в цвете primary (например, вращающийся кружок основного цвета на прозрачном фоне для светлой темы, и наоборот для тёмной темы). Размер спиннера адаптируется под контекст: маленький – внутри кнопки при её состоянии loading, стандартный (~24pt) – по центру экрана при загрузке контента. Наличие явных индикаторов прогресса важно для обратной связи пользователю
uxpin.com
.

Пользователь видит, что приложение обрабатывает запрос и не зависло. Дополнительно применяются скелетоны – placeholders в виде серых блоков вместо контента, чтобы показать структуру данных во время их загрузки (например, серые прямоугольники вместо карточек списка).

Цветовые токены и темы (Colors)

Определена цветовая палитра с разделением на семантические токены для светлой и тёмной тем. Основные токены включают: primary (брендовый основной цвет – используется для акцентных элементов, кнопок, активных состояний), secondary (дополнительный цвет для акцентов или второстепенных элементов интерфейса), background (основной цвет фона приложения), surface (цвет поверхностей, например, карточек, панелей), error (цвет для состояний ошибок), success и warning (для индикации успешных действий и предупреждений), а также текстовые цвета вроде onPrimary и onSurface (цвет текста/иконок поверх соответствующих фонов).

Для каждого токена задано два значения – для light и dark темы. При переключении темы значения меняются на соответствующие, но имя токена остаётся тем же (это реализовано через дизайн-токены Figma или CSS-переменные). Это позволяет единообразно применять цвета в коде и дизайне: например, токен primary может быть синим в светлой теме и светло-голубым в тёмной для контраста, но в дизайне везде обозначается как color.primary. Такой механизм соответствует современным дизайн-системам: дизайн-токен связывает абстрактное имя цвета с конкретными значениями под каждую тему
atlassian.design
. Палитра подобрана с учётом контрастности (для текста на фоне, иконок на кнопках и т.п.) согласно WCAG.

Типографика (Typography)

Установлены стили текста для заголовков и базового текста, основанные на единой шкале размеров. Предусмотрено 3 уровня заголовков: H1, H2, H3 – от самого крупного к меньшим. Например, H1 используется для самых важных заголовков (размер порядка 32pt, полужирный), H2 – для подпунктов или разделов (около 24pt, полужирный), H3 – для подразделов/секций (около 20pt, полужирный либо обычный). Основной текст имеет два базовых стиля: Body1 (например, 16pt, нормальный вес) – для основного содержания, Body2 (около 14pt) – для вторичного текста. Также задан стиль Caption (~12pt, мелкий шрифт для подписей, дат и т.п.) и стиль Button (для текста кнопок – обычно 14–16pt, полужирный, может быть верхним регистром).

Все текстовые стили определены с указанием шрифта (семейство), начертания, размера, межстрочного интервала и пр. Благодаря этому при разработке используются именно эти значения, а дизайн остаётся цельным. Стили вынесены в отдельные Text Styles в Figma, что ускоряет применение. Определение типографической иерархии в UI Kit гарантирует, что дизайнеры и разработчики говорят “на одном языке” и соблюдается визуальная иерархия текста
productstar.ru
.

Все перечисленные компоненты и стили включены в финальную версию UI Kit 1.0. Это соответствует лучшим практикам: полноценный UI Kit содержит базовые интерактивные элементы (кнопки, поля ввода, переключатели), контейнеры и карточки, навигационные блоки, типографику и цветовую палитру
productstar.ru
productstar.ru
. Компоненты согласованы между собой по стилю, отступам, радиусам скругления, цветовому оформлению и поведению. Благодаря этому единообразию разработчики смогут использовать UI Kit как единый источник правды, а пользователи ощутят целостный и знакомый опыт работы с приложением.

Крайние сценарии (Edge Cases & States)

При разработке дизайна учтены особые состояния интерфейса – ситуации, когда контент отсутствует, произошла ошибка, идёт загрузка или нет подключения. Проработка этих сценариев повышает качество UX и предотвращает замешательство пользователей. Ниже описаны подходы к таким состояниям:

Пустые состояния (Empty States)

Для экранов или разделов, где отсутствуют данные (например, нет задач, нет событий в календаре, результаты поиска пусты), разработаны специальные макеты. Вместо пустого экрана отображается дружелюбное сообщение и иллюстрация/иконка, объясняющие ситуацию и предлагающие следующий шаг. Например, на экране списка задач, если задач нет, выводится сообщение: «У вас пока нет задач. Нажмите +, чтобы добавить первую.» – вместе с условной иконкой (например, чекбокс или папка) в приглушённых тонах. Такое сообщение сразу информирует о состоянии системы и подсказывает пользователю, что делать дальше
nngroup.com
. Без этого пользователь мог бы задуматься: загрузились ли данные, произошла ли ошибка или нужно самостоятельно добавить что-то? Каждый пустой экран выдержан в фирменном стиле (цвета, шрифты) и может содержать CTA – например, кнопку для создания нового элемента прямо из пустого состояния. Таким образом, пустой экран превращается в полезный: информирует и направляет пользователя, вместо того чтобы просто показывать пустое место.

Ошибочные состояния (Error States)

Предусмотрены экраны и всплывающие уведомления для различных ошибок – от ошибок ввода (не пройдена валидация формы) до сбоев загрузки или проблемы с сетью. Каждое сообщение об ошибке сформулировано понятно и содержит инструкцию для пользователя, как действовать (например: «Не удалось загрузить данные. Проверьте подключение и попробуйте снова.»). Визуально ошибки выделяются использованием цвета error из палитры (как правило, ярко-красного) и соответствующей иконкой (например, красный восклицательный знак). Для критических сбоев, которые блокируют работу приложения, спроектирован отдельный экран-заглушка: крупная иконка ошибки, текст пояснения и кнопка действия («Повторить» или «Помощь»). Для локальных ошибок (скажем, не загрузилась отдельная карточка списка) – на её месте может отображаться небольшой серый блок с сообщением об ошибке. В компоненты форм также встроено отображение ошибок: у поля ввода появляется красная рамка и текст-подсказка под ним. Благодаря унифицированному оформлению ошибок пользователь сразу распознаёт проблему и понимает, как её решить.

Состояния загрузки (Loading States)

Когда данные загружаются или выполняется длительная операция, пользователь видит явные индикаторы процесса. Помимо упомянутых выше спиннеров и прогресс-баров, на местах контента используются скелетоны – временные серые блоки, имитирующие структуру страницы. Например, пока список задач не подгрузился, на экране отображаются несколько серых полос вместо текста и круглые заготовки вместо иконок/аватаров. Это лучше, чем просто пустой экран, так как даёт представление о том, что именно загружается (список, карточки и т.д.). Если операция критична и происходит на отдельном экране (например, авторизация), может показываться полноэкранный спиннер или блокирующий индикатор. По завершении загрузки скелетоны исчезают, и появляются реальные данные, либо происходит автоматический переход на другой экран. Таким образом, всегда соблюдается принцип обратной связи: приложение явно показывает, что оно занято, и пользователь понимает, что нужно подождать
nngroup.com
 (избегаем ситуации, когда пустой экран заставляет гадать, идет загрузка или нет).

Офлайн-режим (Offline States)

Приложение распознаёт отсутствие интернет-соединения и уведомляет об этом пользователя. В UI предусмотрен офлайн-баннер – заметная полоса в верхней части экрана (либо всплывающее toast-сообщение), появляющаяся при потере сети. В нём отображается сообщение вроде: «Вы офлайн. Данные могут быть не обновлены.» вместе с иконкой отсутствия сигнала. Такое уведомление появляется сразу, как только соединение пропадает, чтобы пользователь понял, почему новый контент не загружается
web.dev
. Одновременно некоторые действия в офлайн-режиме ограничиваются: например, кнопки, требующие соединения (обновить, отправить форму), могут становиться неактивными, сопровождаясь подсказкой. Если часть функционала доступна офлайн (например, просмотр ранее загруженных данных, создание элементов с отложенной синхронизацией), приложение позволяет продолжать работу и помечает несинхронизированные изменения специальным значком. Как только связь восстановлена, пользователь получает сигнал (исчезновение баннера или уведомление «Соединение восстановлено»), и отложенные действия могут быть автоматически выполнены. Такой подход соответствует рекомендациям по офлайн-UX: чётко информировать о состоянии приложения и доступных действиях при потере связи
web.dev
web.dev
. Пользователь остаётся в курсе событий и не теряет доверия к приложению даже при нестабильном интернете.

Проработка этих крайних сценариев на этапе дизайна предотвращает состояние неопределённости для пользователя. Каждый ключевой экран в макетах имеет вариант под эти случаи (empty/error/loading/offline), и они вынесены на страницу Figma для разработки. Например, присутствует отдельный экран списка задач без задач, экран ошибки сети, офлайн-баннер и т.д. – все они учтены в дизайне и будут реализованы разработчиками.

Wireframes низкой детализации для основных блоков

Для планирования UX-логики проекта подготовлен комплект wireframes (простых схематичных экранов) по основным функциональным блокам: Auth, Calendar, Tasks. Эти наброски отражают структуру экранов и последовательность действий пользователя, без детальной прорисовки UI – что позволяет команде сфокусироваться на функциональности, а не на стиле
interaction-design.org
. Wireframes легко корректировать и обсуждать; они служат основой для последующей детальной дизайна. Ниже перечислены экраны и сценарии, покрытые wireframes, с пояснением их целей:

Блок авторизации (Auth)

Onboarding (онбординг): Серия стартовых экранов, знакомящих пользователя с возможностями приложения при первом запуске. Обычно это 2–3 экрана-слидера с краткими описаниями и иллюстрациями. Цель: вовлечь нового пользователя и кратко показать ценность LifeMerge до регистрации. Wireframe отображает место под изображение/иконку, несколько строк текста-инструкции и кнопку «Далее» (или «Начать»). После онбординга пользователь переходит к регистрации.

Schedule/Graph (настройка графика): Примечание: В ТЗ упомянут «График» в контексте Auth. Предположительно, это экран, где новый пользователь настраивает свой распорядок (например, рабочие часы, предпочтительные часы для задач) либо демонстрация календарного графика. Цель: собрать персональные данные для персонализации (если это часть онбординга) – например, когда удобно планировать задачи. Wireframe показывает интерактивный элемент (календарь или шкалу времени), где пользователь отмечает свой график. Если этот шаг необязателен, предусмотрена кнопка «Пропустить».

Registration (регистрация): Экран создания нового аккаунта с формой ввода (имя, email, пароль и т.п.). Цель: позволить пользователю зарегистрироваться. Wireframe отображает поля ввода, кнопку «Зарегистрироваться» и ссылку «Уже есть аккаунт? Войти». Учтены детали UX: кнопка остается неактивной, пока не заполнены обязательные поля; при ошибке (например, email уже занят) будет показано сообщение ошибки под полем.

Login (вход): Экран входа для существующих пользователей. Содержит поля логина (например, email) и пароля, кнопку «Войти» и ссылку «Забыли пароль?». Цель: предоставить быстрый доступ к аккаунту. Wireframe минималистичен: логотип/название приложения, поля и кнопка – ничего лишнего. Добавлена опция «Keep me signed in» (если требуется).

Password Recovery (восстановление пароля): Процесс сброса пароля. Цель: помочь пользователю восстановить доступ. Wireframe представляет два шага: ввод email/телефона на первом экране и подтверждение на втором. На первом – поле «Email» и кнопка «Восстановить пароль». На втором – сообщение «Мы отправили ссылку для сброса на ваш email» и кнопка «OK». Продуманы нюансы: например, если email не найден, отобразится соответствующая ошибка.

Эти wireframes охватывают полный путь нового пользователя от установки приложения до входа, а также сценарий восстановления. Они показывают, как пользователь переходит от онбординга к регистрации, от регистрации к входу и т.д. Несмотря на простоту (низкая детализация), уже на этом этапе проверена логика: никакой необходимый шаг не упущен, навигация между экранами очевидна (например, из регистрации можно перейти на экран входа и наоборот). Такой подход помогает рано выявить и устранить проблемы в UX потоке.

Блок календаря (Calendar)

Day View (День): Экран календаря для одного дня. Цель: детально показать расписание пользователя на выбранный день. Wireframe отображает верхний бар с датой и, возможно, переключателями просмотра (день/неделя/месяц) или кнопкой «Сегодня». Основная часть – список событий за день, отсортированных по времени. Каждый элемент содержит время, название события (и, возможно, место или пометку). Если событий нет, внизу экрана – иллюстрация и текст пустого состояния («Нет событий»). Предусмотрена кнопка «+» (Floating Action Button) для создания нового события.

Week View (Неделя): Экран календаря на неделю. Цель: дать обзор нагрузки на неделю. Wireframe показывает сетку 7 дней (пн-вс) с краткими отметками событий (например, маленькие блоки или полоски внутри ячеек дней). Верхняя панель – управление (стрелки переключения недель, выпадающий список выбора недели, либо табы для разных видов). Если событий мало, они могут отображаться списком по дням. Этот экран поможет пользователю планировать недельную занятость.

Month View (Месяц): Экран календаря на месяц. Цель: показать долгосрочный план (даты с событиями). Wireframe представляет типичную сетку календаря (5–6 строк недель, 7 столбцов дней). Внутри ячеек дней отмечены события, например, маленькими точками или цветными метками (если много событий, может отображаться число «+3» и т.д.). Выбранный день подсвечивается. Этот экран удобен для выбора конкретной даты – по тапу на день пользователь перейдёт в Day View.

Create Event (Новое событие): Экран создания события. Цель: позволить пользователю добавить новую встречу или напоминание. Wireframe включает форму: поля «Название», «Дата и время» (с кнопкой выбора на календаре/таймпикере), «Место» (с иконкой карты), «Описание» и, возможно, переключатели или список участников. Кнопка «Сохранить» активна, когда заполнено обязательное поле (название). Также показана кнопка «Отмена» для закрытия формы. Все элементы размещены компактно, возможно, экран реализуется как модальное окно поверх календаря.

Event Details (Детали события): Экран просмотра информации о событии. Цель: дать полный контекст по выбранному событию и опции действий. Wireframe показывает заголовок события, дату и время, место (с иконкой местоположения), описание, список участников (с аватарками или инициалами). Внизу – кнопки «Редактировать» и «Удалить событие». Этот экран может вызываться по тапу на событие из календаря. Если событие прошло, оно может быть отображено серым или с пометкой «Прошедшее».

Wireframes календаря охватывают все основные задачи пользователя, связанные с управлением временем: от просмотра расписания (на разных уровнях детализации) до создания и редактирования событий. Они обеспечивают последовательность: пользователь может перейти с Month к Day, создать событие, увидеть его тут же в списке. Навигация и действия проверены: FAB «+» открывает форму, тап на событие – экран деталей, стрелки переключают периоды и т.д. Благодаря низкой детализации, эти схемы были использованы для быстрого UX-тестирования (например, в обсуждениях команды): убедиться, что все понятны и ничего не забыто.

Блок задач (Tasks)

Task List (список задач): Экран со списком всех задач пользователя. Цель: предоставить удобный обзор дел и инструменты фильтрации. Wireframe включает верхнюю панель с заголовком («Задачи» или «Мои задачи») и иконками (поиск, фильтр). Ниже – горизонтальный список фильтров (например, вкладки: «Все», «Сегодня», «Выполненные», «По проектам»), реализуемый как Chip-группа. Основное пространство – перечень задач вертикально. Каждая строка содержит чекбокс (для отметки выполнения), название задачи, возможно, значок приоритета или дедлайн датой. Если задач нет, выводится сообщение пустого состояния. В углу – плавающая кнопка «+» для добавления новой задачи.

Task Detail (детали задачи): Экран подробностей задачи. Цель: показать всю информацию по задаче и дать возможность действий (изменить, отметить выполненной). Wireframe отображает заголовок задачи крупным шрифтом, под ним – переключатель или чекбокс статуса («Выполнена / Не выполнена»). Далее – описание задачи (многострочный текст), информация о дедлайне (иконка календаря и дата), категория/проект (если есть), вложения (иконки файлов). Также может быть блок подзадач, если концепция поддерживает чек-лист внутри задачи. Внизу экрана – кнопки «Редактировать» и «Удалить».

Task Form (форма задачи): Экран создания/редактирования задачи. Цель: позволить пользователю добавить новую задачу или изменить существующую. Wireframe показывает форму с полями: «Название задачи» (текстовое поле), «Описание» (многострочное поле), «Дедлайн» (с выбором даты/времени), «Категория/Проект» (выпадающий список), «Приоритет» (например, выбор P0/P1/P2), возможно «Напоминание» (переключатель). Верхняя панель – заголовок «Новая задача» или «Редактировать задачу» и кнопка «Сохранить». Если редактирование, поля предзаполнены текущими значениями. При валидации – например, если не заполнено название – под полем или всплывающим сообщением будет указано, что оно обязательное.

Wireframes для задач покрывают полный функционал менеджера задач: от обзора всего списка до деталей и создания. Они показывают, как пользователь может фильтровать дела (например, выбрав «Сегодня» увидит только сегодняшние задачи), как может быстро отметить задачу выполненной (чекбокс в списке), как просмотреть подробности (тап по задаче) и отредактировать их. Связи между экранами продуманы: после нажатия «Сохранить» на форме – возвращаемся к списку, обновлённому; при удалении задачи – она убирается из списка и, возможно, показывается snackbar с опцией «Отменить». Поскольку эти схемы были согласованы с командой, все обязательные элементы UI (например, фильтры, кнопка добавления) включены заранее, а не добавляются в последний момент.

Примечание: Все указанные wireframes интегрированы в прототип (например, связаны в Figma), чтобы можно было последовательно пройти пользовательский путь: регистрация → вход → основной экран (например, календарь или задачи), создание элемента, и т.д. Это помогло убедиться, что переходы понятны, а также послужило основой для обсуждения с командой и раннего тестирования. Wireframes намеренно низкой детализации (без цвета, шрифтов, лишь блоки и условные обозначения) – это соответствует практике постепенного повышения fidelity: сначала проработка содержания и логики, потом визуального стиля
interaction-design.org
.

Страница "🌟 Ready for Dev" в Figma

После завершения дизайна подготовлена отдельная страница 🌟 Ready for Dev в файле Figma. На эту страницу скопированы все утверждённые фреймы UI Kit и экранов, описанных выше. Выделение отдельной страницы для финальных макетов – часть процесса hand-off, которая облегчает работу разработчиков
jobs.ataccama.com
. Они могут открыть страницу и сразу увидеть все готовые экраны и компоненты, без черновых версий и лишней информации.

Организация страницы:

Сначала размещён блок UI Kit v1.0 – все приоритетные компоненты и стили. Компоненты сгруппированы по категориям: кнопки (со всеми их состояниями), поля ввода, карточки, чипсы, AppBar, BottomNav, индикаторы, примеры цветовой палитры (светлая/тёмная) и образцы текстовых стилей. Каждый компонент представлен единообразно и подписан. Это позволяет разработчикам легко находить нужный элемент и сверяться с его параметрами (например, размеры кнопки, отступы, цвет текста). Страница фактически служит справочником: UI Kit всегда «под рукой» у команды разработки.

Далее идут фреймы экранов, разбитые на разделы по функциональным блокам: Auth, Calendar, Tasks. Например, в секции Auth находятся фреймы Onboarding_v1, Register_v1, Login_v1, Recovery_v1 (названия условные, но следуют шаблону [Экран]_v1). В секции Calendar – Calendar_Day_v1, Calendar_Week_v1, Calendar_Month_v1, Event_New_v1, Event_Details_v1. В секции Tasks – Task_List_v1, Task_Detail_v1, Task_Form_v1. Такое именование (с суффиксом версии) упрощает отслеживание изменений: если экран потребуется доработать, появится версия v2 на той же странице.

Ключевое свойство – все эти фреймы используют компоненты из UI Kit. То есть кнопки, поля, иконки и прочее вставлены как инстансы готовых компонентов. Благодаря этому дизайн экранов строго соответствует библиотеке компонентов: например, Primary-кнопка на экране регистрации – это экземпляр компонента Primary Button из UI Kit (в Figma). Если в UI Kit обновится стиль (скажем, цвет или радиус), он автоматически обновится на всех экранах. Для разработчиков это сигнал, что дизайн консистентен, и они могут переиспользовать одни и те же ресурсы (кнопки, поля) в коде.

Каждый экран на странице снабжён необходимыми аннотациями. В Figma использованы комментарии и Section descriptions для пояснений. Например, рядом с экранами онбординга может быть примечание «Свайп или кнопка “Далее” переводит на следующий слайд», на экране задачи – «Чекбокс помечает задачу выполненной, при этом она уходит из активного списка». Эти пояснения выделены так, чтобы в режимах Dev Mode Figma их тоже было видно. Они помогают разработчикам понять динамику и интерактивное поведение, которое неявно из статичного макета.

Помимо основных (happy path) экранов, на страницу Ready for Dev добавлены и edge-case экраны: пустые состояния, ошибки, офлайн-баннеры. Они либо расположены рядом с соответствующими основными экранами, либо в отдельной секции «States». Например, рядом с Task_List_v1 находится мини-экран Task_List_Empty_v1 с сообщением «У вас нет задач»; рядом с Calendar_Day_v1 – состояние «нет событий»; вынесен отдельно offline-banner. Благодаря этому разработчики видят все вариации интерфейса в одном месте
jobs.ataccama.com
, и ничего не упустится при реализации.

После финальной проверки дизайна все эти фреймы помечены статусом Figma «Ready for dev» (если используется функциональность статусной маркировки). Это служит явным индикатором, что дизайн зафиксирован для разработки
figma.com
. Дизайнеры воздерживаются от внесения изменений на этой странице без соглашения с командой, чтобы избежать расхождений. Более того, по договорённости, любые новые версии экранов (v2) или альтернативные концепты будут на других страницах (например, «Discovery»), а Ready for Dev остается стабильной и отражает именно то, что должно быть реализовано в текущем спринте/MVP.

Такой подход к организации файла получил положительные отзывы внутри команды: «Если макеты явно отмечены как “готово к разработке” и собраны на одной странице, ориентироваться очень легко». Разработчики точно знают, где смотреть, и уверены, что эти экраны актуальны и утверждены. Это снижает количество вопросов и ошибок на этапе реализации, ускоряет интеграцию (так как компоненты и стили уже систематизированы).

========================================
FILE: ./Flutter/LifeMerge_docs/02_Design/UI_Kit/UI Kit & Wireframes figma.md
========================================

LifeMerge UI Kit & Wireframes Implementation

This document summarises the finalised UI Kit v1.0, outlines the key wireframes for the MVP, and lists the screens that are marked as Ready for Development. Since direct editing in Figma is unavailable in this environment, the specifications are provided here for import into your design tool of choice.

UI Kit Components
Buttons

Three button styles are defined: Primary, Secondary and Tertiary. All buttons have a fixed height of 48 pt and rounded corners with a 10 pt radius. States include:

Default – normal background and label colours based on button type.

Pressed – background darkens slightly to indicate active press.

Disabled – lower opacity and muted colours; the button is not interactive.

Loading – shows an inline spinner in place of, or alongside, the label.

Input Fields

Text input fields are sized at 48 pt high and include a label, placeholder, optional icon and helper text. Supported states:

Default – empty field with placeholder text.

Focused – border highlights and the label floats above the input.

Filled – displays the user’s input; label remains above the field.

Error – border changes to the error colour; an error message appears below.

Disabled – muted appearance; the field is read‑only.

Cards

Cards act as containers for related content. They have 12 pt corner radius and a subtle shadow elevation. Three variants exist:

Variant	Use case
TaskCard	Shows task title, due date, priority and status
EventCard	Displays event name, date/time and location
FinanceCard	Contains transaction amount, category and type

Cards may elevate slightly or change shadow on hover or press.

Chips

Chips (tags) are used for categories and filters. They have a height of 28 pt with rounded ends. States include default (neutral border or background), selected (filled with accent colour and contrasting text) and disabled (reduced opacity).

App Bar

The top navigation bar is 56 pt high and contains a title and action icons. It adapts to light and dark themes. The bar may include a back button or menu icon on the left and context‑specific actions on the right.

Bottom Navigation

Bottom navigation consists of five items – Calendar, Tasks, Finance, Inbox and Profile. Each item shows an icon and optional label. States: default (neutral colour) and selected (accent colour and bold label). Icons switch colours in dark mode.

Spinners & Loading Indicators

Use circular spinners for indeterminate processes and skeleton placeholders for loading lists or cards. Where possible, use progress bars to indicate determinate progress. Indicators adopt neutral or primary colours appropriate for the active theme.

Colour Tokens

The palette is defined via tokens to support light and dark themes. Key tokens include:

Token	Description
primary	Main brand colour for highlights
secondary	Secondary accent or supporting colour
background	Page background colour
surface	Surface backgrounds (cards, panels)
error	Colour used for error states
success	Colour used for success messages
warning	Colour used for warnings
onPrimary	Colour of text/icons on a primary surface
onSecondary	Colour of text/icons on secondary surfaces
onBackground	Colour of text/icons on the background
onSurface	Colour of text/icons on a surface

Each token has values for both the light and dark themes to maintain sufficient contrast.

Typography

The type scale defines a clear hierarchy:

Style	Approximate size	Use
H1	32 pt	Main page titles
H2	24 pt	Section titles
H3	20 pt	Subsection headings
Body 1	16 pt	Primary body text
Body 2	14 pt	Secondary text
Caption	12 pt	Annotations and captions
Button	16 pt (bold)	Labels on buttons
Edge Cases & States

Proper handling of edge cases is critical for a polished user experience:

Empty states – when there is no content, show a friendly illustration and a brief message that explains the situation and offers a call‑to‑action to add content.

Error states – use the error colour token to highlight inputs or modules in error; provide clear messages and actions to recover (e.g. a Retry button for network errors).

Loading states – display skeleton placeholders or spinners while data is loading; subtle animations convey that the content is on its way.

Offline states – when connectivity is lost, show a banner or toast informing the user. Disable network‑dependent actions and allow offline functionality where possible. Notify the user once the connection returns.

MVP Wireframes

The following wireframes outline the core screens for the MVP. They are described at a structural level without visual styling so they can be implemented in any design tool.

Auth Screens

Onboarding – a series of slides introducing the value of the app with imagery and short text. Users can navigate forward or skip entirely.

Schedule Setup – an optional step where the user specifies their working pattern or preferred hours to personalise scheduling.

Registration – a form capturing email and password with inline validation and error feedback.

Login – a simple form for returning users to sign in with their credentials; includes an option to stay signed in.

Password Recovery – a two‑step flow to request a password reset via email and to confirm the reset.

Calendar Screens

Day View – detailed schedule for a single day with time slots and events stacked vertically. A floating action button allows creation of a new event.

Week View – a grid of seven columns representing days of the week with events displayed as blocks. Suitable for viewing relative occupancy across the week.

Month View – an overview calendar showing days of the month with subtle markers indicating the presence of events. Selecting a day drills down to the Day View.

Create Event – a form to add a new event: name, date/time picker, location and optional description; includes options for repetition and reminders.

Event Details – displays all information about an event (title, date/time, location, description, participants) and provides actions to edit or delete the event.

Task Screens

Task List – shows all tasks grouped by filters (e.g. by status or priority). Each item has a checkbox to mark it complete.

Task Detail – presents full details of a task: description, due date, context, priority, attachments, and allows editing or deletion.

Task Form – a form for creating or editing tasks; fields include name, description, due date, priority, context and reminder settings.

Ready for Development Screens

The following screens and components have been finalised and are ready to be handed off to engineering. They comply with the UI Kit and meet the Definition of Ready/Done criteria:

Onboarding_v1

Register_v1

Login_v1

Recovery_v1

Calendar_Day_v1

Task_List_v1

Task_Detail_v1

Event_New_v1

Each screen uses components defined in UI Kit v1.0 and accounts for all edge cases and states. These designs align with the MVP scope and can be imported into Figma or another design tool to continue development.

========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/AI/JSON Schema/calendar_min.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/calendar_min.json",
    "title": "CalendarMin",
    "type": "array",
    "items": {
        "type": "object",
        "additionalProperties": false,
        "required": [
            "id",
            "starts_at",
            "ends_at",
            "type",
            "source"
        ],
        "properties": {
            "id": {
                "type": "string",
                "minLength": 1
            },
            "starts_at": {
                "type": "string",
                "format": "date-time"
            },
            "ends_at": {
                "type": "string",
                "format": "date-time"
            },
            "type": {
                "type": "string",
                "enum": [
                    "event",
                    "task_block",
                    "finance_event"
                ]
            },
            "source": {
                "type": "string",
                "enum": [
                    "lifemerge",
                    "google",
                    "apple"
                ]
            },
            "task_id": {
                "type": "string",
                "minLength": 1
            }
        }
    }
}

========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/AI/JSON Schema/goals_min.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/goals_min.json",
    "title": "GoalsMin",
    "type": "array",
    "items": {
        "type": "object",
        "additionalProperties": false,
        "required": [
            "id",
            "title"
        ],
        "properties": {
            "id": {
                "type": "string",
                "minLength": 1
            },
            "title": {
                "type": "string",
                "minLength": 1,
                "maxLength": 128
            }
        }
    }
}

========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/AI/JSON Schema/metadata.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/metadata.json",
    "title": "PlannerMetadata",
    "type": "object",
    "additionalProperties": false,
    "required": [
        "request_id",
        "user_hash",
        "model_version",
        "prompt_version"
    ],
    "properties": {
        "request_id": {
            "type": "string",
            "minLength": 8,
            "maxLength": 128
        },
        "user_hash": {
            "type": "string",
            "minLength": 16,
            "maxLength": 128
        },
        "model_version": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64
        },
        "prompt_version": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64
        },
        "ab_bucket": {
            "type": "string",
            "maxLength": 64
        }
    }
}

========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/AI/JSON Schema/plan_week_request.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/plan_week_request.json",
    "title": "PlanWeekRequest",
    "type": "object",
    "additionalProperties": false,
    "required": [
        "period",
        "tasks",
        "calendar",
        "preferences",
        "goals",
        "metadata"
    ],
    "properties": {
        "period": {
            "type": "object",
            "additionalProperties": false,
            "required": [
                "start_utc",
                "end_utc"
            ],
            "properties": {
                "start_utc": {
                    "type": "string",
                    "format": "date-time"
                },
                "end_utc": {
                    "type": "string",
                    "format": "date-time"
                }
            }
        },
        "tasks": {
            "$ref": "tasks_min.json"
        },
        "calendar": {
            "$ref": "calendar_min.json"
        },
        "preferences": {
            "$ref": "preferences.json"
        },
        "goals": {
            "$ref": "goals_min.json"
        },
        "metadata": {
            "$ref": "metadata.json"
        }
    }
}

========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/AI/JSON Schema/plan_week_response.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/plan_week_response.json",
    "title": "PlanWeekResponse",
    "type": "object",
    "additionalProperties": false,
    "required": [
        "plan",
        "notes",
        "model_version"
    ],
    "properties": {
        "plan": {
            "type": "array",
            "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                    "starts_at",
                    "ends_at",
                    "type"
                ],
                "properties": {
                    "starts_at": {
                        "type": "string",
                        "format": "date-time"
                    },
                    "ends_at": {
                        "type": "string",
                        "format": "date-time"
                    },
                    "type": {
                        "type": "string",
                        "enum": [
                            "task",
                            "rest",
                            "focus"
                        ]
                    },
                    "task_id": {
                        "type": "string",
                        "minLength": 1
                    }
                }
            }
        },
        "notes": {
            "type": "array",
            "items": {
                "type": "string",
                "maxLength": 280
            },
            "maxItems": 32
        },
        "constraints_applied": {
            "type": "array",
            "items": {
                "type": "string",
                "maxLength": 64
            },
            "maxItems": 64
        },
        "model_version": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64
        }
    }
}

========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/AI/JSON Schema/preferences.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/preferences.json",
    "title": "PlannerPreferences",
    "type": "object",
    "additionalProperties": false,
    "required": [
        "timezone",
        "weekend_policy",
        "buffer_minutes_default",
        "focus_windows",
        "forbidden_windows"
    ],
    "properties": {
        "timezone": {
            "type": "string",
            "minLength": 1
        },
        "weekend_policy": {
            "type": "string",
            "enum": [
                "no_tasks",
                "light_only",
                "allow"
            ]
        },
        "buffer_minutes_default": {
            "type": "integer",
            "minimum": 0,
            "maximum": 120
        },
        "focus_windows": {
            "type": "array",
            "items": {
                "$ref": "#/definitions/time_window"
            },
            "maxItems": 28
        },
        "forbidden_windows": {
            "type": "array",
            "items": {
                "$ref": "#/definitions/time_window"
            },
            "maxItems": 56
        }
    },
    "definitions": {
        "time_window": {
            "type": "object",
            "additionalProperties": false,
            "required": [
                "weekday",
                "start",
                "end"
            ],
            "properties": {
                "weekday": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 7
                },
                "start": {
                    "type": "string",
                    "pattern": "^([01]\\d|2[0-3]):[0-5]\\d$"
                },
                "end": {
                    "type": "string",
                    "pattern": "^([01]\\d|2[0-3]):[0-5]\\d$"
                }
            }
        }
    }
}

========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/AI/JSON Schema/tasks_min.json
========================================

{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://lifemerge.ai/schemas/planner/v1/tasks_min.json",
    "title": "TasksMin",
    "type": "array",
    "items": {
        "type": "object",
        "additionalProperties": false,
        "required": [
            "id",
            "title",
            "priority",
            "estimated_minutes",
            "status"
        ],
        "properties": {
            "id": {
                "type": "string",
                "minLength": 1
            },
            "title": {
                "type": "string",
                "minLength": 1,
                "maxLength": 256
            },
            "priority": {
                "type": "string",
                "enum": [
                    "P0",
                    "P1",
                    "P2"
                ]
            },
            "estimated_minutes": {
                "type": "integer",
                "minimum": 5,
                "maximum": 1440
            },
            "due_at": {
                "type": "string",
                "format": "date-time"
            },
            "goal_id": {
                "type": "string",
                "minLength": 1
            },
            "status": {
                "type": "string",
                "enum": [
                    "open",
                    "done",
                    "canceled"
                ]
            }
        }
    }
}

========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/API/AI_Planner_API.md
========================================

# AI Planner API (v1)

## Общие правила
- Требуется Bearer JWT + заголовки `Accept-Language`, `X-Timezone`; лимит 5 запросов/мин на пользователя.
- Используем `request_id` или `X-Idempotency-Key` для отслеживания повторов, все ответы содержат `model_version`.
- Формат ошибок: `{error: {code, message, details?}}`; при недоступности LLM возвращается `503 ai_unavailable`.
- Поля `user_id` не передаются в LLM; вместо них хэш. Все вызовы проходят через сервис аудита с логированием промптов/ответов (без чувствительных данных).

## POST /v1/ai/plan_week
- Body: `{goals[], tasks[], calendar[], preferences{focus_hours[], sleep, timezone}, request_id}`
- Response: `{plan: [ {day, slots:[{starts_at, ends_at, type(task|focus|rest), task_id?}]} ], notes, model_version}`
- В ответ добавляется `request_id` и `generated_at`; сохраняется в таблицу `ai_plans` вместе с `X-AI-Model` и `X-Prompt-Version`.

## POST /v1/ai/insights
- Body: `{period, metrics, request_id}`
- Response: текстовые выводы и списки рекомендаций.
- Поддерживает параметр `tone` (friendly|neutral|direct) для адаптации копирайта.

## POST /v1/ai/rephrase
- Body: `{text, tone (friendly|formal), request_id}`
- Ответ содержит `variants[]` и оценку токсичности входного текста.

## Безопасность
- Требуется Bearer токен; лимит 5 запросов/мин на пользователя.
- Поля `user_id` не передаются в LLM; вместо них хэш.

## Версионирование
- Заголовок `X-AI-Model` и `X-Prompt-Version` для отслеживания качества; сохраняем в `ai_plans`.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/API/Auth_API.md
========================================

# Auth API (v1)

## Общие правила
- Все ответы используют структуру ошибок `{error: {code, message, details?}}`; успешные ответы содержат `request_id` для трассировки.
- Авторизация по Bearer JWT в `Authorization`, кроме `/signup`, `/login`, `/refresh`, `/forgot`, `/reset`.
- Локализация через `Accept-Language`; часовой пояс клиента передаётся в `X-Timezone` и фиксируется в сессии.
- Для защищённых операций поддерживаются `X-Idempotency-Key` и `request_id` (обязательно для серверного аудита и офлайн-синхронизации).
- Все токены выдаются только по HTTPS; refresh токены привязаны к `device_id` и могут быть отозваны для конкретного устройства или всех устройств.

## POST /v1/auth/signup
- body: `{email, password, full_name?, timezone}`
- result: `{user, access_token, refresh_token}`
- Ограничение по частоте: rate limit на пользователя/IP для предотвращения брутфорса.

## POST /v1/auth/login
- body: `{email, password, device_id}`
- result: `{user, access_token, refresh_token}`
- Ответ включает `created_at`, `updated_at`, `deleted` флаг пользователя для корректного состояния клиента.

## POST /v1/auth/refresh
- body: `{refresh_token, device_id}`
- result: `{access_token}`
- При несовпадении `device_id` возвращаем `401` с кодом `refresh_invalid_device`.

## POST /v1/auth/logout
- headers: `Authorization`
- body: `{all_devices?: boolean}`
- result: `{success: true}`

## POST /v1/auth/forgot
- body: `{email}` → письмо с кодом/ссылкой
- Ответ содержит TTL кода и маскированный email назначения.

## POST /v1/auth/reset
- body: `{email, code, new_password}`
- После успешного сброса старые refresh токены инвалидируются.

Общие правила: rate limit для `/signup` и `/forgot`, ответы содержат `request_id`.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/API/Calendar_API.md
========================================

# Calendar API (v1)

## Общие правила
- Требуется `Authorization: Bearer <token>`, заголовки `Accept-Language` и `X-Timezone` для корректного расчёта повторений и длительности.
- Идемпотентность через `request_id` или `X-Idempotency-Key` для всех операций создания/изменения/удаления.
- Ошибки в формате `{error: {code, message, details?}}`; при конфликте `updated_at` возвращается `409` с актуальным событием.
- Ответы включают `created_at`, `updated_at`, `deleted`, `source` (lifemerge/google/apple) для офлайн-синхронизации и разрешения конфликтов.

## GET /v1/calendar/events
- Query: `from`, `to`, `cursor?`, `limit?`, `sources?` (lifemerge/google/apple)
- Пагинация cursor-based; ответ содержит `next_cursor`.

## POST /v1/calendar/events
- Body: `{title, starts_at, ends_at, location?, recurrence_rule?, task_id?, source?, request_id}`
- При `task_id` создаётся привязка задачи к слоту.
- Принимаются временные зоны в ISO-8601; сервер нормализует к TZ пользователя.

## PATCH /v1/calendar/events/{id}
- Body: `{title?, starts_at?, ends_at?, location?, recurrence_rule?, request_id}`
- Для правок серии допускается `apply_to` (this|future|all) в `details`.

## DELETE /v1/calendar/events/{id}
- Soft delete; body `{request_id}`
- Для повторяющихся событий поддерживается `scope` (this|future|all).

## Синхронизация
- `POST /v1/calendar/import` — подключение внешнего календаря (OAuth token в защищённом хранилище).
- `POST /v1/calendar/webhook/google` — точка для уведомлений; подписки на 60 дней вперёд.
- Все события содержат `updated_at` и `source` для разрешения конфликтов.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/API/Finance_API.md
========================================

# Finance API (v1)

## Общие правила
- Все запросы требуют Bearer JWT, а также заголовки `Accept-Language` и `X-Timezone` для нормализации дат и валютных обозначений.
- Для операций записи используем `request_id` или `X-Idempotency-Key`; ответы содержат `created_at`, `updated_at`, `deleted`.
- Пагинация cursor-based (`cursor`, `limit`); формат ошибок `{error: {code, message, details?}}`.
- Все суммы передаются в минорных единицах (integer) или decimal строго с указанием `currency`.

## Категории
- `GET /v1/finance/categories` — список (с `next_cursor` при пагинации).
- `POST /v1/finance/categories` — `{name, type: income|expense, color?, request_id}`
- `PATCH /v1/finance/categories/{id}` — обновление.

## Транзакции
- `GET /v1/finance/transactions` — фильтры: `from`, `to`, `category_id`, `cursor`, `limit`.
- `POST /v1/finance/transactions` — `{amount, currency, category_id?, happened_at, note?, request_id}`
- `PATCH /v1/finance/transactions/{id}` — любые поля + `request_id`.
- `DELETE /v1/finance/transactions/{id}` — soft delete.

## Бюджеты и отчёты
- `POST /v1/finance/budgets` — `{category_id?, period_start, period_end, limit_amount, currency, request_id}`
- `GET /v1/finance/summary` — агрегаты по периодам, прогноз до конца месяца, перерасход.
- Все отчёты содержат поле `currency` и временные интервалы, нормализованные к TZ пользователя.

Все суммы в API передаются в копейках/центах (integer) либо decimal, согласовано по `currency`.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/API/Goals_API.md
========================================

# Goals API (v1)

## Общие правила
- Все запросы защищены Bearer JWT; заголовки `Accept-Language` и `X-Timezone` обязательны для корректного отображения сроков.
- Изменяющие операции требуют `request_id` или `X-Idempotency-Key` для идемпотентности (офлайн-режим, повторные отправки).
- Пагинация cursor-based: `cursor`, `limit`; ответы возвращают `next_cursor`.
- Ошибки оформляются как `{error: {code, message, details?}}`; при конфликте по `updated_at` возвращается `409`.

## GET /v1/goals
- Query: `status?`, `area?`, `cursor?`, `limit?`
- Ответ дополнительно отдаёт агрегаты по связанным задачам (`tasks_open`, `tasks_done`).

## POST /v1/goals
- Body: `{title, description?, area?, target_date?, request_id}`
- При создании можно передать стартовый `progress` и список связанных `task_ids`.

## PATCH /v1/goals/{id}
- Body: `{title?, description?, area?, target_date?, status?, progress?, request_id}`
- При смене статуса на `completed` фиксируется `completed_at`.

## DELETE /v1/goals/{id}
- Soft delete; body `{request_id}`.
- Удаление каскадно архивирует связанные задачи (статус deferred).

## Метрики и прогресс
- `GET /v1/goals/{id}/progress` — агрегированный прогресс по задачам.
- `POST /v1/goals/{id}/progress` — ручное обновление прогресса `{progress, note?, request_id}`.
- Ответ включает связанные активные задачи (до 5) для виджета «Фокус дня».


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/API/Inbox_API.md
========================================

# Inbox API (v1)

## Общие правила
- Авторизация: `Authorization: Bearer <token>`, поддержка `Accept-Language` и `X-Timezone`.
- Все записи имеют `created_at`, `updated_at`, `deleted`; изменяющие операции требуют `request_id` или `X-Idempotency-Key`.
- Ответы и ошибки следуют формату `{error: {code, message, details?}}` и всегда возвращают `request_id` для трассировки.
- Пагинация cursor-based (`cursor`, `limit`) с `next_cursor` в ответе.

## GET /v1/inbox
- Query: `status?`, `cursor?`, `limit?`
- Возвращает список входящих элементов с метаданными источника (`source`, `payload_type`).

## POST /v1/inbox
- Body: `{source, payload, request_id}` — создание входящего элемента (из виджета/интеграции).
- Для ассистента допускается `context` (текст) для последующей конвертации AI.

## POST /v1/inbox/{id}/convert
- Body: `{type: task|event|note, mapped_fields, request_id}` — конвертация во внутренние сущности.
- В ответе возвращается созданная сущность и обновлённый статус inbox-элемента.

## PATCH /v1/inbox/{id}
- Body: `{status?, payload?, request_id}` (статусы: new, converted, archived).
- При конфликте по `updated_at` возвращается `409`.

## DELETE /v1/inbox/{id}
- Body: `{request_id}`

Ответы содержат `created_at` и `updated_at`, пригодны для офлайн-синхронизации.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/API/OpenAPI.yaml
========================================

openapi: 3.0.3
info:
  title: LifeMerge API
  version: 1.0.0
servers:
  - url: https://api.stage.lifemerge/v1
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  parameters:
    AcceptLanguage:
      in: header
      name: Accept-Language
      schema: { type: string, example: ru-RU }
      required: false
      description: UI локализация, влияет на тексты ошибок и уведомлений
    Timezone:
      in: header
      name: X-Timezone
      schema: { type: string, example: Europe/Moscow }
      required: false
      description: Часовой пояс клиента, используется для дат и повторений
    Cursor:
      in: query
      name: cursor
      schema: { type: string }
      required: false
      description: Токен курсора для пагинации
    Limit:
      in: query
      name: limit
      schema: { type: integer, minimum: 1, maximum: 100, default: 20 }
      required: false
      description: Количество элементов в ответе
  schemas:
    ErrorResponse:
      type: object
      properties:
        error:
          type: object
          properties:
            code: { type: string }
            message: { type: string }
            details: { type: object }
    Task:
      type: object
      properties:
        id: { type: string, format: uuid }
        title: { type: string }
        description: { type: string }
        goal_id: { type: string, format: uuid, nullable: true }
        due_at: { type: string, format: date-time, nullable: true }
        created_at: { type: string, format: date-time }
        updated_at: { type: string, format: date-time }
        deleted: { type: boolean }
    TaskCreate:
      type: object
      required: [title]
      properties:
        title: { type: string }
        description: { type: string }
        goal_id: { type: string, format: uuid }
        due_at: { type: string, format: date-time }
        request_id: { type: string }
paths:
  /auth/login:
    post:
      summary: User login
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - $ref: '#/components/parameters/Timezone'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email: { type: string, format: email }
                password: { type: string }
                device_id: { type: string }
      responses:
        '200':
          description: tokens
        '401':
          description: invalid credentials
          content:
            application/json:
              schema: { $ref: '#/components/schemas/ErrorResponse' }
  /tasks:
    get:
      summary: List tasks
      security:
        - bearerAuth: []
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - $ref: '#/components/parameters/Timezone'
        - in: query
          name: status
          schema: { type: string }
        - in: query
          name: goal_id
          schema: { type: string, format: uuid }
        - in: query
          name: due_from
          schema: { type: string, format: date-time }
        - in: query
          name: due_to
          schema: { type: string, format: date-time }
        - $ref: '#/components/parameters/Cursor'
        - $ref: '#/components/parameters/Limit'
      responses:
        '200':
          description: ok
          content:
            application/json:
              schema:
                type: object
                properties:
                  items:
                    type: array
                    items: { $ref: '#/components/schemas/Task' }
                  next_cursor: { type: string, nullable: true }
        '401':
          description: unauthorized
          content:
            application/json:
              schema: { $ref: '#/components/schemas/ErrorResponse' }
    post:
      summary: Create task
      security:
        - bearerAuth: []
      parameters:
        - $ref: '#/components/parameters/AcceptLanguage'
        - $ref: '#/components/parameters/Timezone'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TaskCreate'
      responses:
        '201':
          description: created
          content:
            application/json:
              schema: { $ref: '#/components/schemas/Task' }
        '409':
          description: conflict (duplicate request_id)
          content:
            application/json:
              schema: { $ref: '#/components/schemas/ErrorResponse' }


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/API/Tasks_API.md
========================================

# Tasks API (v1)

## Общие правила
- Требуется `Authorization: Bearer <token>`, `Accept-Language` и `X-Timezone` для корректных дат дедлайнов.
- Для всех изменяющих операций передаётся `request_id` или `X-Idempotency-Key` (гарантия идемпотентности при офлайн-синхронизации).
- Пагинация cursor-based: параметры `cursor`, `limit`; ответы возвращают `next_cursor`.
- Ошибки: `{error: {code, message, details?}}`, например `validation_error`, `not_found`, `conflict` (при обновлении устаревшей версии `updated_at`).

## GET /v1/tasks
- Query: `status?`, `goal_id?`, `due_from?`, `due_to?`, `cursor?`, `limit?`
- Response: список задач + `next_cursor`.
- У каждой записи есть `created_at`, `updated_at`, `deleted` для офлайн-режима.

## POST /v1/tasks
- Body: `{title, description?, goal_id?, due_at?, priority?, estimated_minutes?, energy_level?, request_id}`
- Response: созданная задача.
- При создании можно передать `reminder_at[]` для мгновенной подписки на напоминания.

## PATCH /v1/tasks/{id}
- Body: любые изменяемые поля + `request_id`.
- Конфликты по `updated_at` возвращают `409` с актуальной задачей в `details.current`.

## DELETE /v1/tasks/{id}
- Soft delete. Body: `{request_id}`.
- Удалённые задачи помечаются `deleted=true` и остаются доступными в истории синка.

## Подзадачи
- `POST /v1/tasks/{id}/subtasks` → `{title, request_id}`
- `PATCH /v1/subtasks/{subtask_id}` → `{title?, done?, request_id}`
- Подзадачи наследуют `updated_at` для разрешения конфликтов.

## Напоминания/статусы
- `POST /v1/tasks/{id}/status` → `{status, request_id}` (todo/in_progress/done/deferred)
- `POST /v1/tasks/{id}/reminders` → `{remind_at}`
- Ответы содержат `updated_at` для разрешения конфликтов офлайн-синхронизации.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/Architecture/AI_Architecture.md
========================================

# AI Architecture

## Сервисы
- **AI Planner API:** принимает профиль пользователя, цели, занятость календаря, предпочтения энергии/фокуса, возвращает план недели.
- **Insights:** генерирует текстовые резюме недели/финансов, теги для задач и целей.
- **Safety Layer:** проверка токенов, лимиты на объём текста, фильтрация запрещённого контента.

## Поток планирования
1. Backend собирает контекст (цели, задачи, события, предпочтения) и отправляет в AI сервис.
2. AI сервис вызывает LLM (внешний провайдер), применяет промпт-шаблоны и пост-обработку (нормализация дат, ограничения бюджета времени).
3. Результат сохраняется в БД через backend (`ai_plans` + связанные задачи/события), пользователю показывается diff.

## Технические детали
- Реализация на Python/Node, контейнер; запросы через REST `/v1/plan`, `/v1/summary`.
- Асинхронная обработка через очередь; синхронный ответ только для быстрых подсказок (<3 сек).
- Логирование запросов обезличено (hash user_id), содержимое подсказок хранится в зашифрованном виде.
- Версионирование промптов и моделей (`model_version`, `prompt_version`) для сравнения качества.

## Качество и безопасное использование
- Метрики: время отклика, % успешных планов, % ручных правок пользователем, жалобы на качество.
- A/B: сравнение разных промптов/моделей на когортах stage/prod.
- Fallback: при недоступности LLM — базовый план на шаблонах (распределение задач по приоритету и сроку).


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/Architecture/Backend_Architecture.md
========================================

# Backend Architecture

## Модули
- **Auth:** регистрация, вход, refresh, устройства, роли.
- **Tasks/Goals:** CRUD, подзадачи, напоминания, статусы, прогресс целей.
- **Calendar:** события, повторения, синхронизация с внешними календарями.
- **Finance:** транзакции, категории, бюджеты, отчёты.
- **Inbox:** сбор уведомлений/входящих идей с конвертацией в задачи/события.
- **Notifications:** пуши/почта, расписания триггеров.

## Технологии
- REST API (FastAPI/Express), PostgreSQL, Redis для кеша и сессий, Celery/BullMQ для очередей.
- Авторизация через JWT, rate-limit middleware, OpenAPI спецификация генерируется автоматически.
- Модульная монолитная структура или микросервисы (Auth+Core, AI отдельный) в зависимости от нагрузки.

## Паттерны
- DTO ↔ Domain мапперы, репозитории для БД, сервисы с бизнес-логикой.
- Idempotency для POST/PATCH/DELETE, optimistic locking с `updated_at`.
- Вебхуки для синхронизации календарей, retry с экспоненциальной задержкой.

## Масштабирование
- API горизонтально за балансером; воркеры масштабируются по метрикам очереди.
- Кеширование справочников и публичных настроек; heavy-вычисления в воркерах.
- Фичефлаги для дорогих функций (AI, интеграции) и для миграций данных.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/Architecture/Data_Model/Database_Schema.sql
========================================

-- LifeMerge core schema (PostgreSQL)

CREATE TABLE users (
    id UUID PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    currency CHAR(3) NOT NULL DEFAULT 'USD',
    is_pro BOOLEAN NOT NULL DEFAULT false,
    trial_end TIMESTAMPTZ,
    full_name TEXT,
    timezone TEXT NOT NULL DEFAULT 'UTC',
    role TEXT NOT NULL DEFAULT 'user',
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE goals (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    category TEXT,
    deadline TIMESTAMPTZ,
    progress NUMERIC(5,2) DEFAULT 0,
    status TEXT NOT NULL DEFAULT 'active',
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE tasks (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    goal_id UUID REFERENCES goals(id) ON DELETE SET NULL,
    title TEXT NOT NULL,
    description TEXT,
    context TEXT,
    energy_level TEXT CHECK (energy_level IN ('light','medium','heavy')),
    estimated_minutes INTEGER,
    priority TEXT DEFAULT 'P2' CHECK (priority IN ('P0','P1','P2')),
    deadline TIMESTAMPTZ,
    is_recurring BOOLEAN NOT NULL DEFAULT false,
    recurrence_rule TEXT,
    status TEXT NOT NULL DEFAULT 'open' CHECK (status IN ('open','done','canceled')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted BOOLEAN NOT NULL DEFAULT false
);

CREATE TABLE subtasks (
    id UUID PRIMARY KEY,
    task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    done BOOLEAN NOT NULL DEFAULT false,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE finance_categories (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    type TEXT NOT NULL CHECK (type IN ('income','expense')),
    color TEXT,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE finance_transactions (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    category_id UUID REFERENCES finance_categories(id) ON DELETE SET NULL,
    type TEXT NOT NULL CHECK (type IN ('income','expense')),
    linked_event_id UUID,
    is_recurring BOOLEAN NOT NULL DEFAULT false,
    recurrence_rule TEXT,
    amount NUMERIC(14,2) NOT NULL,
    currency CHAR(3) NOT NULL DEFAULT 'USD',
    happened_at TIMESTAMPTZ NOT NULL,
    transaction_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    note TEXT,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted BOOLEAN NOT NULL DEFAULT false
);

CREATE TABLE calendar_events (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    type TEXT NOT NULL CHECK (type IN ('event','task_block','finance_event')),
    linked_task_id UUID REFERENCES tasks(id) ON DELETE SET NULL,
    linked_finance_id UUID REFERENCES finance_transactions(id) ON DELETE SET NULL,
    title TEXT NOT NULL,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    location TEXT,
    source TEXT DEFAULT 'lifemerge',
    category TEXT,
    recurrence_rule TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted BOOLEAN NOT NULL DEFAULT false
);

CREATE TABLE inbox_items (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    text TEXT,
    type TEXT NOT NULL CHECK (type IN ('idea','task','goal','finance')),
    source TEXT, -- email, widget, integration
    payload JSONB NOT NULL,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active','processed')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE budgets (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    category_id UUID REFERENCES finance_categories(id) ON DELETE SET NULL,
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    limit_amount NUMERIC(14,2) NOT NULL,
    currency CHAR(3) NOT NULL DEFAULT 'USD'
);

CREATE TABLE ai_plans (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    plan_json JSONB NOT NULL,
    prompt_version TEXT,
    model_version TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_tasks_user_deadline ON tasks(user_id, deadline);
CREATE INDEX idx_events_user_start ON calendar_events(user_id, start_time);
CREATE INDEX idx_fin_tx_user_date ON finance_transactions(user_id, happened_at);


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/Architecture/Mobile_Architecture_Flutter.md
========================================

# Mobile Architecture (Flutter)

## Слои
- **Presentation:** `views`, `widgets`, `state` (riverpod/provider), маршруты через `go_router`.
- **Domain:** use-cases (например, `planWeek`, `syncTasks`), модели без зависимостей на Flutter.
- **Data:** репозитории (API + локальное хранилище), мапперы DTO ↔ domain, кеширование.
- **Infrastructure:** HTTP клиент, secure storage, аналитика, пуши.

## Офлайн/онлайн
- Локальная БД `sqflite` содержит задачи, события, транзакции, цели, очереди операций.
- При отсутствии сети операции складываются в `pending_operations` с `request_id`; синк при восстановлении соединения.
- Конфликты: правило «сервер выигрывает», но UI показывает diff и позволяет принять локальную версию.

## Навигация и модули
- Отдельные модули: `auth`, `tasks`, `calendar`, `goals`, `finance`, `inbox`, `settings`.
- Common UI: `lifemerge_theme`, `AppScaffold`, `primary_button`, `sheet_header` из UI Kit.

## Тестирование
- Widget тесты для списков задач, календаря, финансовых графиков.
- Golden тесты для базовых компонентов UI Kit.
- Интеграционные тесты сценариев: онбординг, создание задачи, офлайн-режим.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/Architecture/Offline_Sync_Design.md
========================================

# Offline Sync Design

## Цели
- Позволить создавать/редактировать задачи, события, финоперации без сети.
- Избежать потери данных и дублей при восстановлении соединения.

## Локальные данные
- Храним в `sqflite` таблицы `tasks_local`, `events_local`, `transactions_local`, `pending_operations`.
- Каждая запись содержит `local_id`, `server_id`, `updated_at_local`, `updated_at_server`, `sync_status`.

## Очередь операций
- Формат операции: `{type, entity, payload, request_id, created_at}`.
- Синхронизатор отправляет батчами (до 20 операций) в `/sync/batch` или соответствующие модули.
- В случае конфликта сервер возвращает 409 с актуальной версией; клиент показывает diff.

## Политики конфликта
- **Last Write Wins** по `updated_at`, но если разница >24h, показываем выбор пользователю.
- Удаления помечаются `deleted=true` и синхронизируются как soft delete.

## Дополнительное
- Фоновая синхронизация при смене сети или раз в 15 минут на фоне.
- При logout очищаем локальные таблицы и pending-очередь.
- Журналируем ошибки синка и отправляем в Sentry.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/Architecture/Personalization_ML_Spec.md
========================================

# ML Personalization Module — Input/Output Specification

## Назначение
Модуль персонализации отвечает за подготовку признаков и вызов ML/LLM-модели, которая адаптирует планирование, подсказки и приоритеты под конкретного пользователя. Спецификация фиксирует контракт входных данных и ожидаемых выходов, чтобы бэкенд и AI-сервис были согласованы.

## Общие правила
- Все идентификаторы пользователей и устройств передаются в захешированном виде (`sha256(user_id)`).
- Часовой пояс обязателен, время — в ISO 8601 с таймзоной.
- Денежные суммы указываются в базовой валюте профиля, строки валют — по ISO 4217.
- Пустые поля не отправляются; для необязательных массивов допускается `[]`.

## Входные данные (Input)
JSON-пакет `PersonalizationContext` передается из backend в ML-сервис:

```json
{
  "user_profile": {
    "user_hash": "string",
    "locale": "ru-RU",
    "timezone": "Europe/Moscow",
    "work_pattern": "5/2",
    "focus_hours": [{"start": "09:00", "end": "12:00"}],
    "no_go_periods": [{"weekday": "sun", "reason": "rest"}]
  },
  "behavior": {
    "tasks": [
      {
        "id_hash": "string",
        "title": "string",
        "priority": "P0|P1|P2",
        "context": "home|office|mobile|travel|custom",
        "energy": "light|medium|heavy",
        "estimated_minutes": 45,
        "deadline": "2024-11-20T18:00:00+03:00",
        "status": "open|done|canceled",
        "created_at": "2024-11-10T07:00:00+03:00",
        "completed_at": "2024-11-11T09:20:00+03:00"
      }
    ],
    "events": [
      {
        "id_hash": "string",
        "type": "event|task_block|finance_event",
        "starts_at": "2024-11-14T10:00:00+03:00",
        "ends_at": "2024-11-14T11:00:00+03:00",
        "title": "string",
        "linked_task_id_hash": "string|null"
      }
    ],
    "goals": [
      {
        "id_hash": "string",
        "title": "string",
        "category": "career|health|finance|family|learning|other",
        "deadline": "2025-03-01T00:00:00+03:00",
        "progress": 0.35
      }
    ],
    "finance": {
      "currency": "RUB",
      "regular_cashflow": [{"type": "income|expense", "amount": 75000, "interval": "monthly", "next_date": "2024-12-01"}],
      "last_transactions": [{"amount": -1200, "category": "food", "ts": "2024-11-12T13:00:00+03:00"}]
    },
    "engagement": {
      "session_count_7d": 9,
      "task_completion_rate_7d": 0.62,
      "ai_plan_accept_rate": 0.74,
      "feedback_events": [{"type": "like|dislike", "subject": "ai_plan", "ts": "2024-11-11T10:00:00+03:00"}]
    }
  },
  "constraints": {
    "hard_rules": ["no_heavy_after_20:00", "min_gap_15m"],
    "max_daily_work_minutes": 480
  },
  "request": {
    "request_id": "uuid",
    "model_version": "string",
    "prompt_version": "string",
    "target_horizon": "day|week"
  }
}
```

### Поля и валидация
- `user_profile.work_pattern`: одно из `5/2`, `2/2`, `3/3`, `custom`.
- `behavior.tasks[].priority`: `P0` обязательно имеет `deadline`; `estimated_minutes` > 0.
- `behavior.events[]`: `starts_at < ends_at`; если `type == task_block`, поле `linked_task_id_hash` обязательно.
- `behavior.finance.regular_cashflow[].interval`: `daily|weekly|monthly|yearly`.
- `constraints.hard_rules`: набор строковых токенов, согласованных между backend и AI-сервисом.

## Выходные данные (Output)
Ответ ML-сервиса `PersonalizationResult` возвращается в backend:

```json
{
  "request_id": "uuid",
  "generated_at": "2024-11-13T08:00:00Z",
  "model_version": "string",
  "prompt_version": "string",
  "personalization": {
    "ranked_tasks": [
      {"task_id_hash": "string", "score": 0.87, "reason": "high priority before deadline"}
    ],
    "suggested_slots": [
      {
        "task_id_hash": "string",
        "starts_at": "2024-11-14T09:30:00+03:00",
        "ends_at": "2024-11-14T10:15:00+03:00",
        "confidence": 0.81
      }
    ],
    "nudges": [
      {"type": "habit|focus|finance|energy", "message": "Сделай тяжёлую задачу до 11:00", "priority": "high|medium|low"}
    ],
    "ab_experiment": {"cohort": "B", "features": {"tone": "direct", "slot_length": 45}},
    "profile_updates": {
      "detected_focus_hours": [{"start": "08:30", "end": "11:30"}],
      "preferred_contexts": ["office", "mobile"],
      "anomalies": ["low_completion_3d"]
    }
  },
  "constraints_applied": ["no_heavy_after_20:00", "min_gap_15m"],
  "safety": {"redacted_fields": ["title"], "tokens": 3240}
}
```

### Интерпретация выходов
- `ranked_tasks`: отсортированный список для рекомендаций и авто-планирования; `score` в диапазоне `[0,1]`.
- `suggested_slots`: кандидаты для вставки в календарь; backend валидирует конфликты перед сохранением.
- `nudges`: микро-рекомендации для уведомлений/баннеров; `priority` задаёт канал доставки.
- `ab_experiment`: выбранные параметры для текущего пользователя, чтобы фиксировать в аналитике.
- `profile_updates`: сигналы, которые можно сохранить в `user_settings` после подтверждения бизнес-логикой.
- `constraints_applied`: набор правил, учтённых при генерации, для аудита и дебага.
- `safety`: метаданные о редактировании текста и токенизации.

## Контроль качества
- Обязательные проверки на стороне backend: соответствие `request_id`, допустимость таймслотов, ограничения по рабочему времени и валюте.
- Логирование: сохраняем `request_id`, `model_version`, `prompt_version`, `hashes` сущностей, но не сохраняем исходные тексты задач/заметок.
- Метрики: точность принятия слотов, % выполненных задач из рекомендованных, CTR по `nudges`, доля пользователей с обновлёнными `focus_hours` после 7 дней.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/Architecture/System_Architecture.md
========================================

# System Architecture

## Компоненты
- **Mobile (Flutter):** UI, офлайн-кеш, очередь синхронизации, пуши.
- **Backend API:** Auth, Tasks, Calendar, Goals, Finance, Notifications, Feature Flags.
- **AI Service:** планирование недели, подсказки целей, резюме недели, тональная коррекция писем.
- **Data Layer:** PostgreSQL + Redis (кеш/сессии) + S3-хранилище.
- **Async:** очередь (RabbitMQ/Redis Streams) + воркеры для синхронизаций, AI, интеграций.
- **Monitoring:** Grafana/Prometheus, Sentry, Crashlytics.

## Потоки данных (упрощённо)
1. Пользователь создаёт задачу в приложении → сохраняется локально → синхронизируется на сервер через `/tasks` → фоновые воркеры пушат напоминания.
2. Импорт из Google Calendar: backend-воркер получает вебхук, обновляет события, отправляет пуш об изменениях.
3. AI-планирование: backend формирует контекст (цели, расписание), отправляет в AI сервис, получает расписание и пишет в таблицу `ai_plans` + задачи.

## Нефункциональные аспекты
- Горизонтальное масштабирование API и воркеров, sticky-сессии не требуются (stateless).
- Кеширование справочников и результатов AI на 24 часа.
- Резервное копирование БД ежедневно, тест восстановления еженедельно.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/DevOps/CI_CD_Pipeline.md
========================================

# CI/CD Pipeline

## CI (pull request)
1. Lint/format: `dart format --set-exit-if-changed`, `flutter analyze`, `ruff`/`eslint` для бекенда/AI.
2. Unit/widget tests: `dart test`, `pytest`, `npm test` (если фронт веб).
3. Сборка мобильного клиента в `--debug` для smoke, выгрузка артефактов в CI.
4. Генерация OpenAPI и проверка `scripts/validate_openapi.sh`.

## CD
- **Develop → Dev**: авто-деплой backend/AI через Docker + Helm, прогон миграций, загрузка демоданных.
- **Release candidate → Stage**: ручной триггер, подпись мобильных билдов (internal test), прогон регресса.
- **Prod**: мажорные релизы через change approval, канареечный rollout 10% → 50% → 100% за 24 часа.

## Артефакты
- Контейнеры собираются через BuildKit, публикуются в приватный registry.
- Мобильные `.ipa/.aab` хранятся в артефакт-репозитории с метаданными версии, commit SHA, окружения.

## Качество
- Codecov/coveralls с порогом >70% для ключевых модулей (tasks, calendar, finance).
- SAST/Dependency scan (Trivy/Snyk) обязательны перед stage/prod.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/DevOps/Deployment_Guide.md
========================================

# Deployment Guide

## Подготовка
- Проверить миграции БД и обратную совместимость API.
- Убедиться, что `OpenAPI.yaml` обновлён и прошёл валидацию.
- Настроить переменные окружения (см. Environments.md), обновить secrets в Vault.

## Backend/AI
1. Собрать образы `backend:<tag>` и `ai-service:<tag>`.
2. Применить Helm-чарты: `helm upgrade --install lifemerge-backend charts/backend -f values/<env>.yaml`.
3. Выполнить миграции: `alembic upgrade head` или `prisma migrate deploy` (в зависимости от стека).
4. Проверить readiness/liveness, метрики, отсутствие 5xx в логах.

## Мобильные клиенты
- iOS: `flutter build ipa --flavor <env>`; загрузить в TestFlight/App Store Connect.
- Android: `flutter build appbundle --flavor <env>`; загрузить в Play Console/внешние сторы.
- Проверить совместимость с минимальной поддерживаемой версией, обновить changelog.

## Проверки после релиза
- Smoke-тест: логин, создание задачи/события, синхронизация офлайн → онлайн, операция с финансами.
- Проверить алёрты, дашборды и crash-free; вернуть rollout, если error rate > допустимого порога.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/DevOps/Deployment_Plan.md
========================================

# Deployment Plan — Draft Environment CI/CD

## Цель
Описать, как черновой стенд (Draft) автоматически собирается и разворачивается из CI/CD, чтобы разработчики получали изолированные сборки для раннего тестирования без влияния на Dev/Stage/Prod.

## Триггеры и ветки
- **feature/** и **bugfix/**: авто-сборка и деплой чернового стенда по каждому push в MR/PR.
- **manual re-run**: ручной перезапуск job для восстановления стенда или проверки фиксов.
- **auto-cleanup**: тайм-аут жизни стенда 48 часов; после merge/close MR стенд уничтожается.

## Пайплайн
1. **Lint/Static Analysis**: `flutter analyze`, `dart test --coverage` для клиента; `pytest -q` и `ruff`/`eslint` для backend/AI.
2. **Сборка контейнеров**: BuildKit, теги `draft-<branch>-<sha>` публикуются в приватный registry.
3. **Деплой**: Helm-чарт в namespace `draft-<branch>` с `values/draft.yaml`; включаем mock-провайдеры внешних интеграций.
4. **Миграции**: `alembic upgrade head` / `prisma migrate deploy` против отдельной Draft-БД; обратная совместимость обязательна.
5. **Smoke-тест**: `scripts/smoke_draft.sh` — логин, создание задачи, синхронизация офлайн → онлайн.
6. **Отчёт**: URL стенда и артефакты сборки публикуются в MR/PR комментарии.

## Роллбек и очистка
- Helm rollback на предыдущий релиз (`helm rollback <release> 1`) по детекту 5xx/ошибок readiness.
- После merge/закрытия MR job `cleanup_draft` удаляет namespace, секреты и storage claims.

## Требования к секретам
- Secrets и токены берутся из Vault/KMS по пути `draft/<team>/<service>`; доступ ограничен service account CI.
- В пайплайне используются временные credentials (TTL ≤ 1 час), чтобы уборка не блокировалась утечками ключей.

## Логи и наблюдаемость
- Включен stdout/stackdriver/ELK сбор логов для всех pod в namespace `draft-*`.
- Метрики и алёрты общие с Dev, но с отдельными неймспейс-фильтрами; частота проверок раз в 5 минут.

## Передача в Dev/Stage
- Merge в `develop` переключает пайплайн на Dev по существующим правилам (см. CI_CD_Pipeline.md).
- Принятые фичи получают тег `draft-tested` в release notes, если smoke прошёл на черновом стенде.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/DevOps/Environments.md
========================================

# Environments

| Среда | Назначение | URL/API | Особенности |
|-------|------------|---------|-------------|
| **Dev** | Быстрая разработка | `https://api.dev.lifemerge` | Авто-сборки из `develop`, моковые интеграции, открытые тест-аккаунты |
| **Stage** | Приёмка/QA | `https://api.stage.lifemerge` | Данные приближены к прод, feature flags по умолчанию включены, нагрузочные тесты |
| **Prod** | Пользовательская | `https://api.lifemerge.app` | Полные метрики/алёрты, белые списки IP для админки |

## Управление конфигурацией
- Секреты в Vault/KMS, подключение через переменные окружения.
- Feature flags (Unleash/LaunchDarkly) для AI-функций, офлайна, платёжных интеграций.
- Версии мобильных приложений фиксируются через `min_supported_version` в конфиге backend.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/DevOps/Infrastructure_Spec.md
========================================

# Infrastructure Spec — Draft Environment

## Контур
- **Кластер**: K8s (managed, 3×nodes t3.medium/4vCPU/8GB), отдельный namespace `draft-*` на общем кластере с Dev.
- **Сеть**: ingress с базовой аутентификацией, IP allowlist ограничен офис/VPN; egress через NAT с ограничением к внешним API.
- **БД**: отдельный PostgreSQL instance per-branch (`draft_<branch>`), размер до 10 GB, авто-удаление с retention 2 дня.
- **Файлы**: S3 совместимое хранилище с bucket `lifemerge-draft` и prefix `branches/<branch>/`; lifecycle 7 дней.
- **Кэш/очереди**: Redis c ограничением 256MB per-namespace, RabbitMQ shared vhost `draft`.

## Конфигурация сервисов
- **Backend/AI**: деплой через Helm-чарты `charts/backend` и `charts/ai` с overlays `values/draft.yaml`.
- **Мобильные билд-серверы**: билд-агенты в CI (Linux/macOS runners) с кэшем зависимостей; артефакты в `artifacts/draft/`.
- **Secrets/Config**: `values/secrets-draft.yaml` формируются из Vault; токены интеграций заменяются на моки.

## Наблюдаемость
- Логи: stdout → Loki/ELK с label `env=draft`.
- Метрики: Prometheus scrape `draft-*`; дашборд Grafana “Draft Stand” с SLA: error rate <2%, аптайм 95%.
- Трейсинг: OpenTelemetry с экспортом в Jaeger, сэмплинг 5% для контроля нагрузки.

## Политики безопасности
- RBAC: доступ к namespace только через сервис-аккаунт CI и группу DevOps-readonly.
- Образы проходят проверку Trivy, сигнатуры Notary; pull только из приватного registry через imagePullSecrets.
- NetworkPolicy закрывает межсервисное общение, разрешает только ingress от IngressController и egress к Redis/DB.

## Интеграция с CI/CD
- Pipeline создаёт namespace, секреты и параметры БД динамически, затем применяет `helm upgrade --install`.
- После завершения MR job `cleanup_draft` удаляет namespace, PVC и префикс в S3, освобождая квоты.
- Для экономии ресурсов включена автопауза pod при простое (keda/hpa до 0 реплик) и cron на удаление старых артефактов.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/DevOps/Monitoring_and_Logging.md
========================================

# Monitoring & Logging

## Метрики
- Backend: latency/таймауты по эндпоинтам, ошибки 4xx/5xx, очередь задач, использование БД (CPU, connections, slow queries).
- AI сервис: время ответа, количество токенов, процент fallbacks, очередь job'ов.
- Мобильный клиент: crash-free %, время запуска, FPS на ключевых экранах.

## Логирование
- Формат JSON, обязательные поля: `timestamp`, `level`, `service`, `request_id`, `user_id`, `path`, `latency_ms`.
- PII маскируем; отключаем body для финансовых операций.
- Корреляция через `request_id` между сервисами.

## Алёрты (пример)
- API error rate >5% за 5 минут.
- Latency p95 > 400 мс на `/tasks` или `/calendar`.
- Очередь фоновых задач > 1k сообщений 10 минут.
- Crash-free mobile < 98% за сутки.

## Дашборды
- Grafana/Datadog для сервисных метрик, Sentry для ошибок, Firebase Crashlytics для мобильных.
- Общий продуктовый дашборд: MAU, удержание D1/D7, активность по модулям (календарь, задачи, финансы).


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/Requirements/API_Requirements.md
========================================

# Требования к API

- REST/JSON, префикс `/v1`, консистентные коды ошибок и тело `{error:{code,message,details}}`.
- Авторизация через Bearer JWT, поддержка refresh; все запросы по HTTPS.
- Пагинация cursor-based (`cursor`, `limit`), ответы с `next_cursor`.
- Идемпотентность: `X-Idempotency-Key` или `request_id` для изменяющих операций.
- Все ресурсы содержат `updated_at`, `created_at`, `deleted` (soft delete) для офлайн-синхронизации.
- Локализация через `Accept-Language`, часовой пояс через `X-Timezone`.
- Rate limit по IP и пользователю; отдельные квоты для AI-вызовов.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/Requirements/Functional_Requirements.md
========================================

# Функциональные требования (MVP)

1. **Регистрация/логин/восстановление** по email + пароль; ограничение устройств.
2. **Задачи**: создание/редактирование/удаление, приоритет, дедлайны, подзадачи, напоминания, статусы, офлайн-режим.
3. **Календарь**: события с повторениями, привязка задач к слотам, синхронизация с Google/Apple, просмотр день/неделя/месяц.
4. **Цели**: создание целей, области жизни, прогресс, связь с задачами, краткие отчёты прогресса.
5. **Финансы**: категории доходов/расходов, транзакции, бюджеты, дашборд месяца.
6. **Inbox**: сбор идей/уведомлений, конвертация в задачи/события.
7. **AI**: планирование недели с учётом задач/календаря/предпочтений, текстовые инсайты.
8. **Уведомления**: пуши о задачах/событиях, дневной/недельный дайджест.
9. **Аналитика**: события для Mixpanel/Amplitude (активация, создание задач, удержание).


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/Requirements/NonFunctional_Requirements.md
========================================

# Нефункциональные требования (NFR)

## Производительность
- p95 для основных API (/tasks, /calendar, /finance) ≤ 400 мс на Stage при нагрузке 200 RPS.
- Синхронизация офлайн-очереди < 5 сек для 20 операций.

## Надёжность
- Доступность прод сервисов 99.5% в месяц.
- Автоматические бэкапы БД ежедневно, RPO ≤ 24 часа, RTO ≤ 4 часа.

## Безопасность
- Все соединения по HTTPS, хранение токенов в защищённых хранилищах.
- Шифрование дисков, ротация ключей раз в 90 дней, журнал аудита для действий админов.

## Масштабируемость
- Горизонтальное масштабирование API/воркеров, stateless обработчики.
- Кеширование справочников, очереди для тяжёлых операций (AI, импорт календаря).

## Юзабилити
- Поддержка тёмной темы, шрифты и контраст в соответствии с WCAG AA.
- Время первого запуска приложения < 3 сек на устройствах уровня Pixel 6 / iPhone 12.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/Requirements/Technical_Specification.md
========================================

# Technical Specification (кратко)

- **Платформы:** Flutter iOS/Android, backend REST на FastAPI/Express, AI-сервис отдельный.
- **БД:** PostgreSQL, Redis для кеша и сессий.
- **Фичи MVP:** auth, задачи, календарь, цели, финансы, inbox, AI-планирование недели.
- **Интеграции:** Google/Apple Calendar, FCM/APNs, внешняя LLM API.
- **Офлайн:** локальная БД + очередь операций, конфликты по `updated_at`.
- **Обновления:** OpenAPI.yaml генерируется автоматически, мобильные клиенты через App Store/Play с feature flags.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/Security/Authentication.md
========================================

# Authentication & Authorization

## Флоу входа
1. Пользователь вводит email/пароль → `/auth/login`.
2. Backend возвращает `access_token` (15–30 мин), `refresh_token` (30 дней), `user_profile`.
3. Access хранится в памяти клиента, refresh — в защищённом хранилище (Keychain/Keystore).
4. При истечении access вызываем `/auth/refresh` с `refresh_token`.

## Регистрация и восстановление
- Signup: email + пароль + согласие с политиками; письмо для верификации.
- Восстановление пароля: одноразовый код/ссылка, ограничения по частоте (5 запросов/час).
- Ограничение устройств: по умолчанию до 3 активных refresh-токенов; `logout_all` отзывает остальные.

## Авторизация
- Роли: `user` (по умолчанию), `admin`, `support` (read-only). Проверка ролей в middleware.
- Доступ к объектам проверяем по `user_id` + флагам доступа (для будущего шеринг-модуля).
- Для AI-вызовов добавляем доп. лимиты и контроль объёма входного текста.

## Безопасность токенов
- Формат JWT: `sub`, `role`, `exp`, `iat`, `device_id`.
- Подпись: RS256, приватный ключ в KMS. Ключи ротируются каждые 90 дней, `kid` в заголовке.
- Чёрный список refresh-токенов в Redis/PostgreSQL (`revoked_tokens`).

## Аудит
- Логируем входы/выходы, смену пароля, подозрительные IP/гео, попытки доступа к чужим ресурсам.
- Пользователь может просмотреть последние активные сессии и отозвать их.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/Security/Data_Protection.md
========================================

# Data Protection

## Хранение данных
- **Бэкенд:** PostgreSQL с шифрованием томов (AES-256), резервные копии ежедневно с хранением 30 дней.
- **Файлы:** документы/изображения в S3-совместимом хранилище, шифрование на стороне сервера, приватные bucket.
- **Клиент:** локальная БД шифруется паролем ОС; чувствительные поля (токены, email) — через secure storage.

## Управление персональными данными
- Минимизация: собираем только email, имя, часовой пояс; финданные всегда привязаны к user_id.
- Пользователь может экспортировать JSON/CSV с задачами, целями, транзакциями; удаление аккаунта инициирует очистку в течение 30 дней.
- Логирование PII запрещено; используем маскировку для номеров карт и сумм.

## Передача данных
- Все соединения TLS 1.2+, HSTS, отключены слабые шифры; HTTP → HTTPS редирект.
- WebSockets (позже) только wss:// с проверкой токена на connect/refresh.
- Push-токены передаются только по HTTPS и хранятся отделенно от профилей.

## Соответствие требованиям
- Соответствие GDPR-подобным принципам: согласие, право на удаление, ограничение цели сбора.
- DPIA проводится для AI-функций; данные для обучения анонимизируются.
- Доступ разработчиков к прод-данным только через break-glass процесс с аудитом.


========================================
FILE: ./Flutter/LifeMerge_docs/03_Technical/Security/Threat_Model.md
========================================

# Threat Model (LifeMerge)

## Акторы
- **Злоумышленник без учётки:** пытается получить доступ к API, подделать трафик, подменить приложение.
- **Скомпрометированный пользователь:** пытается украсть/подменить данные других пользователей.
- **Внутренний нарушитель:** доступ к логам/базе, попытка извлечь PII и финданные.

## Основные угрозы и меры
1. **Кража токенов доступа**
   - HTTPS везде, `secure`/`HttpOnly` для refresh-cookie в web, для mobile храним в OS Keychain/Keystore.
   - Ротация refresh каждые 30 дней, отзыв токенов при logout/all-devices.
2. **Инъекции и эскалация прав**
   - Parametrized queries/ORM; входные данные валидируются схемами, лимиты длины.
   - RBAC: проверки на уровне handler и сервисов, аудит действий admin/support.
3. **Подмена/утечка данных при синхронизации**
   - Подпись ответов `ETag`, HSTS, защита от downgrade TLS, pinning сертификата в мобильном приложении.
   - Консистентность через `updated_at` и версии записей.
4. **Утечка PII и финансовых данных из логов/бэкапов**
   - Маскирование карт и сумм в логах, шифрование бэкапов и снапшотов, доступ по VPN/KMS.
5. **DDoS и rate abuse**
   - Rate limit per IP/user, капча на signup, отдельные лимиты для дорогих AI-вызовов.
6. **Loss/Corruption данных клиента**
   - Защита локальной БД паролем ОС, шифрование AES-256; периодический бэкап пользовательских настроек в облако (opt-in).

## Остаточные риски
- Социальная инженерия и фишинг вне приложения.
- Утечки на стороне сторонних интеграций (Google/Apple/банки) — минимизируются мониторингом и отзывом токенов.


========================================
FILE: ./Flutter/LifeMerge_docs/04_Development/Backlog/Bugs.md
========================================

# Known bugs

| ID | Компонент | Описание | Приоритет | Статус |
|----|-----------|----------|-----------|--------|
| BUG-1 | Calendar sync | Дублируются события при повторном импорте из Google при смене таймзоны | High | In progress |
| BUG-2 | Tasks offline | Изменённые подзадачи не уходят в очередь синхронизации при потере сети | High | To Do |
| BUG-3 | Finance charts | Некорректное округление копеек в диаграмме расходов (на iOS) | Medium | To Do |
| BUG-4 | Notifications | Пуш «Начни день» приходит в 00:00, не учитывается пользовательский часовой пояс | High | In progress |
| BUG-5 | AI Planner | При пустом описании цели возвращается 500 вместо валидационной ошибки | Medium | To Do |


========================================
FILE: ./Flutter/LifeMerge_docs/04_Development/Backlog/Features.md
========================================

# Feature backlog

1. **Смарт-планировщик недели (AI Planner v1)**
   - Ввод: цели, приоритеты, доступные слоты календаря.
   - Вывод: предложение расписания + задачи на неделю с учётом энергии/фокуса.
2. **Финансовый дашборд**
   - Визуализации расходов/доходов, бюджеты по категориям, прогноз остатка до конца месяца.
3. **Интеграции с календарями**
   - Импорт событий из Google/Apple, выбор календарей, двусторонняя синхронизация будущих 60 дней.
4. **Виджеты на главный экран**
   - iOS/Android: задачи дня, прогресс цели, баланс бюджета.
5. **Совместная работа (Pro roadmap)**
   - Шеринг задач/проектов с ролями «читатель/редактор», комментарии и упоминания.


========================================
FILE: ./Flutter/LifeMerge_docs/04_Development/Backlog/Tech_Debt.md
========================================

# Tech Debt backlog

| ID | Область | Описание | Риск | План фикса |
|----|---------|----------|------|------------|
| TD-1 | Мобильный клиент | Неполное покрытие unit-тестами use-case «планирование недели» | Средний | Добавить тесты на пересчёт расписания и синхронизацию до спринта 3 |
| TD-2 | Backend Tasks | Нет дедубликации idempotency-key для повторных POST задач | Высокий | Ввести уникальный индекс по `request_id` и фоновые задачи для очистки записей | 
| TD-3 | AI сервис | Векторизация описаний целей синхронная, блокирует запрос | Средний | Перевести в очередь Celery/BullMQ, добавить кэш по goal_id |
| TD-4 | DevOps | Отсутствует автоматика ротации ключей JWT/FCM | Высокий | Настроить KMS и cron-ротацию раз в 90 дней |
| TD-5 | Данные | Нет истории изменений задач | Низкий | Добавить audit-таблицу и soft delete в схеме v1.1 |


========================================
FILE: ./Flutter/LifeMerge_docs/04_Development/Coding_Standards/API_Usage_Guide.md
========================================

# Руководство по использованию API

## Аутентификация
- Получаем `access_token` и `refresh_token` через `/auth/login` (см. Auth_API.md).
- Добавляем `Authorization: Bearer <token>` к каждому запросу.
- При 401 с причиной `token_expired` вызываем `/auth/refresh`, повторяем оригинальный запрос с тем же `request_id`.

## Общие правила запросов
- **Базовый URL:** определяется окружением (`DEV_API_BASE`, `STAGE_API_BASE`, `PROD_API_BASE`).
- **Версионирование:** используем префикс `/v1/` для всех путей.
- **Идемпотентность:** для POST/PATCH/DELETE передаём `X-Idempotency-Key` или поле `request_id` в body.
- **Пагинация:** `?limit=50&cursor=<ts_or_id>`; получаем `next_cursor` в ответе.
- **Локализация/часовой пояс:** заголовок `X-Timezone` (IANA) и `Accept-Language`.

## Ошибки
- Формат: `{ "error": { "code": "validation_error", "message": "...", "details": {...} } }`.
- Статусы: 400 валидация, 401 auth, 403 permissions, 404 not found, 409 конфликт версии, 429 лимиты, 500/503 сервер.
- Все клиенты логируют `request_id` из ответа или заголовка.

## Практики для мобильного клиента
- Отправлять `app_version`, `platform`, `device_id` в заголовках для аналитики и feature flags.
- Кешировать справочники (категории задач/финансов) с TTL и ETag; при 304 используем локальные данные.
- Объединять небольшие изменения в батчи (например, до 20 событий календаря) для снижения сетевых вызовов.
- Использовать `If-Modified-Since`/`If-None-Match` при загрузке календаря и задач.

## Тестовые данные
- В dev/stage заведены тест-аккаунты `demo_userX@example.com` с предзаполненными задачами, целями и транзакциями.
- Для нагрузочных тестов генерируйте синтетические данные через скрипт `tools/seed_demo_data.py` (backend репозиторий).


========================================
FILE: ./Flutter/LifeMerge_docs/04_Development/Coding_Standards/Architecture_Rules.md
========================================

# Архитектурные правила LifeMerge

Документ обобщает договорённости из TECHNICAL SPECIFICATIONS и ТЗ для реализации Flutter-клиента, backend и AI-сервисов.

## Базовые принципы
- **Слойность:** презентация → application/service → domain → infrastructure. Прямых зависимостей от UI к хранилищу нет.
- **Чистые модели:** DTO для сети/БД, domain-модели для логики, мапперы обязательны.
- **Idempotency & retries:** все mutating-эндпоинты backend принимают `request_id` для безопасных повторов.
- **Трассировка:** каждый запрос несёт `X-Request-Id`; логируем путь, пользователя, время, статус.

## Интеграции
- **AI-сервис:** отдельный REST, вызывается backend-воркерами. UI не ходит к AI напрямую.
- **Платёжки/FCM/APNs:** обёрнуты адаптерами; конфиги через переменные окружения.

## Данные и офлайн
- **Единый источник истины:** серверная БД PostgreSQL. Клиент хранит кеш (sqflite) + очередь синхронизации.
- **Версионирование схемы:** миграции через `migration_version`; несовместимые изменения только по фичефлагу.
- **Конфликты:** правило «последний апдейт выигрывает» с сохранением истории изменений для задач/событий.

## Безопасность
- JWT access (15–30 мин) + refresh; все сервисы ходят только по HTTPS.
- Роли: user, admin, support; проверка авторизации на уровне handler + сервис.
- PII и финансовые суммы логируются только в хэшированном/маскированном виде.

## Производительность
- Пагинация по cursor/`updated_at`, лимит 50 записей по умолчанию.
- Индексы по `(user_id, due_date)`, `(user_id, status)` для задач, `(user_id, date)` для транзакций.
- Критичные запросы тестируются на 95‑перцентиль не более 200 мс в stage-среде.


========================================
FILE: ./Flutter/LifeMerge_docs/04_Development/Coding_Standards/Dart_Style_Guide.md
========================================

# Dart Style Guide (LifeMerge)

- Следуем официальному `dart style`; используем `dart format` без переопределения ширины строки.
- Именование: классы/enum в `PascalCase`, методы/поля/переменные в `camelCase`, константы в `lowerCamel` с `k` не используем.
- Публичные API должны иметь `///` документацию с примерами использования.
- Избегаем `dynamic` и `!`; используем null-safety, опциональные поля помечаем `?`.
- Коллекции неизменяемые по умолчанию (`UnmodifiableListView`, `const` widgets) когда это безопасно.
- Обработка ошибок через `Either<Result, Failure>` или `Result<T>` вместо выбрасывания исключений в бизнес-логике.
- Импортируем через `package:lifemerge/...`; относительные импорты только внутри модуля.
- Файлы экранов/виджетов именуем по компоненту: `tasks_list_page.dart`, `task_tile.dart`, `goal_progress_chart.dart`.
- Не добавляем `try/catch` вокруг импортов; используется автоматический анализ зависимостей pub.


========================================
FILE: ./Flutter/LifeMerge_docs/04_Development/Coding_Standards/Flutter_Best_Practices.md
========================================

# Flutter: лучшие практики

## Архитектура клиента
- Используем **MVVM + Provider/riverpod** для управления состоянием экранов.
- Навигация через `go_router`; маршруты описываем декларативно, учитывая deeplink из пушей.
- Разделяем слой данных (`repositories`), домена (`use_cases`), UI (`views/widgets`).

## Работа с сетью
- HTTP-клиент оборачиваем в `ApiClient` с перехватчиками для токенов и логов.
- Повтор запросов с backoff для сетевых ошибок, но не более 3 попыток.
- Сериализация через `json_serializable`, время передаём в ISO8601 + timezone.

## UI и доступность
- Используем дизайн-токены из `UI_Kit/Design_Tokens.json` и кастомные `ThemeExtension`.
- Минимальный размер тапа 44×44, контраст текста WCAG AA.
- Все иконки и тексты должны поддерживать тёмную тему; тестируем на эмуляторах iOS/Android.

## Офлайн
- Локальное хранилище `sqflite` + `hive` для быстрых настроек.
- Очередь синхронизации хранит pending-операции; при восстановлении сети выполняем батчами.
- Конфликты показываем пользователю (баннер) с выбором варианта или автопринятием сервера.

## Качество
- Unit-тесты для `use_cases` и мапперов, widget-тесты для ключевых экранов (календарь, задачи, финансы).
- Включаем `flutter analyze`, `dart format`, `dart test` в pre-push hook.
- Производительность проверяем `profile`-сборкой: время фрейма < 16 мс на целевых девайсах Pixel 6 / iPhone 12.


========================================
FILE: ./Flutter/LifeMerge_docs/04_Development/Sprint_Planning/Template_Sprint_Plan.md
========================================

# Sprint {{номер}} – Planning

## 1. Sprint Goals
- Цель 1  
- Цель 2  

---

## 2. Sprint Backlog
| ID | User Story | Задача | Story Points | Ответственный |
|----|------------|--------|--------------|----------------|

---

## 3. Capacity
| Член команды | Доступные часы | Комментарий |
|--------------|----------------|--------------|

---

## 4. Risks
- Риск 1  
- Риск 2  

---

## 5. Definition of Done (DoD)
| Компонент | Критерий |
|-----------|----------|

---

## 6. Retro Notes (по окончании)
- Что получилось  
- Что не получилось  
- Что улучшить  


========================================
FILE: ./Flutter/LifeMerge_docs/05_QA/Automation/CI_Test_Config.md
========================================

# CI Test Config

- Запуск `dart test` и `flutter test --tags=smoke` на каждом PR.
- Backend/AI: `pytest -q`, `npm test` (если Node), покрытие >70% для ядра.
- Lint: `dart format --set-exit-if-changed`, `flutter analyze`, `ruff`, `eslint`.
- Интеграционные тесты (эмуляторы) ночью по расписанию: онбординг, создание задачи, синк офлайн → онлайн.
- Отчёты в CI: JUnit + coverage, отправка в Codecov; уведомления в Slack/Telegram при падениях.


========================================
FILE: ./Flutter/LifeMerge_docs/05_QA/Checklists/Regression_Checklist.md
========================================

# Regression Checklist (основные блоки)

## Аутентификация
- [ ] Signup/login/logout/refresh, восстановление пароля.

## Задачи/Цели
- [ ] CRUD задач и подзадач, напоминания, статусы.
- [ ] Фильтры/сортировки, поиск.
- [ ] Связка задач с целями, обновление прогресса целей.

## Календарь
- [ ] Создание/редактирование/удаление событий, повторения.
- [ ] Синхронизация с внешними календарями, обработка вебхуков.

## Финансы
- [ ] CRUD категорий и транзакций, бюджеты.
- [ ] Корректные валюты и округление.

## Inbox/Уведомления
- [ ] Добавление элементов inbox, конвертация в задачи/события.
- [ ] Получение пушей и настройка времени отправки.

## Офлайн/Синхронизация
- [ ] Рабочие сценарии офлайн → онлайн, отсутствие дублей.

## AI
- [ ] План недели создаётся, корректно создаёт задачи/события.
- [ ] Ограничения по лимитам/ошибкам отображаются корректно.


========================================
FILE: ./Flutter/LifeMerge_docs/05_QA/Checklists/Release_Checklist.md
========================================

# Release Checklist

- [ ] Все задачи релиза в статусе Done, нет блокеров.
- [ ] Пройдены Smoke и Regression (см. отдельные чеклисты).
- [ ] Билды подписаны и загружены в TestFlight/Play Console.
- [ ] Миграции БД применены на stage и проверены.
- [ ] Алёрты/дашборды сконфигурированы для версии.
- [ ] Обновлены маркетинговые тексты и privacy policy.
- [ ] План отката согласован, проверено восстановление из бэкапа.


========================================
FILE: ./Flutter/LifeMerge_docs/05_QA/Checklists/Smoke_Test_Checklist.md
========================================

# Smoke Test Checklist

- [ ] Установка/запуск приложения (iOS/Android).
- [ ] Регистрация нового пользователя и логин существующего.
- [ ] Создание задачи, изменение статуса, удаление.
- [ ] Создание события календаря, привязка задачи, просмотр расписания.
- [ ] Добавление цели, связка задач с целью.
- [ ] Добавление расхода/дохода, просмотр дашборда.
- [ ] Получение пуша-напоминания.


========================================
FILE: ./Flutter/LifeMerge_docs/05_QA/QA_Plan.md
========================================

# 🧪 QA PLAN — LifeMerge (MVP, Pro 1.0+ Ready)

## 1. Цели QA

1. Обеспечить стабильную работу **ядра продукта**:

   * календарь,
   * задачи/цели,
   * финансы,
   * GTD Inbox,
   * AI-планировщик,
   * подписки и уведомления.
2. Минимизировать риск **потери/порчи данных** (особенно задач, целей, финансов).
3. Подтвердить, что:

   * UX соответствует дизайну,
   * логика Free/Pro соблюдается,
   * AI **не нарушает** пользовательские правила.
4. Обеспечить предсказуемое качество на каждом релизе (регрессия).

---

## 2. Область охвата (Scope)

### Входит:

* Мобильные приложения: iOS + Android.
* Все ключевые модули:

  * Регистрация/логин.
  * Календарь + рабочие графики.
  * Задачи/цели/проектная структура.
  * Финансы (доходы/расходы/регулярные).
  * Inbox (GTD).
  * AI-планировщик (Pro).
  * Уведомления.
  * Подписки/Trial.
  * Настройки (тема, уведомления, график, язык RU).
* Offline-режим (кэш + отложенная синхронизация).

### Не входит (на этап MVP, но отмечается как future):

* Web-версия.
* Полноценный конфликт-менеджмент при синхронизации.
* Сложная интеграция банков/HealthKit/Google Fit.
* Полностью автономный режим AI.

---

## 3. Типы тестирования

1. **Unit-тесты**

   * Бизнес-логика (use cases).
   * Парсинг/сериализация данных.
   * Локальные валидаторы.

2. **Integration tests**

   * Клиент ↔️ backend (через staging API).
   * Работа offline-очереди.
   * AI-запросы и обработка ответов.

3. **UI/UX (manual + automated)**

   * Отображение экранов.
   * Навигация.
   * Состояния (loading / empty / error).

4. **End-to-End (E2E)**

   * Жизненные сценарии:

     * создание цели → задач → расписание → финансы → AI-план → отчёт.

5. **Регрессионное тестирование**

   * Перед каждым релизом.

6. **Non-functional**

   * Производительность (basic).
   * Устойчивость (long-run).
   * Usability (ручное, по чек-листам).

7. **Security & Privacy (базовый уровень)**

   * Валидация auth-флоу.
   * Нет утечек чувствительных данных в логах.

---

## 4. Стратегия по уровням

### 4.1. Unit-тесты

**Цель:** поймать ошибки логики до UI/интеграции.

Покрыть:

* расчёт прогресса по целям,
* вычисление баланса бюджета,
* генерация временных интервалов в календаре,
* обработку настроек рабочего графика,
* базовую подготовку данных для AI-запроса.

**Критерий:**
для MVP — покрытие ключевых use-case модулей ≥ 70%.

---

### 4.2. Integration tests

Проверяем:

* корректность API-контрактов:

  * Auth,
  * Tasks,
  * Calendar,
  * Finance,
  * AI.
* работу локального кэша + синка:

  * создаём задачу offline → получаем её на другом устройстве после sync.

---

### 4.3. UI/UX тестирование

* Проверяем макеты Figma vs. реализация:

  * сетка,
  * типографика,
  * отступы,
  * состояния.
* Особо:

  * Тёмная тема.
  * Пустые состояния (нет задач, нет операций).
  * Ошибки (нет сети, ошибка AI, backend down).

---

### 4.4. E2E сценарии (основные)

**Сценарий 1: «Новый пользователь Free»**

1. Установка → онбординг.
2. Регистрация аккаунта.
3. Настройка рабочего графика.
4. Создание пары задач и цели.
5. Добавление финансовых записей.
6. Проверка календаря и пушей.

**Сценарий 2: «Pro с AI-планировщиком»**

1. Активация Trial (с тестовой картой).
2. Создание набора задач с приоритетами, дедлайнами, контекстами.
3. Запуск AI-планировщика на неделю.
4. Проверка:

   * AI не залез в запретные зоны (вечер, выходные, non-working).
   * расписание выглядит логично.
5. Принятие плана.
6. Проверка, что план реально применился в календаре.

**Сценарий 3: «Finance + Calendar»**

1. Добавить зарплату (регулярный доход).
2. Добавить несколько расходов (с и без привязки к событиям).
3. Привязать расход к событию в календаре (поход в кафе).
4. Проверить месячный отчёт.

**Сценарий 4: «Inbox → действие»**

1. Набросать 5–10 элементов в Inbox.
2. Превратить часть в задачи, часть в цели, часть в финансовые события.
3. Проверить, что всё корректно отобразилось в соответствующих разделах.

---

## 5. Test Matrix (что тестируется особенно тщательно)

### Модули и приоритет:

| Модуль         | Приоритет         | Уровень тестирования         |
| -------------- | ----------------- | ---------------------------- |
| Auth           | Высокий           | Unit, Integration, E2E       |
| Календарь      | Критический       | Unit, Integration, UI, E2E   |
| Задачи/цели    | Критический       | Unit, Integration, UI, E2E   |
| Финансы        | Высокий           | Unit, Integration, E2E       |
| Inbox          | Средний           | Integration, UI, E2E         |
| AI-планировщик | Критический (Pro) | Integration, E2E, спец-тесты |
| Подписки/Trial | Высокий           | Integration, E2E             |
| Уведомления    | Высокий           | Integration, device tests    |
| Настройки      | Средний           | UI, Integration              |
| Offline/sync   | Высокий           | Integration, E2E             |

---

## 6. Подход к AI-тестированию

### Особенность: AI ≠ детерминированный код.

### Что тестируем:

1. **Формат запроса/ответа**

   * структуру JSON,
   * обработку ошибок,
   * timeout.

2. **Соблюдение жёстких правил**

   * тест-кейсы:

     * Пользователь запрещает вечерние слоты → AI **не ставит** туда задачи.
     * Пользователь указывает выходной день → AI не планирует там работу.
     * Минимальный буфер между задачами → слоты не слепляются.

3. **Граничные кейсы**

   * очень много задач (AI должен часть оставить «unscheduled», а не ломать расписание),
   * очень мало свободного времени.

4. **UX-поведение**

   * если AI вернул пустой/ошибочный ответ:

     * показывается дефолтное сообщение,
     * приложение не крашится,
     * пользователь может продолжать вручную.

---

## 7. Стратегия по платформам и девайсам

### 7.1. iOS

* Минимальная версия: iOS 14
* Тестовые девайсы:

  * iPhone SE (малый экран),
  * iPhone 13/14 (основной),
  * желательно одно «старое» устройство.

### 7.2. Android

* Минимальная версия: Android 8 (API 26)
* Тестовые девайсы:

  * бюджетный (низкая мощность),
  * средний,
  * флагман (высокая частота, разные dpi).

Обязательно проверять:

* акцентные элементы (цвета/тексты) на разных DPI,
* корректность темы,
* пуши при закрытом приложении.

---

## 8. Test Environments

1. **Dev environment**

   * нестабильный,
   * использует dev-ветку,
   * данные могут очищаться.

2. **Staging environment**

   * максимально близок к продакшену:

     * та же схема БД,
     * тот же набор сервисов.
   * используется для:

     * интеграционных и E2E тестов,
     * regression перед релизом.

3. **Production**

   * только мониторинг, hotfix-проверки.

---

## 9. Test Artifacts

1. **Test Cases**

   * подробные шаги и expected results,
   * покрывают все User Stories.

2. **Checklists**

   * быстрые проверки перед релизом (smoke + sanity).

3. **Bug reports**

   * оформляются в системе тикетов (Jira/YouTrack):

     * шаги,
     * фактический результат,
     * ожидаемый результат,
     * severity (Critical/Major/Minor),
     * скриншоты/видео.

4. **Test Summary Reports**

   * после каждого спринта/релиза:

     * что тестировалось,
     * сколько тест-кейсов прошло/провалилось,
     * какие критические баги остались/исправлены.

---

## 10. Критерии начала тестирования (Entry Criteria)

* Feature/branch собран в **staging-билд**.
* Пройдены unit-тесты.
* Есть:

  * актуальные макеты,
  * описание бизнес-логики,
  * настройки тестовых аккаунтов (Free, Pro, Trial).
* Backend для нужного функционала развёрнут и доступен.

---

## 11. Критерии завершения тестирования (Exit Criteria)

* Все **критические** баги исправлены.
* **Major** — либо исправлены, либо согласованы и вынесены в backlog с пометкой.
* Регрессионные тесты пройдены по ключевым флоу:

  * логин,
  * календарь,
  * задачи,
  * финансы,
  * AI-планировщик,
  * подписки.
* Test Summary Report подготовлен и одобрен.

---

## 12. Риски и как их снижать

1. **AI непредсказуем в редких кейсах**

   * Решение:

     * жёсткие hard constraints,
     * fallback, UI-предупреждения.

2. **Разночтения между mobile и backend API**

   * Решение:

     * контрактные тесты,
     * Postman collection / OpenAPI.

3. **Баги в оффлайн-сценариях**

   * Решение:

     * отдельные E2E кейсы для offline → online,
     * тесты с выключением сети во время операций.



========================================
FILE: ./Flutter/LifeMerge_docs/06_Release/AppStore/Description.md
========================================

# App Store / Google Play Description (draft)

**LifeMerge — единое приложение для времени, целей и финансов.**

- Планируйте день и неделю в одном календаре.
- Управляйте задачами и целями, отслеживайте прогресс.
- Ведите расходы и бюджеты, получайте финансовые инсайты.
- AI-помощник предложит расписание и подскажет приоритеты.
- Работает офлайн, синхронизируется между устройствами.

**Почему LifeMerge?**
- Всё в одном: календарь, задачи, цели, финансы.
- Лёгкий старт: готовые шаблоны и умные подсказки.
- Для людей из СНГ: локализация, рубли/тенге/гривны, напоминания в нужном часовом поясе.

Поддержка: support@lifemerge.app


========================================
FILE: ./Flutter/LifeMerge_docs/06_Release/AppStore/Privacy_Policy.md
========================================

# Privacy Policy (кратко)

- Мы собираем: email, имя, часовой пояс, данные задач/целей/финансов, технические метаданные устройства.
- Используем: для оказания сервиса, персонализации, аналитики (Mixpanel/Amplitude), отправки уведомлений.
- Не продаём данные третьим лицам; передача только обработчикам (хостинг, аналитика) по договорам.
- Данные хранятся на защищённых серверах, резервируются; пользователи могут запросить выгрузку или удаление аккаунта.
- Cookies/токены применяются для аутентификации и сессий; пуш-токены хранятся отдельно.
- Контакты: privacy@lifemerge.app


========================================
FILE: ./Flutter/LifeMerge_docs/06_Release/Beta_Testing/Beta_Feedback.md
========================================

# Beta Feedback Process

## Сбор
- Форма Google/Typeform: NPS, удовлетворённость по модулям (календарь, задачи, финансы, AI), багрепорты.
- Встроенная кнопку «Сообщить об ошибке» (отправляет логи + скрин по согласию).
- Телеграм-чат с быстрыми опросами.

## Обработка
- Все фидбеки заносятся в борд: тип (bug/UX/feature), приоритет, модуль, воспроизводимость.
- Критичные баги → горячие фиксы до следующего билда; улучшения — в backlog.
- Еженедельный дайджест по метрикам: activation, crash-free, time to first value.

## Ответ пользователям
- Благодарность и статус: принято/в работе/отклонено.
- Релиз-ноты тестовых сборок с закрытыми пунктами.


========================================
FILE: ./Flutter/LifeMerge_docs/06_Release/Beta_Testing/Invitations.md
========================================

# Beta Testing Invitations

## Кого зовём
- Ранние пользователи из целевой аудитории (25–40, СНГ), существующие клиенты productivity-сообщества.
- Команда/партнёры, сотрудники компании.

## Каналы
- Email-рассылка по списку ожидания.
- Телеграм-канал/чат с инструкциями и обратной связью.
- App Store TestFlight и закрытый трек Google Play.

## Сообщение-приглашение (шаблон)
```
Привет! Запускаем бету LifeMerge — планировщик времени, целей и финансов.
1) Установи приложение по ссылке <TestFlight/Google Play>.
2) Пройди онбординг и создай минимум 3 задачи и 1 цель.
3) Поделись фидбеком в форме: <ссылка>.
Спасибо! Команда LifeMerge
```


========================================
FILE: ./Flutter/LifeMerge_docs/06_Release/Release_Plan.md
========================================

# Release Plan

## Milestones
1. **Beta (Internal)** — сбор фидбека, crash-free >95%, основные баги закрыты.
2. **Release Candidate (Stage)** — подключены платёжные/календари, регрессия пройдена.
3. **Prod Launch** — rollout 10→50→100%, мониторинг метрик, поддержка 24/7 первые 72 часа.

## Чеклист перед выкладкой
- Пройдены Smoke/Regression чек-листы (см. QA/Checklists).
- Миграции БД применены и протестированы на stage.
- Обновлены маркетинговые материалы (App Store/Google Play), privacy policy.
- Настроены алёрты и дашборды.

## Пост-релиз
- Мониторинг error rate, p95, crash-free; план обратного отката.
- Сбор фидбека от первых пользователей, быстрые фиксы.


========================================
FILE: ./Flutter/pubspec.yaml
========================================

name: lifemerge
description: LifeMerge Flutter client
publish_to: "none"

version: 0.1.0+1

environment:
  sdk: ">=3.4.0 <4.0.0"

dependencies:
  flutter:
    sdk: flutter
  flutter_riverpod: ^2.5.1
  go_router: ^14.2.7
  flutter_localizations:
    sdk: flutter
  shared_preferences: ^2.3.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^4.0.0

flutter:
  uses-material-design: true
  # NOTE: UI Kit uses Inter. Font assets will be added later; theme already sets fontFamily.


========================================
FILE: ./Flutter/README.md
========================================

# LifeMerge (Flutter)

Flutter client for LifeMerge.

## Architecture
- `lib/core/` — shared infrastructure (DI, routing, theme)
- `lib/features/<feature>/{presentation,application,domain,data}` — feature modules

This repository currently contains a project skeleton for Sprint 01 (foundation + A1).


========================================
SUMMARY:
Total files processed: 0
Total files skipped: 0
Total bytes written: 0
Output file: project_dump.txt
Script excluded: combine_md.sh
========================================
